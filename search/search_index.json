{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"efxdev-docs"},{"location":"demo/","tags":["hyped","dodoche"],"text":"Toto For full documentation visit mkdocs.org . HTML for content and structure JavaScript for interactivity CSS for text running out of boxes Internet Explorer ... huh? Ctrl + Alt + Del Lorem ipsum 1 dolor sit amet, consectetur adipiscing elit. 2 Tab 1 Tab 2 Lorem ipsum dolor sit amet, (1) consectetur adipiscing elit. I'm an annotation! Phasellus posuere in sem ut cursus (1) I'm an annotation as well! Method Description GET Fetch resource PUT Update resource DELETE Delete resource stateDiagram-v2 state fork_state <<fork>> [*] --> fork_state fork_state --> State2 fork_state --> State3 state join_state <<join>> State2 --> join_state State3 --> join_state join_state --> State4 State4 --> [*] Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Back to index Welcome to MkDocs For full documentation visit mkdocs.org . Question Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa. Commands HTML for content and structure JavaScript for interactivity CSS for text running out of boxes Internet Explorer ... huh? mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. Go to toto 1 2 3 # Code block content import React from 'react' ; const toto = React . useState ( 0 ); # Code block content bubble_sort.py def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] Toto For full documentation visit mkdocs.org . HTML for content and structure JavaScript for interactivity CSS for text running out of boxes Internet Explorer ... huh? Ctrl + Alt + Del Lorem ipsum 1 dolor sit amet, consectetur adipiscing elit. 2 Tab 1 Tab 2 Lorem ipsum dolor sit amet, (1) consectetur adipiscing elit. I'm an annotation! Phasellus posuere in sem ut cursus (1) I'm an annotation as well! Method Description GET Fetch resource PUT Update resource DELETE Delete resource stateDiagram-v2 state fork_state <<fork>> [*] --> fork_state fork_state --> State2 fork_state --> State3 state join_state <<join>> State2 --> join_state State3 --> join_state join_state --> State4 State4 --> [*] Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9 \u21a9 Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9 \u21a9","title":"Toto"},{"location":"demo/#toto","text":"For full documentation visit mkdocs.org . HTML for content and structure JavaScript for interactivity CSS for text running out of boxes Internet Explorer ... huh? Ctrl + Alt + Del Lorem ipsum 1 dolor sit amet, consectetur adipiscing elit. 2 Tab 1 Tab 2 Lorem ipsum dolor sit amet, (1) consectetur adipiscing elit. I'm an annotation! Phasellus posuere in sem ut cursus (1) I'm an annotation as well! Method Description GET Fetch resource PUT Update resource DELETE Delete resource stateDiagram-v2 state fork_state <<fork>> [*] --> fork_state fork_state --> State2 fork_state --> State3 state join_state <<join>> State2 --> join_state State3 --> join_state join_state --> State4 State4 --> [*]","title":"Toto"},{"location":"demo/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Back to index","title":"Commands"},{"location":"demo/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org . Question Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.","title":"Welcome to MkDocs"},{"location":"demo/#commands_1","text":"HTML for content and structure JavaScript for interactivity CSS for text running out of boxes Internet Explorer ... huh? mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"demo/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. Go to toto 1 2 3 # Code block content import React from 'react' ; const toto = React . useState ( 0 ); # Code block content bubble_sort.py def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ]","title":"Project layout"},{"location":"demo/#toto_1","text":"For full documentation visit mkdocs.org . HTML for content and structure JavaScript for interactivity CSS for text running out of boxes Internet Explorer ... huh? Ctrl + Alt + Del Lorem ipsum 1 dolor sit amet, consectetur adipiscing elit. 2 Tab 1 Tab 2 Lorem ipsum dolor sit amet, (1) consectetur adipiscing elit. I'm an annotation! Phasellus posuere in sem ut cursus (1) I'm an annotation as well! Method Description GET Fetch resource PUT Update resource DELETE Delete resource stateDiagram-v2 state fork_state <<fork>> [*] --> fork_state fork_state --> State2 fork_state --> State3 state join_state <<join>> State2 --> join_state State3 --> join_state join_state --> State4 State4 --> [*] Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9 \u21a9 Lorem ipsum dolor sit amet, consectetur adipiscing elit. \u21a9 \u21a9","title":"Toto"},{"location":"pages/advanced/","tags":["web","advanced"],"text":"","title":"Advanced web"},{"location":"pages/advanced/javascript/","tags":["js","javascript","es6","Typescript"],"text":"","title":"Advanced Javascript"},{"location":"pages/advanced/javascript/async-await/","text":"Intro Info The async keyword is used to declare async functions Async functions are functions that are instances of the AsyncFunction constructor Unlike normal functions, async functions always return a promise Normal function function greet () { return \"Hello\" ; } greet (); // browser console: \"Hello\" async function async function greet () { return \"Hello\" ; } greet (); // browser console: Promise {<fulfilled>: \"Hello\"} async function with promise async function greet () { return Promise . resolve ( \"Hello\" ); } greet (). then ( value => console . log ( value ) ); // browser console: \u2018Hello\u2019 Await Info Await keyword can be put infront of any async promise based function to pause your code until that promise settles and returns its result await only works inside async functions. Cannot use await in normal functions async with await async function greet () { let promise = new Promise (( resolve , reject ) => { setTimeout (() => resolve ( \"Hello\" ), 1000 ) }); let result = await promise ; // await until the promise resolve console . log ( result ) ; // \"Hello\" } greet () Sequential execution Function hello function resolveHello () { return new Promise ( resolve => { setTimeout (() => resolve ( \u2018 Hello \u2019 ), 2000 ); } }; Function world function resolveWorld () { return new Promise ( resolve => { setTimeout (() => resolve ( \u2018 Hello \u2019 ), 2000 ); } }; Sequential start async function sequentialStart () { const hello = await resolveHello (); console . log ( hello ); // Logs me after 2 secondes const world = await resolveWorld (); console . log ( world ); // Logs after 2 + 1 = 3 seconds } sequentialStart (); Parrallel execution resolveHello fn function resolveHello () { return new Promise ( resolve => { setTimeout (() => { resolve ( 'Hello' ); }, 2000 ); }); } resolveWorld fn function resolveWorld () { return new Promise ( resolve => { setTimeout ( function () { resolve ( 'World' ); }, 1000 ) }); } parallel function function parallel () { Promise . all ([ ( async () => console . log ( await resolveHello ()))(), // Total time taken = 2 seconds ( async () => console . log ( await resolveWorld ()))(), // Total time taken = 1 seconds ]); } parallel (); // Logs 'World' in first then: 'Hello' // Total time taken : 2 secs parallel function with await async function parallel () { await Promise . all ([ ( async () => console . log ( await resolveHello ()))(), // Total time taken = 2 seconds ( async () => console . log ( await resolveWorld ()))(), // Total time taken = 1 seconds ]); console . log ( 'Finally' ); // Logged after World Hello } parallel (); // Logs 'World' in first then: 'Hello' 'Finally' Chaining promises vs async-await with 'then' const promise = fetchCurrentUser ( api / user \u2019 ) promise . then ( result => fetchFollowersByUserId ( \u00b0 api / followers / $ { result . userId } )) . then ( result => fetchFollowerInterests ( api / interests / $ { result . followerId } )) . then ( result => fetchInterestTags ( api / tags / $ { result . interestId } )) . then ( result => fetchTagDescription ( api / description / $ { result . tagId } )) . then ( result => console . log ( 'Display the data' , result )); with 'await' async function fetchData () { const user = await fetchCurrentUser ( 'api/user' ); const followers = await fetchFollowersByUserId ( `api/followers/ ${ result . userId } ` ); const interests = await fetchFollowerInterests ( `api/interests/ ${ result . followerId } ` ) const tags = await fetchInterestTags ( `api/tags/ ${ result . interestId } ` ); const description = await fetchTagDescription ( `api/description/ ${ result . tagId } ` ); console . log ( 'Display the data' , result ); } with 'await' and 'try..catch' async function fetchData () { try { const user = await fetchCurrentUser ( 'api/user' ); const followers = await fetchFollowersByUserId ( `api/followers/ ${ result . userId } ` ); const interests = await fetchFollowerInterests ( `api/interests/ ${ result . followerId } ` ) const tags = await fetchInterestTags ( `api/tags/ ${ result . interestId } ` ); const description = await fetchTagDescription ( `api/description/ ${ result . tagId } ` ); console . log ( 'Display the data' , result ); } catch ( e ) { console . log ( 'Error' , e ); } Exercise - async await Question Problem statement: Define a function called sleep which accepts a duration parameter The sleep function should suspend execution of the function it is invoked in Solution function sleep ( duration ) { return new Promise ( resolve => setTimeout ( resolve , duration )); } async function main () { console . log ( 'Logs immediately' ); await sleep ( 2000 ); console . log ( 'Logs after 2 seconds' ); } main (); // output: 'Logs immediately' // then output: 'Logs after 2 seconds'","title":"Async await"},{"location":"pages/advanced/javascript/async-await/#intro","text":"Info The async keyword is used to declare async functions Async functions are functions that are instances of the AsyncFunction constructor Unlike normal functions, async functions always return a promise Normal function function greet () { return \"Hello\" ; } greet (); // browser console: \"Hello\" async function async function greet () { return \"Hello\" ; } greet (); // browser console: Promise {<fulfilled>: \"Hello\"} async function with promise async function greet () { return Promise . resolve ( \"Hello\" ); } greet (). then ( value => console . log ( value ) ); // browser console: \u2018Hello\u2019","title":"Intro"},{"location":"pages/advanced/javascript/async-await/#await","text":"Info Await keyword can be put infront of any async promise based function to pause your code until that promise settles and returns its result await only works inside async functions. Cannot use await in normal functions async with await async function greet () { let promise = new Promise (( resolve , reject ) => { setTimeout (() => resolve ( \"Hello\" ), 1000 ) }); let result = await promise ; // await until the promise resolve console . log ( result ) ; // \"Hello\" } greet ()","title":"Await"},{"location":"pages/advanced/javascript/async-await/#sequential-execution","text":"Function hello function resolveHello () { return new Promise ( resolve => { setTimeout (() => resolve ( \u2018 Hello \u2019 ), 2000 ); } }; Function world function resolveWorld () { return new Promise ( resolve => { setTimeout (() => resolve ( \u2018 Hello \u2019 ), 2000 ); } }; Sequential start async function sequentialStart () { const hello = await resolveHello (); console . log ( hello ); // Logs me after 2 secondes const world = await resolveWorld (); console . log ( world ); // Logs after 2 + 1 = 3 seconds } sequentialStart ();","title":"Sequential execution"},{"location":"pages/advanced/javascript/async-await/#parrallel-execution","text":"resolveHello fn function resolveHello () { return new Promise ( resolve => { setTimeout (() => { resolve ( 'Hello' ); }, 2000 ); }); } resolveWorld fn function resolveWorld () { return new Promise ( resolve => { setTimeout ( function () { resolve ( 'World' ); }, 1000 ) }); } parallel function function parallel () { Promise . all ([ ( async () => console . log ( await resolveHello ()))(), // Total time taken = 2 seconds ( async () => console . log ( await resolveWorld ()))(), // Total time taken = 1 seconds ]); } parallel (); // Logs 'World' in first then: 'Hello' // Total time taken : 2 secs parallel function with await async function parallel () { await Promise . all ([ ( async () => console . log ( await resolveHello ()))(), // Total time taken = 2 seconds ( async () => console . log ( await resolveWorld ()))(), // Total time taken = 1 seconds ]); console . log ( 'Finally' ); // Logged after World Hello } parallel (); // Logs 'World' in first then: 'Hello' 'Finally'","title":"Parrallel execution"},{"location":"pages/advanced/javascript/async-await/#chaining-promises-vs-async-await","text":"with 'then' const promise = fetchCurrentUser ( api / user \u2019 ) promise . then ( result => fetchFollowersByUserId ( \u00b0 api / followers / $ { result . userId } )) . then ( result => fetchFollowerInterests ( api / interests / $ { result . followerId } )) . then ( result => fetchInterestTags ( api / tags / $ { result . interestId } )) . then ( result => fetchTagDescription ( api / description / $ { result . tagId } )) . then ( result => console . log ( 'Display the data' , result )); with 'await' async function fetchData () { const user = await fetchCurrentUser ( 'api/user' ); const followers = await fetchFollowersByUserId ( `api/followers/ ${ result . userId } ` ); const interests = await fetchFollowerInterests ( `api/interests/ ${ result . followerId } ` ) const tags = await fetchInterestTags ( `api/tags/ ${ result . interestId } ` ); const description = await fetchTagDescription ( `api/description/ ${ result . tagId } ` ); console . log ( 'Display the data' , result ); } with 'await' and 'try..catch' async function fetchData () { try { const user = await fetchCurrentUser ( 'api/user' ); const followers = await fetchFollowersByUserId ( `api/followers/ ${ result . userId } ` ); const interests = await fetchFollowerInterests ( `api/interests/ ${ result . followerId } ` ) const tags = await fetchInterestTags ( `api/tags/ ${ result . interestId } ` ); const description = await fetchTagDescription ( `api/description/ ${ result . tagId } ` ); console . log ( 'Display the data' , result ); } catch ( e ) { console . log ( 'Error' , e ); }","title":"Chaining promises vs async-await"},{"location":"pages/advanced/javascript/async-await/#exercise-async-await","text":"Question Problem statement: Define a function called sleep which accepts a duration parameter The sleep function should suspend execution of the function it is invoked in Solution function sleep ( duration ) { return new Promise ( resolve => setTimeout ( resolve , duration )); } async function main () { console . log ( 'Logs immediately' ); await sleep ( 2000 ); console . log ( 'Logs after 2 seconds' ); } main (); // output: 'Logs immediately' // then output: 'Logs after 2 seconds'","title":"Exercise - async await"},{"location":"pages/advanced/javascript/callback/","text":"Intro Info In JavaScript, functions are first class objects : Just like an object, a function can be passed as an argument to a function A function can also be returned as values from other functions A simple function callback function greet ( name ) { console . log ( `Hello ${ name } ` ); } function greetVishwas ( greetFn ) { const name = \"Vishwas\" ; greetFn ( name ); } greetVishwas ( greet ); // output: 'Hello Vishwas' A higherOrder Function callback function greet ( name ) { console . log ( `Hello ${ name } ` ) } function higherOrderFunction ( callback ) { const name = \"Vishwas\" callback ( name ) } higherOrderFunction ( greet ); // output: 'Hello Vishwas' Any function that is passed as an argument to another function is called a callback function in JavaScript The function which accepts a function as an argument or returns a function is called a higher order function Synchronous callbacks Info A callback which is executed immediately is called a synchronous callback. A synchronous callback test function greet ( name ) { console . log ( `Hello ${ name } ` ); } function higherOrderFunction ( callback ) { const name = \"Vishwas\" ; callback ( name ); } higherOrderFunction ( greet ); // output: 'Hello Vishwas' A synchronous callback with js built-in function let numbers = [ 1 , 2 , 4 , 7 , 3 , 5 , 6 ]; numbers . sort (( a , b ) => a - b ); // output: [ 1, 2, 3, 4, 5, 6, 7 ] numbers . map ( n => n * 2 ); // output: [ 2, 4, 6, 8, 10, 12, 14 ] numbers . filter ( n => n % 2 === 0 ); // output: [ 2, 4, 6 ] Asynchronous callbacks Asynchronous Example with a setTimeout function greet ( name ) { console . log ( `Hello ${ name } ` ); } setTimeout ( greet , 2000 , 'Vishwas' ); function callback () { document . getElementById ( \"demo\" ). innerHTML = \"Hello World\" ; } // output: 'Hello Vishwas' after a delay of 2 secs Asynchronous Example with addEventListener document . getElementById ( \"btn\" ). addEventListener ( \"click\" , callback ); Asynchronous Example with a get $ . get ( \"url\" , function ( data ) { $ ( \".result\" ). html ( data ); alert ( \"Load was performed.\" ); }) Callback functions allow you to delay the execution of a function.","title":"Callback"},{"location":"pages/advanced/javascript/callback/#intro","text":"Info In JavaScript, functions are first class objects : Just like an object, a function can be passed as an argument to a function A function can also be returned as values from other functions A simple function callback function greet ( name ) { console . log ( `Hello ${ name } ` ); } function greetVishwas ( greetFn ) { const name = \"Vishwas\" ; greetFn ( name ); } greetVishwas ( greet ); // output: 'Hello Vishwas' A higherOrder Function callback function greet ( name ) { console . log ( `Hello ${ name } ` ) } function higherOrderFunction ( callback ) { const name = \"Vishwas\" callback ( name ) } higherOrderFunction ( greet ); // output: 'Hello Vishwas' Any function that is passed as an argument to another function is called a callback function in JavaScript The function which accepts a function as an argument or returns a function is called a higher order function","title":"Intro"},{"location":"pages/advanced/javascript/callback/#synchronous-callbacks","text":"Info A callback which is executed immediately is called a synchronous callback. A synchronous callback test function greet ( name ) { console . log ( `Hello ${ name } ` ); } function higherOrderFunction ( callback ) { const name = \"Vishwas\" ; callback ( name ); } higherOrderFunction ( greet ); // output: 'Hello Vishwas' A synchronous callback with js built-in function let numbers = [ 1 , 2 , 4 , 7 , 3 , 5 , 6 ]; numbers . sort (( a , b ) => a - b ); // output: [ 1, 2, 3, 4, 5, 6, 7 ] numbers . map ( n => n * 2 ); // output: [ 2, 4, 6, 8, 10, 12, 14 ] numbers . filter ( n => n % 2 === 0 ); // output: [ 2, 4, 6 ]","title":"Synchronous callbacks"},{"location":"pages/advanced/javascript/callback/#asynchronous-callbacks","text":"Asynchronous Example with a setTimeout function greet ( name ) { console . log ( `Hello ${ name } ` ); } setTimeout ( greet , 2000 , 'Vishwas' ); function callback () { document . getElementById ( \"demo\" ). innerHTML = \"Hello World\" ; } // output: 'Hello Vishwas' after a delay of 2 secs Asynchronous Example with addEventListener document . getElementById ( \"btn\" ). addEventListener ( \"click\" , callback ); Asynchronous Example with a get $ . get ( \"url\" , function ( data ) { $ ( \".result\" ). html ( data ); alert ( \"Load was performed.\" ); }) Callback functions allow you to delay the execution of a function.","title":"Asynchronous callbacks"},{"location":"pages/advanced/javascript/class/","text":"Intro Person class class Person { constructor ( name ) { this . name = name ; } sayMyName () { console . log ( My name is $ { this . name } ); } eat ( food ) { console . log ( I 'm eating ${food}' ); } sleep () { console . log ( \u2019 Sleeping \u2019 ); } } const vishwas = new Person ( \u2019 vishwas \u2019 ); const batman = new Person ( * Batman \u2019 ); const superman = new Person ( \u2019 Superman \u2019 ); const vishwas = Person ( 'Vishwas' ); vishwas . sayMyName (); // My name is Vishwas vishwas . eat ( 'pizza' ); // I'm eating pizza vishwas . sleep (); // Sleeping Exercice Calculator and ScientificCalculator class class Calculator { constructor () { this . value = 0 ; } add ( num ) { this . value += num ; } subtract ( num ) { this . value -= num ; } print () { console . log ( this . value ); } } class ScientificCalculator extends Calculator { square () { this . value *= this . value ; } } Use the ScientificCalculator class const s = new ScientificCalculator (); s . add ( 10 ); s . subtract ( 5 ); s . square (); s . print (); // Logs 25 to the console; // or write with dot syntax: s . add ( 10 ). subtract ( 5 ). square (). print ();","title":"Class"},{"location":"pages/advanced/javascript/class/#intro","text":"Person class class Person { constructor ( name ) { this . name = name ; } sayMyName () { console . log ( My name is $ { this . name } ); } eat ( food ) { console . log ( I 'm eating ${food}' ); } sleep () { console . log ( \u2019 Sleeping \u2019 ); } } const vishwas = new Person ( \u2019 vishwas \u2019 ); const batman = new Person ( * Batman \u2019 ); const superman = new Person ( \u2019 Superman \u2019 ); const vishwas = Person ( 'Vishwas' ); vishwas . sayMyName (); // My name is Vishwas vishwas . eat ( 'pizza' ); // I'm eating pizza vishwas . sleep (); // Sleeping","title":"Intro"},{"location":"pages/advanced/javascript/class/#exercice","text":"Calculator and ScientificCalculator class class Calculator { constructor () { this . value = 0 ; } add ( num ) { this . value += num ; } subtract ( num ) { this . value -= num ; } print () { console . log ( this . value ); } } class ScientificCalculator extends Calculator { square () { this . value *= this . value ; } } Use the ScientificCalculator class const s = new ScientificCalculator (); s . add ( 10 ); s . subtract ( 5 ); s . square (); s . print (); // Logs 25 to the console; // or write with dot syntax: s . add ( 10 ). subtract ( 5 ). square (). print ();","title":"Exercice"},{"location":"pages/advanced/javascript/closures/","text":"Double incovation Double Invokation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function outer () { let counter = 0 ; function inner () { counter ++ ; console . log ( counter ); } inner (); } outer (); outer (); // What is logged to the console? // Line 5 : 1 // Line 6 : 1 Every time a function gets invoked, it gets a brand new local memory which contains all the variables and arguments. When we finish running the function, that temporary memory is pretty much deleted. When we invoke the function again it doesn't remember the data that was stored in the memory from the previous run. Invoke later Invoke later 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function outer () { let counter = 0 ; function inner () { counter ++ ; console . log ( counter ); } return inner ; } const fn = outer (); fn (); fn (); // What is logged to the console? // Line 5 : 1 // Line 6 : 2 Closures in JavaScript A closure is the combination of a function bundled together with references to its surrounding state (the lexical environment). Closures are created every time a function is created, at function creation time. In JavaScript, when we return a function from another function, we are effectively returning a combination of the function definition along with the function's scope chain. This would let the function definition have an associated persistent memory which could hold on to live data between executions. Info The combination of the function and its scope chain (lexical environemnt) is what is called a closure in JavaScript. Multiple closure instances function outer () { let counter = 9 function inner () { counter ++ console . log ( counter ) } return inner } const fn1 = outer (); fn1 (); fn1 (); const fn2 = outer (); fn2 (); fn2 (); // What is logged to the console? // fn1 output: 10 11 // fn2 output: 10 11 Info Multiple closure instances don't share the same persistent memory. Exercice: memoization with Closures Implement optimizedSquare function First implementation function square ( num ) { return num * num ; } function memoizedSquare () { let cache = {}; return function optimizedSquare ( num ) { ... } } Final implementation function square ( num ) { return num * num ; } function memoizedSquare () { let cache = {}; return function optimizedSquare ( num ) { if ( num in cache ) { console . log ( 'Returning from cache' ); return cache [ num ]; } else { console . log ( 'Computing square' ); const result = square ( num ); cache [ num ] = result ; return result ; } } } Testing the optimizedSquare memo closure Run memoizedSquare const memoSquare = memoizedSquare (); console . log ( memoSquare ( 2 )); console . log ( memoSquare ( 5 )); console . log ( memoSquare ( 5 )); // What is logged to the console? // Computing square 4 // Computing square 25 // Returning from cache 25 Generic memoization implementation memoize function function memoize ( callback ) { let cache = {}; return function (... args ) { const key = args . toString (); if ( key in cache ) { console . log ( \"Returning from cache\" ); return cache [ key ]; } else { console . log ( \"Computing result\" ); const result = callback (... args ); cache [ key ] = result ; return result ; } } } Use the memoize fn with a callback // the callback function add ( a , b ) { return a + b ; } // Create the memo with the callback const memoizedAdd = memoize ( add ); console . log ( memoizedAdd ( 2 , 4 )); console . log ( memoizedAdd ( 2 , 4 )); // What is logged to the console? // Computing result 6 // Returning from cache 6","title":"Closures"},{"location":"pages/advanced/javascript/closures/#double-incovation","text":"Double Invokation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function outer () { let counter = 0 ; function inner () { counter ++ ; console . log ( counter ); } inner (); } outer (); outer (); // What is logged to the console? // Line 5 : 1 // Line 6 : 1 Every time a function gets invoked, it gets a brand new local memory which contains all the variables and arguments. When we finish running the function, that temporary memory is pretty much deleted. When we invoke the function again it doesn't remember the data that was stored in the memory from the previous run.","title":"Double incovation"},{"location":"pages/advanced/javascript/closures/#invoke-later","text":"Invoke later 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function outer () { let counter = 0 ; function inner () { counter ++ ; console . log ( counter ); } return inner ; } const fn = outer (); fn (); fn (); // What is logged to the console? // Line 5 : 1 // Line 6 : 2 Closures in JavaScript A closure is the combination of a function bundled together with references to its surrounding state (the lexical environment). Closures are created every time a function is created, at function creation time. In JavaScript, when we return a function from another function, we are effectively returning a combination of the function definition along with the function's scope chain. This would let the function definition have an associated persistent memory which could hold on to live data between executions. Info The combination of the function and its scope chain (lexical environemnt) is what is called a closure in JavaScript.","title":"Invoke later"},{"location":"pages/advanced/javascript/closures/#multiple-closure-instances","text":"function outer () { let counter = 9 function inner () { counter ++ console . log ( counter ) } return inner } const fn1 = outer (); fn1 (); fn1 (); const fn2 = outer (); fn2 (); fn2 (); // What is logged to the console? // fn1 output: 10 11 // fn2 output: 10 11 Info Multiple closure instances don't share the same persistent memory.","title":"Multiple closure instances"},{"location":"pages/advanced/javascript/closures/#exercice-memoization-with-closures","text":"","title":"Exercice: memoization with Closures"},{"location":"pages/advanced/javascript/closures/#implement-optimizedsquare-function","text":"First implementation function square ( num ) { return num * num ; } function memoizedSquare () { let cache = {}; return function optimizedSquare ( num ) { ... } } Final implementation function square ( num ) { return num * num ; } function memoizedSquare () { let cache = {}; return function optimizedSquare ( num ) { if ( num in cache ) { console . log ( 'Returning from cache' ); return cache [ num ]; } else { console . log ( 'Computing square' ); const result = square ( num ); cache [ num ] = result ; return result ; } } }","title":"Implement optimizedSquare function"},{"location":"pages/advanced/javascript/closures/#testing-the-optimizedsquare-memo-closure","text":"Run memoizedSquare const memoSquare = memoizedSquare (); console . log ( memoSquare ( 2 )); console . log ( memoSquare ( 5 )); console . log ( memoSquare ( 5 )); // What is logged to the console? // Computing square 4 // Computing square 25 // Returning from cache 25","title":"Testing the optimizedSquare memo closure"},{"location":"pages/advanced/javascript/closures/#generic-memoization-implementation","text":"memoize function function memoize ( callback ) { let cache = {}; return function (... args ) { const key = args . toString (); if ( key in cache ) { console . log ( \"Returning from cache\" ); return cache [ key ]; } else { console . log ( \"Computing result\" ); const result = callback (... args ); cache [ key ] = result ; return result ; } } } Use the memoize fn with a callback // the callback function add ( a , b ) { return a + b ; } // Create the memo with the callback const memoizedAdd = memoize ( add ); console . log ( memoizedAdd ( 2 , 4 )); console . log ( memoizedAdd ( 2 , 4 )); // What is logged to the console? // Computing result 6 // Returning from cache 6","title":"Generic memoization implementation"},{"location":"pages/advanced/javascript/currying/","text":"Currying and closures function curry ( fn ) { return function ( a ) { return function ( b ) { return function ( c ) { return fn ( a , b , c ); } } } } const sum = ( value1 , value2 , value3 ) => value1 + value2 + value3 ; const curriedSum = curry ( sum ); console . log ( curriedSum ( 2 )( 3 )( 5 )); // output: 10 Currying is possible because of closures. When we return a function from another function, we are returning the function along with its lexical scope. Lexical scope takes the outer function parameters into consideration.","title":"Currying"},{"location":"pages/advanced/javascript/es6-utilities/","text":"Filter Info The filter() method take an arg function with array element like parameter. The function return a boolean filter. An second parameter may be used for element indice. Filter return an array. Simple Example const users = [ 'John' , 'Marc' , 'Mattew' , 'Peter' , 'Paul' ]; const result = users . filter ( user => user . length > 4 ); // return name length > 4 // result return: Array[\"Mattew\", \"Peter\"] const result = users . filter (( user , i ) => i > 2 ); // return indice > 2 // result return: Array[\"Peter\", \"Paul\"] Filter example with an object Intial data const users = { \"admin\" : false , \"user\" : true , \"super\" : true } Output all true data from user object Solution Object . keys ( users ). filter ( ( k ) => { return user [ k ] } ); // Output: [ 'user', 'super' ] shortland solution Object . keys ( users ). filter ( ( k ) => user [ k ] ); // Output: [ 'user', 'super' ] Map Info map take an arg function with array element like parameter. The function must return the new value. An second parameter may be used for element indice. Map return an array. Simple Example const users = [ 'John' , 'Marc' , 'Mattew' , 'Peter' , 'Paul' ]; const result = users . filter ( user => user . length > 4 ); // result return: Array[\"Mattew\", \"Peter\"] const result = users . filter (( user , i ) => i > 2 ); Reduce Info The reduce() method executes a user-supplied \"reducer\" callback function on each element of the array, in order, passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the array is a single value. Simple Example const array1 = [ 1 , 2 , 3 , 4 ]; const reducer = array1 . reduce (( acc , element ) => acc + element ); // return 10 const reducer2 = array1 . reduce (( acc , element , i ) => acc + element + i ); // return 16 Reduce Exemple Intial data const pilots = [ { id : 10 , name : \"Peo Dameron\" , years : 30 , }, { id : 2 , name : \"Temin Wexley\" , years : 50 , }, { id : 41 , name : \"Tallissan Lintra\" , years : 13 , }, { id : 99 , name : \"Ello Asty\" , years : 5 , }, ]; Get the lower age pilot const pilot = pilots . reduce ( ( acc , element ) => ( acc . years || 0 ) < element . years ? acc : element ); // Output : { id: 99, name: 'Ello Asty', years: 5} More reduce practices","title":"Es6 utilities"},{"location":"pages/advanced/javascript/es6-utilities/#filter","text":"Info The filter() method take an arg function with array element like parameter. The function return a boolean filter. An second parameter may be used for element indice. Filter return an array. Simple Example const users = [ 'John' , 'Marc' , 'Mattew' , 'Peter' , 'Paul' ]; const result = users . filter ( user => user . length > 4 ); // return name length > 4 // result return: Array[\"Mattew\", \"Peter\"] const result = users . filter (( user , i ) => i > 2 ); // return indice > 2 // result return: Array[\"Peter\", \"Paul\"]","title":"Filter"},{"location":"pages/advanced/javascript/es6-utilities/#filter-example-with-an-object","text":"Intial data const users = { \"admin\" : false , \"user\" : true , \"super\" : true }","title":"Filter example with an object"},{"location":"pages/advanced/javascript/es6-utilities/#output-all-true-data-from-user-object","text":"Solution Object . keys ( users ). filter ( ( k ) => { return user [ k ] } ); // Output: [ 'user', 'super' ] shortland solution Object . keys ( users ). filter ( ( k ) => user [ k ] ); // Output: [ 'user', 'super' ]","title":"Output all true data from user object"},{"location":"pages/advanced/javascript/es6-utilities/#map","text":"Info map take an arg function with array element like parameter. The function must return the new value. An second parameter may be used for element indice. Map return an array. Simple Example const users = [ 'John' , 'Marc' , 'Mattew' , 'Peter' , 'Paul' ]; const result = users . filter ( user => user . length > 4 ); // result return: Array[\"Mattew\", \"Peter\"] const result = users . filter (( user , i ) => i > 2 );","title":"Map"},{"location":"pages/advanced/javascript/es6-utilities/#reduce","text":"Info The reduce() method executes a user-supplied \"reducer\" callback function on each element of the array, in order, passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the array is a single value. Simple Example const array1 = [ 1 , 2 , 3 , 4 ]; const reducer = array1 . reduce (( acc , element ) => acc + element ); // return 10 const reducer2 = array1 . reduce (( acc , element , i ) => acc + element + i ); // return 16","title":"Reduce"},{"location":"pages/advanced/javascript/es6-utilities/#reduce-exemple","text":"Intial data const pilots = [ { id : 10 , name : \"Peo Dameron\" , years : 30 , }, { id : 2 , name : \"Temin Wexley\" , years : 50 , }, { id : 41 , name : \"Tallissan Lintra\" , years : 13 , }, { id : 99 , name : \"Ello Asty\" , years : 5 , }, ]; Get the lower age pilot const pilot = pilots . reduce ( ( acc , element ) => ( acc . years || 0 ) < element . years ? acc : element ); // Output : { id: 99, name: 'Ello Asty', years: 5} More reduce practices","title":"Reduce Exemple"},{"location":"pages/advanced/javascript/generator/","text":"What is special about a generator function Normal function function normalFunction () { console . log ( \"Hello\" ); console . log ( \"World\" ); } Run to complemetion model. Output: 'Hello' 'World' Exit by returning or throwing an error. If you call the function again, it will begin the execution from the top. Generator function function * generatorFunction () { yield `Hello` ; yield `World` ; } Warning Do not forget the * after function key : function* generatorFunction() A generator is a function that can stop midway and then continue from where it stopped. A generator function can \"pause\" the execution. To achieve that behaviour, we use the yield keyword. yield is an operator with which a generator can pause itself. Generator yields a value. Invocation Generators Create the Generator function * generatorFunction () { yield `Hello` ; yield `World` ; } const generatorObject = generatorFunction (); Use the Generator for ( const word of generatorObject ) { console . log ( word ); } // Log: Hello world console . log ([... generatorObject ]); // Log: [ 'Hello', 'world' ] generatorObject . next (); // Returns { value: \u2018Hello\u2019, done: false } generatorObject . next (); // Returns { value: \u2018World', done: false } generatorObject . next (); // Returns { value: undefined, done: true }","title":"Generator"},{"location":"pages/advanced/javascript/generator/#what-is-special-about-a-generator-function","text":"Normal function function normalFunction () { console . log ( \"Hello\" ); console . log ( \"World\" ); } Run to complemetion model. Output: 'Hello' 'World' Exit by returning or throwing an error. If you call the function again, it will begin the execution from the top. Generator function function * generatorFunction () { yield `Hello` ; yield `World` ; } Warning Do not forget the * after function key : function* generatorFunction() A generator is a function that can stop midway and then continue from where it stopped. A generator function can \"pause\" the execution. To achieve that behaviour, we use the yield keyword. yield is an operator with which a generator can pause itself. Generator yields a value.","title":"What is special about a generator function"},{"location":"pages/advanced/javascript/generator/#invocation","text":"Generators Create the Generator function * generatorFunction () { yield `Hello` ; yield `World` ; } const generatorObject = generatorFunction (); Use the Generator for ( const word of generatorObject ) { console . log ( word ); } // Log: Hello world console . log ([... generatorObject ]); // Log: [ 'Hello', 'world' ] generatorObject . next (); // Returns { value: \u2018Hello\u2019, done: false } generatorObject . next (); // Returns { value: \u2018World', done: false } generatorObject . next (); // Returns { value: undefined, done: true }","title":"Invocation"},{"location":"pages/advanced/javascript/iterator/","text":"Iterables & Iterators Intro Iterable Protocol - Technical details The iterable protocol decides whether an object is an iterable or not. An object is iterable when it contains a method at the key [Symbol.iterator] that takes no arguments and returns an object which conforms to the iterator protocol. Iterator Protocol - Technical details The iterator protocol decides whether an object is an iterator. An object is an iterator when it satisfies the following rule The object must have a next() method that returns an object with two properties value: which gives the current element done: which is a boolean value indicating whether or not there are any more elements that could be iterated upon Each time you call the next() method, it returns the next value in the collection. { value: 'next value', done: false } // till the last element has been returned { value: undefined, done: true} // after the last element has been returned For..of loop A for..of loop with a string will iterate over the characters in the string for ( const char of str ) { console . log ( char ); } A for..of loop with a map will iterate over the key/value pairs of the map: for ( const [ key , value ] of map ) { console . log ( key + ' = ' + value ); } A for..of loop with an array will iterate over the items in the array: for ( const item of arr ) { console . log ( item ); } A for..of loop with a set will iterate over the values in the set: for ( const value of set ){ console . log ( value ); } Iterables & Iterators examples Basic example Create the iterator const range = { [ Symbol . iterator ] : () => { let counter = 1 ; const iterator = { next : () => { const result = { value : counter , done : false }; if ( counter <= 50 ) { counter ++ ; return result ; } return { done : true }; } } return iterator ; } } Use iterator for ( const num of range ) { console . log ( num ); } // output: 1 2 3 ... 50 console . log ([... range ]); // output: [ 1, 2, 3, ...50 ] Our range iterable logs numbers from 1 to 50 when we have the default iteration with the for..of loop. Customize the iteration behaviour. Pass three values namely start, end and interval. Print the range starting from start value till the end value with interval size increments. start=10, end=20 and interval = 2 logs10, 12, 14, 16, 18 and 20 in the console. Example with next() and return() The iterator object const customRange = { [ Symbol . iterator ] : ( start = 1 , end = 50 , interval = 1 ) => { let counter = start ; const iterator = { next : () => { const result = { value : counter , done : false }; if ( counter <= end ) { counter += interval ; return result ; } return { done : true }; } } return iterator ; } } Use the iterator object for ( const num of customRange ) { if ( num > 10 ) { break ; } console . log ( num ); } // Output : 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 Info Note that the return method is invoked when the iteration is stopped prematurely Iterator object use with for for ( const num of customRange ) { console . log ( num ); } // Output : 1, 2, 3, 4, 5, 6, 7, 8, 9, ... 50 console . log ([ ... customRange ]); // Output : [1, 2, 3, 4, 5, 6, 7, 8, 9, ... 50 ] Iterator object use with while const iterator2 = customRange [ Symbol . iterator ]( 10 , 20 , 2 ); let result = iterator2 . next (); while ( ! result . done ) { console . log ( result . value ); result = iterator2 . next (); } // output: 10 12 14 16 18 20 Iterator object use with next const iterator = customRange [ Symbol . iterator ]( 10 , 20 , 2 ); iterator . next (); // output : { value: 10, done: false } iterator . next (); // output : { value: 12, done: false } iterator . next (); // output : { value: 14, done: false } iterator . next (); // output : { value: 16, done: false } iterator . next (); // output : { value: 18, done: false } iterator . next (); // output : { value: 20, done: false }","title":"Iterables & Iterators"},{"location":"pages/advanced/javascript/iterator/#iterables-iterators","text":"","title":"Iterables &amp; Iterators"},{"location":"pages/advanced/javascript/iterator/#intro","text":"","title":"Intro"},{"location":"pages/advanced/javascript/iterator/#iterable-protocol-technical-details","text":"The iterable protocol decides whether an object is an iterable or not. An object is iterable when it contains a method at the key [Symbol.iterator] that takes no arguments and returns an object which conforms to the iterator protocol.","title":"Iterable Protocol - Technical details"},{"location":"pages/advanced/javascript/iterator/#iterator-protocol-technical-details","text":"The iterator protocol decides whether an object is an iterator. An object is an iterator when it satisfies the following rule The object must have a next() method that returns an object with two properties value: which gives the current element done: which is a boolean value indicating whether or not there are any more elements that could be iterated upon Each time you call the next() method, it returns the next value in the collection. { value: 'next value', done: false } // till the last element has been returned { value: undefined, done: true} // after the last element has been returned","title":"Iterator Protocol - Technical details"},{"location":"pages/advanced/javascript/iterator/#forof-loop","text":"A for..of loop with a string will iterate over the characters in the string for ( const char of str ) { console . log ( char ); } A for..of loop with a map will iterate over the key/value pairs of the map: for ( const [ key , value ] of map ) { console . log ( key + ' = ' + value ); } A for..of loop with an array will iterate over the items in the array: for ( const item of arr ) { console . log ( item ); } A for..of loop with a set will iterate over the values in the set: for ( const value of set ){ console . log ( value ); }","title":"For..of loop"},{"location":"pages/advanced/javascript/iterator/#iterables-iterators-examples","text":"","title":"Iterables &amp; Iterators examples"},{"location":"pages/advanced/javascript/iterator/#basic-example","text":"Create the iterator const range = { [ Symbol . iterator ] : () => { let counter = 1 ; const iterator = { next : () => { const result = { value : counter , done : false }; if ( counter <= 50 ) { counter ++ ; return result ; } return { done : true }; } } return iterator ; } } Use iterator for ( const num of range ) { console . log ( num ); } // output: 1 2 3 ... 50 console . log ([... range ]); // output: [ 1, 2, 3, ...50 ] Our range iterable logs numbers from 1 to 50 when we have the default iteration with the for..of loop. Customize the iteration behaviour. Pass three values namely start, end and interval. Print the range starting from start value till the end value with interval size increments. start=10, end=20 and interval = 2 logs10, 12, 14, 16, 18 and 20 in the console.","title":"Basic example"},{"location":"pages/advanced/javascript/iterator/#example-with-next-and-return","text":"The iterator object const customRange = { [ Symbol . iterator ] : ( start = 1 , end = 50 , interval = 1 ) => { let counter = start ; const iterator = { next : () => { const result = { value : counter , done : false }; if ( counter <= end ) { counter += interval ; return result ; } return { done : true }; } } return iterator ; } } Use the iterator object for ( const num of customRange ) { if ( num > 10 ) { break ; } console . log ( num ); } // Output : 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 Info Note that the return method is invoked when the iteration is stopped prematurely Iterator object use with for for ( const num of customRange ) { console . log ( num ); } // Output : 1, 2, 3, 4, 5, 6, 7, 8, 9, ... 50 console . log ([ ... customRange ]); // Output : [1, 2, 3, 4, 5, 6, 7, 8, 9, ... 50 ] Iterator object use with while const iterator2 = customRange [ Symbol . iterator ]( 10 , 20 , 2 ); let result = iterator2 . next (); while ( ! result . done ) { console . log ( result . value ); result = iterator2 . next (); } // output: 10 12 14 16 18 20 Iterator object use with next const iterator = customRange [ Symbol . iterator ]( 10 , 20 , 2 ); iterator . next (); // output : { value: 10, done: false } iterator . next (); // output : { value: 12, done: false } iterator . next (); // output : { value: 14, done: false } iterator . next (); // output : { value: 16, done: false } iterator . next (); // output : { value: 18, done: false } iterator . next (); // output : { value: 20, done: false }","title":"Example with next() and return()"},{"location":"pages/advanced/javascript/map/","text":"Map object Intro The Map object in JavaScript holds key-value pairs (similar to an object). const map = new Map (); To add key value pairs use the set method passing in key and value as its arguments. const map = new Map (); map . set ( 'firstName' , 'Bruce' ); map . set ( 'lastName' , 'Wayne' ); To check the number of key value pairs in the map, use the size property. const map = new Map (); map . set ( 'firstName' , 'Bruce' ); map . set ( 'lastName' , 'Wayne' ); map . size ; // -> Returns 2 To get the value at a particular key, use the get method passing in key as the argument. map . get ( 'firstName' ); // -> Returns 'Bruce'; map . get ( 'lastName' ); // -> Returns 'Wayne'; To check if a key exists in the map, use the has method. map . has ( 'firstName' ); // -> Returns true map . has ( 'fullName' ); //-> Returns false To remove a key value pair from the map, use the delete method passing in the key.\"To delete all the key value pairs in the map, use the clear method map . delete ( 'firstName' ); // -> Returns true map . delete ( \u2018 fullName ' ); // -> Returns false map . clear (); map . size ; // -> Returns 2 Map array conversion 2D array to map const personArr = [ [ 'firstName' , 'Bruce' ], [ 'lastName' , 'Wayne' ] ]; const personMap = new Map ( personArr ); Map to array const map = new Map () map . set ( 'firstName' , 'Bruce' ); map . set ( 'lastName' , 'Wayne' ); const arr = Array . from ( map ); for in Map Iterating over a Map const map = new Map (); map . set ( 'firstName' , 'Bruce' ); map . set ( 'lastName' , 'Wayne' ); Iterate over key-value pairs for ( let [ key , value ] of map ) { console . log ( key + ' = \u2018 + value ); } Iterate over keys only for ( let key of map . keys ()) { console . log ( key ); } Iterate over values only for ( let value of map . values ()) { console . log ( value ); } Map VS object 1. key type Info A Map's keys can be any value (including functions, objects, or any primitive). The keys of an Object however must be either a String or a Symbol. const keyString = 'a string' ; const keyObj = {}; const keyFunc = function () {}; myMap . set ( keyString , 'String key value' ); myMap . set ( keyObj , 'Object key value' ); myMap . set ( keyFunc , 'Function key value' ); 2. Accidental keys A Map does not contain any keys by default. An Object however has a prototype, so it contains default keys. 3. Identifying the size Number of items in a Map is easily retrieved from its 'size' property. The number of items in an Object however, must be determined manually. 4. Iteration behaviour Map is an iterable so it can directly be iterated Iterating over an Object however requires obtaining its keys in some fashion and then iterating over them.","title":"Map object"},{"location":"pages/advanced/javascript/map/#map-object","text":"","title":"Map object"},{"location":"pages/advanced/javascript/map/#intro","text":"The Map object in JavaScript holds key-value pairs (similar to an object). const map = new Map (); To add key value pairs use the set method passing in key and value as its arguments. const map = new Map (); map . set ( 'firstName' , 'Bruce' ); map . set ( 'lastName' , 'Wayne' ); To check the number of key value pairs in the map, use the size property. const map = new Map (); map . set ( 'firstName' , 'Bruce' ); map . set ( 'lastName' , 'Wayne' ); map . size ; // -> Returns 2 To get the value at a particular key, use the get method passing in key as the argument. map . get ( 'firstName' ); // -> Returns 'Bruce'; map . get ( 'lastName' ); // -> Returns 'Wayne'; To check if a key exists in the map, use the has method. map . has ( 'firstName' ); // -> Returns true map . has ( 'fullName' ); //-> Returns false To remove a key value pair from the map, use the delete method passing in the key.\"To delete all the key value pairs in the map, use the clear method map . delete ( 'firstName' ); // -> Returns true map . delete ( \u2018 fullName ' ); // -> Returns false map . clear (); map . size ; // -> Returns 2","title":"Intro"},{"location":"pages/advanced/javascript/map/#map-array-conversion","text":"2D array to map const personArr = [ [ 'firstName' , 'Bruce' ], [ 'lastName' , 'Wayne' ] ]; const personMap = new Map ( personArr ); Map to array const map = new Map () map . set ( 'firstName' , 'Bruce' ); map . set ( 'lastName' , 'Wayne' ); const arr = Array . from ( map );","title":"Map array conversion"},{"location":"pages/advanced/javascript/map/#for-in-map","text":"Iterating over a Map const map = new Map (); map . set ( 'firstName' , 'Bruce' ); map . set ( 'lastName' , 'Wayne' ); Iterate over key-value pairs for ( let [ key , value ] of map ) { console . log ( key + ' = \u2018 + value ); } Iterate over keys only for ( let key of map . keys ()) { console . log ( key ); } Iterate over values only for ( let value of map . values ()) { console . log ( value ); }","title":"for in Map"},{"location":"pages/advanced/javascript/map/#map-vs-object","text":"","title":"Map VS object"},{"location":"pages/advanced/javascript/map/#1-key-type","text":"Info A Map's keys can be any value (including functions, objects, or any primitive). The keys of an Object however must be either a String or a Symbol. const keyString = 'a string' ; const keyObj = {}; const keyFunc = function () {}; myMap . set ( keyString , 'String key value' ); myMap . set ( keyObj , 'Object key value' ); myMap . set ( keyFunc , 'Function key value' );","title":"1. key type"},{"location":"pages/advanced/javascript/map/#2-accidental-keys","text":"A Map does not contain any keys by default. An Object however has a prototype, so it contains default keys.","title":"2. Accidental keys"},{"location":"pages/advanced/javascript/map/#3-identifying-the-size","text":"Number of items in a Map is easily retrieved from its 'size' property. The number of items in an Object however, must be determined manually.","title":"3. Identifying the size"},{"location":"pages/advanced/javascript/map/#4-iteration-behaviour","text":"Map is an iterable so it can directly be iterated Iterating over an Object however requires obtaining its keys in some fashion and then iterating over them.","title":"4. Iteration behaviour"},{"location":"pages/advanced/javascript/promise/","text":"Promise intro How to execute callback functions based on the status change? Promise Resolve scenario const promise1 = new Promise (( resolve , reject ) => { setTimeout (() => { // Food truck found // Change status from \u2018pending\u2019 to 'fulfilled' resolve ( \"Bringing tacos\" ) }, 5000 ); }); Promise Reject scenario const promise2 = new Promise (( resolve , reject ) => { setTimeout (() => { // Food truck not found // Change status from \u2018pending\u2019 to 'rejected' reject ( 'Not bringing tacos. Food truck not there.' ); }, 5000 ); }); Success and failure callbacks const onFullfillment = ( result ) => { // resolve was called console . log ( result ); console . log ( 'Set up the table to eat tacos' ); } const onRejection = ( error ) => { // reject was called console . log ( error ); console . log ( 'Start cooking pasta' ); } promise1 . then ( onFullfillment ); promise2 . catch ( onRejection ); console log result 'Bringing tacos' 'Set up the table to eat tacos' ------------------------------- 'Cannot bring tacos' 'Start cooking pasta' Promise then() function Version 1 Encouraged approach Even if your onFulfillment callback throws an exception, it is caught and then you can handle that exception gracefully then() and catch() functions const promise = new Promise (( resolve , reject ) => { resolve () or reject () }); promise . then ( onFulfillment ); promise . catch ( onRejection ); Version 2 onRejection callback handles error from only the Promise. If your callback functions itself throws an error or exception, there is no code to handle that. then() function const promise = new Promise (( resolve , reject ) => { resolve () or reject () }); promise . then ( onFulfillment , onRejection ) Chaining Promise Chaining Promises const promise = new Promise (( resolve , reject ) => { resolve () or reject (); } promise . then ( onFulfillment ). catch ( onRejection ); Both then and catch methods return promises. then() and catch() methods can be chained in JavaScript. Promise Static methods Promise.all() Query multiple APIs and perform some actions but only after all the APIs have finished loading. const promise1 = Promise . resolve ( 3 ); const promise2 = 42 ; const promise3 = new Promise (( resolve , reject ) => { setTimeout ( resolve , 1000 , \"foo\" ); }); Promise . all ([ promise1 , promise2 , promise3 ]) . then (( values ) => { console . log ( values ); }); // output: [ 3, 42, 'foo' ] after 1 sec The Promise.all() method takes an iterable of promises as an input and returns. single Promise that resolves to an array of the results of the input promises. Promise.race() The Promise.race() method returns a promise that fulfills or rejects as soon as one of the input promises fulfills or rejects, with the value or reason from that promise. const promise1 = new Promise (( resolve , reject ) => { setTimeout ( resolve , 500 , 'one' ); }); const promise2 = new Promise (( resolve , reject ) => { setTimeout ( resolve , 100 , 'two' ); }); Promise . race ([ promise1 , promise2 ]). then (( value ) => { console . log ( value ); // both resolve but promise2 is faster }); // output: 'two' Promise.allSettled() Promise.allSettled() waits for all input promises to complete regardless of whether or not one of them is rejected. const promise1 = Promise . resolve ( 3 ); const promise2 = 42 ; const promise3 = new Promise (( resolve , reject ) => { setTimeout ( resolve , 1908 , 'foo' ); }); Promise . allSettled ([ promise1 , promise2 , promise3 ]). then (( values ) => { console . log ( values ); }); //output: [ 3, 42, \"foo\" ] /* [ { status: 'fulfilled', value: 3 }, { status: 'fulfilled', value: 42 }, { status: 'fulfilled', value: 'foo' } ] */ Bonus Promise with for..of Ouput the user ID with 1000 ms delay one per one // Create the promise with timeout const getUserID = ( id ) => { return new Promise ( ( resolve ) => { setTimeout (() => { console . log ( `Got user ID ${ id } ` ); resolve ( id ); }, 1000 ); }) } ( async function () { const users = [ 30 , 20 , 10 , 5 , 1 ]; for ( const user of users ) { await getUserID ( user ) } })() // output at 1000 ms frequence one per one the users (5 x 1000 ms): // 'Got user ID 30' >1000 ms // 'Got user ID 20' >1000 ms // 'Got user ID 10' >1000 ms // 'Got user ID 5' >1000 ms // 'Got user ID 1' >1000 ms Promise with forEach, map or for // with forEach, map, for, it run in parrallels users . forEach ( async ( user ) => { await getUserID ( user ) }) // output with 1000 ms delay All the users in one time:","title":"Promise intro"},{"location":"pages/advanced/javascript/promise/#promise-intro","text":"How to execute callback functions based on the status change? Promise Resolve scenario const promise1 = new Promise (( resolve , reject ) => { setTimeout (() => { // Food truck found // Change status from \u2018pending\u2019 to 'fulfilled' resolve ( \"Bringing tacos\" ) }, 5000 ); }); Promise Reject scenario const promise2 = new Promise (( resolve , reject ) => { setTimeout (() => { // Food truck not found // Change status from \u2018pending\u2019 to 'rejected' reject ( 'Not bringing tacos. Food truck not there.' ); }, 5000 ); }); Success and failure callbacks const onFullfillment = ( result ) => { // resolve was called console . log ( result ); console . log ( 'Set up the table to eat tacos' ); } const onRejection = ( error ) => { // reject was called console . log ( error ); console . log ( 'Start cooking pasta' ); } promise1 . then ( onFullfillment ); promise2 . catch ( onRejection ); console log result 'Bringing tacos' 'Set up the table to eat tacos' ------------------------------- 'Cannot bring tacos' 'Start cooking pasta'","title":"Promise intro"},{"location":"pages/advanced/javascript/promise/#promise-then-function","text":"","title":"Promise then() function"},{"location":"pages/advanced/javascript/promise/#version-1","text":"Encouraged approach Even if your onFulfillment callback throws an exception, it is caught and then you can handle that exception gracefully then() and catch() functions const promise = new Promise (( resolve , reject ) => { resolve () or reject () }); promise . then ( onFulfillment ); promise . catch ( onRejection );","title":"Version 1"},{"location":"pages/advanced/javascript/promise/#version-2","text":"onRejection callback handles error from only the Promise. If your callback functions itself throws an error or exception, there is no code to handle that. then() function const promise = new Promise (( resolve , reject ) => { resolve () or reject () }); promise . then ( onFulfillment , onRejection )","title":"Version 2"},{"location":"pages/advanced/javascript/promise/#chaining-promise","text":"Chaining Promises const promise = new Promise (( resolve , reject ) => { resolve () or reject (); } promise . then ( onFulfillment ). catch ( onRejection ); Both then and catch methods return promises. then() and catch() methods can be chained in JavaScript.","title":"Chaining Promise"},{"location":"pages/advanced/javascript/promise/#promise-static-methods","text":"","title":"Promise Static methods"},{"location":"pages/advanced/javascript/promise/#promiseall","text":"Query multiple APIs and perform some actions but only after all the APIs have finished loading. const promise1 = Promise . resolve ( 3 ); const promise2 = 42 ; const promise3 = new Promise (( resolve , reject ) => { setTimeout ( resolve , 1000 , \"foo\" ); }); Promise . all ([ promise1 , promise2 , promise3 ]) . then (( values ) => { console . log ( values ); }); // output: [ 3, 42, 'foo' ] after 1 sec The Promise.all() method takes an iterable of promises as an input and returns. single Promise that resolves to an array of the results of the input promises.","title":"Promise.all()"},{"location":"pages/advanced/javascript/promise/#promiserace","text":"The Promise.race() method returns a promise that fulfills or rejects as soon as one of the input promises fulfills or rejects, with the value or reason from that promise. const promise1 = new Promise (( resolve , reject ) => { setTimeout ( resolve , 500 , 'one' ); }); const promise2 = new Promise (( resolve , reject ) => { setTimeout ( resolve , 100 , 'two' ); }); Promise . race ([ promise1 , promise2 ]). then (( value ) => { console . log ( value ); // both resolve but promise2 is faster }); // output: 'two'","title":"Promise.race()"},{"location":"pages/advanced/javascript/promise/#promiseallsettled","text":"Promise.allSettled() waits for all input promises to complete regardless of whether or not one of them is rejected. const promise1 = Promise . resolve ( 3 ); const promise2 = 42 ; const promise3 = new Promise (( resolve , reject ) => { setTimeout ( resolve , 1908 , 'foo' ); }); Promise . allSettled ([ promise1 , promise2 , promise3 ]). then (( values ) => { console . log ( values ); }); //output: [ 3, 42, \"foo\" ] /* [ { status: 'fulfilled', value: 3 }, { status: 'fulfilled', value: 42 }, { status: 'fulfilled', value: 'foo' } ] */","title":"Promise.allSettled()"},{"location":"pages/advanced/javascript/promise/#bonus","text":"","title":"Bonus"},{"location":"pages/advanced/javascript/promise/#promise-with-forof","text":"Ouput the user ID with 1000 ms delay one per one // Create the promise with timeout const getUserID = ( id ) => { return new Promise ( ( resolve ) => { setTimeout (() => { console . log ( `Got user ID ${ id } ` ); resolve ( id ); }, 1000 ); }) } ( async function () { const users = [ 30 , 20 , 10 , 5 , 1 ]; for ( const user of users ) { await getUserID ( user ) } })() // output at 1000 ms frequence one per one the users (5 x 1000 ms): // 'Got user ID 30' >1000 ms // 'Got user ID 20' >1000 ms // 'Got user ID 10' >1000 ms // 'Got user ID 5' >1000 ms // 'Got user ID 1' >1000 ms","title":"Promise with for..of"},{"location":"pages/advanced/javascript/promise/#promise-with-foreach-map-or-for","text":"// with forEach, map, for, it run in parrallels users . forEach ( async ( user ) => { await getUserID ( user ) }) // output with 1000 ms delay All the users in one time:","title":"Promise with forEach, map or for"},{"location":"pages/advanced/javascript/reduce-cases/","text":"Calculate price basket Initial object const caddie = [ { book : 1 , price : 19.99 }, { beer : 6 , price : 4.5 }, { bread : 1 , price : 1.2 } ]; Calculate the caddie price const price = caddie . reduce (( acc , curr ) => acc + curr . price , 0 ); console . log ( price . toFixed ( 2 )); // 25.69 Reformat data in object Initial object const musicians = [ { id : 12345 , firstName : \"Stevie\" , lastName : \"Tay Vaughn\" , instrument : \"Guitar\" }, { id : 8877 , firstName : \"Jaco\" , lastName : \"Pastorius Vaughn\" , instrument : \"Bass Guitar\" }, { id : 87 , firstName : \"Mitch\" , lastName : \"Micthele\" , instrument : \"Drums\" } ]; Tip Its Easier to call the date by the ID in a object (instead of search) : Get musicians list const musiciansList = musicians . reduce (( acc , curr ) => { const { id , ... othersProps } = curr ; acc [ id ] = othersProps ; return acc ; }, {}); console . log ( musiciansList ); // return { 87:{...}, 8877:{...}, 12345:{...} } console . log ( musiciansList [ 87 ]); // return Micth object Calculate the number of pizzas Initial object const pizzas = [ { userName : \"Bob\" , pizzaName : \"Marguarita\" , qty : 1 }, { userName : \"Sam\" , pizzaName : \"Veggie\" , qty : 2 }, { userName : \"John\" , pizzaName : \"Regina\" , qty : 3 }, { userName : \"Kim\" , pizzaName : \"Regina\" , qty : 1 }, { userName : \"James\" , pizzaName : \"Calzone\" , qty : 1 }, { userName : \"Morley\" , pizzaName : \"Marguarita\" , qty : 5 } ]; Tip Give the number of pizza per type : const pizzaPerType = pizzas . reduce (( acc , curr ) => { if ( Object . keys ( acc ). includes ( curr . pizzaName )) { acc [ curr . pizzaName ] += curr . qty ; } else { acc [ curr . pizzaName ] = curr . qty ; } return acc ; }, {}); console . log ( pizzaPerType ); // Output : { Marguarita: 6, Veggie: 2, Regina: 4, Calzone: 1 }","title":"Reduce cases"},{"location":"pages/advanced/javascript/reduce-cases/#calculate-price-basket","text":"Initial object const caddie = [ { book : 1 , price : 19.99 }, { beer : 6 , price : 4.5 }, { bread : 1 , price : 1.2 } ]; Calculate the caddie price const price = caddie . reduce (( acc , curr ) => acc + curr . price , 0 ); console . log ( price . toFixed ( 2 )); // 25.69","title":"Calculate price basket"},{"location":"pages/advanced/javascript/reduce-cases/#reformat-data-in-object","text":"Initial object const musicians = [ { id : 12345 , firstName : \"Stevie\" , lastName : \"Tay Vaughn\" , instrument : \"Guitar\" }, { id : 8877 , firstName : \"Jaco\" , lastName : \"Pastorius Vaughn\" , instrument : \"Bass Guitar\" }, { id : 87 , firstName : \"Mitch\" , lastName : \"Micthele\" , instrument : \"Drums\" } ]; Tip Its Easier to call the date by the ID in a object (instead of search) : Get musicians list const musiciansList = musicians . reduce (( acc , curr ) => { const { id , ... othersProps } = curr ; acc [ id ] = othersProps ; return acc ; }, {}); console . log ( musiciansList ); // return { 87:{...}, 8877:{...}, 12345:{...} } console . log ( musiciansList [ 87 ]); // return Micth object","title":"Reformat data in object"},{"location":"pages/advanced/javascript/reduce-cases/#calculate-the-number-of-pizzas","text":"Initial object const pizzas = [ { userName : \"Bob\" , pizzaName : \"Marguarita\" , qty : 1 }, { userName : \"Sam\" , pizzaName : \"Veggie\" , qty : 2 }, { userName : \"John\" , pizzaName : \"Regina\" , qty : 3 }, { userName : \"Kim\" , pizzaName : \"Regina\" , qty : 1 }, { userName : \"James\" , pizzaName : \"Calzone\" , qty : 1 }, { userName : \"Morley\" , pizzaName : \"Marguarita\" , qty : 5 } ]; Tip Give the number of pizza per type : const pizzaPerType = pizzas . reduce (( acc , curr ) => { if ( Object . keys ( acc ). includes ( curr . pizzaName )) { acc [ curr . pizzaName ] += curr . qty ; } else { acc [ curr . pizzaName ] = curr . qty ; } return acc ; }, {}); console . log ( pizzaPerType ); // Output : { Marguarita: 6, Veggie: 2, Regina: 4, Calzone: 1 }","title":"Calculate the number of pizzas"},{"location":"pages/advanced/javascript/set/","text":"Set intro The Set object in JavaScript lets you store unique values of any type. const set = new Set (); To append values to the Set object, use the add method passsing in the value as its argument. const set = new Set (); set . add ( 1 ); set . add ( 2 ); set . add ( 1 ); // -> Does not get added To check the number of values in the set, you can use the size property. const set = new Set (); set . add ( 1 ); set . add ( 2 ); set . size ; // -> Returns 2 To check if a value exists in the set, use the has method. set . has ( 1 ); // -> Returns true set . has ( 5 ); // -> Returns false To remove a value from the set, use the delete method passing in the value. To delete all the values in the set, use the clear method. set . delete ( 1 ); // -> Returns true set . delete ( 5 ); // -> Returns false set . clear (); set . size ; // -> Returns 0 Set and Array Conversion Array to Set const numArr = [ 1 , 2 ]; const numSet = new Set ([ numArr ]); Set to Array const numArr = [ 1 , 2 ]; const numSet = new Set ( numArr ); // just deconstruct set [... numSet ] Iterating over a Set const set = new Set (); set . add ( 1 ); set . add ( 2 ); for ( let value of set ) { console . log ( value ); } // output: 1 2","title":"Set"},{"location":"pages/advanced/javascript/set/#set-intro","text":"The Set object in JavaScript lets you store unique values of any type. const set = new Set (); To append values to the Set object, use the add method passsing in the value as its argument. const set = new Set (); set . add ( 1 ); set . add ( 2 ); set . add ( 1 ); // -> Does not get added To check the number of values in the set, you can use the size property. const set = new Set (); set . add ( 1 ); set . add ( 2 ); set . size ; // -> Returns 2 To check if a value exists in the set, use the has method. set . has ( 1 ); // -> Returns true set . has ( 5 ); // -> Returns false To remove a value from the set, use the delete method passing in the value. To delete all the values in the set, use the clear method. set . delete ( 1 ); // -> Returns true set . delete ( 5 ); // -> Returns false set . clear (); set . size ; // -> Returns 0","title":"Set intro"},{"location":"pages/advanced/javascript/set/#set-and-array-conversion","text":"Array to Set const numArr = [ 1 , 2 ]; const numSet = new Set ([ numArr ]); Set to Array const numArr = [ 1 , 2 ]; const numSet = new Set ( numArr ); // just deconstruct set [... numSet ]","title":"Set and Array Conversion"},{"location":"pages/advanced/javascript/set/#iterating-over-a-set","text":"const set = new Set (); set . add ( 1 ); set . add ( 2 ); for ( let value of set ) { console . log ( value ); } // output: 1 2","title":"Iterating over a Set"},{"location":"pages/advanced/javascript/setinterval/","text":"Timeouts & Intervals setinterval() The setinterval() function repeatedly runs the same code over and over again at regular intervals. setInterval ( function , duration , param1 , param2 , ...); The first parameter is the code to execute. *The second parameter is the duration in milliseconds. After the second parameter, you can pass in zero or more values that represent any parameters you want to pass to the function when it is run. function greet () { console . log ( \"Hello\" ); } setInterval ( greet , 20090 ) // -> Logs \u2018Hello\u2019 every 2 seconds clearInterval() Intervals keep running a task forever so you should clear the interval when appropriate. const intervalId = setInterval ( greet , 2000 , 'Vishwas' ); clearInterval ( intervalId ); setInterval & setTimeOut: Noteworthy points It is possible to achieve the same effect as setinterval with a recursive setTimeout. setTimeout ( function run () { console . log ( 'Hello' ) setTimeout ( run , 100 ); }, 100 ); // output 'Hello' to endless loop each 100ms Duration is guaranteed between executions: Irrespective of how long the code takes to run, the interval will remain the same. Code can take longer to run the the time interval itself? Recursive setTimeout . You can calculate a different delay before running each iteration. setInterval ( () => { console . log ( \u2018 Hello \u2019 ) }, 100 ); The duration interval includes the time taken to execute the code you want to run: The code takes 40ms to run, the interval is 60ms The code takes 50ms to run, the interval is 50ms setinterval is always a fixed interval duration","title":"Timeouts & Intervals"},{"location":"pages/advanced/javascript/setinterval/#timeouts-intervals","text":"","title":"Timeouts &amp; Intervals"},{"location":"pages/advanced/javascript/setinterval/#setinterval","text":"The setinterval() function repeatedly runs the same code over and over again at regular intervals. setInterval ( function , duration , param1 , param2 , ...); The first parameter is the code to execute. *The second parameter is the duration in milliseconds. After the second parameter, you can pass in zero or more values that represent any parameters you want to pass to the function when it is run. function greet () { console . log ( \"Hello\" ); } setInterval ( greet , 20090 ) // -> Logs \u2018Hello\u2019 every 2 seconds","title":"setinterval()"},{"location":"pages/advanced/javascript/setinterval/#clearinterval","text":"Intervals keep running a task forever so you should clear the interval when appropriate. const intervalId = setInterval ( greet , 2000 , 'Vishwas' ); clearInterval ( intervalId );","title":"clearInterval()"},{"location":"pages/advanced/javascript/setinterval/#setinterval-settimeout-noteworthy-points","text":"It is possible to achieve the same effect as setinterval with a recursive setTimeout. setTimeout ( function run () { console . log ( 'Hello' ) setTimeout ( run , 100 ); }, 100 ); // output 'Hello' to endless loop each 100ms Duration is guaranteed between executions: Irrespective of how long the code takes to run, the interval will remain the same. Code can take longer to run the the time interval itself? Recursive setTimeout . You can calculate a different delay before running each iteration. setInterval ( () => { console . log ( \u2018 Hello \u2019 ) }, 100 ); The duration interval includes the time taken to execute the code you want to run: The code takes 40ms to run, the interval is 60ms The code takes 50ms to run, the interval is 50ms setinterval is always a fixed interval duration","title":"setInterval &amp; setTimeOut: Noteworthy points"},{"location":"pages/advanced/javascript/this-examples/","text":"Binding args example bind method with arguments function bind ( fn , context ) { return function () { fn . apply ( context , [... arguments ]); } } Question What is logged to the console? // use the bind previous function code const person = { name : 'Vishwas' } function sayMyName ( lastname ) { console . log ( `My name is ${ this . name } ${ lastname } ` ); } const boundFn = bind ( sayMyName , person ); boundFn ( 'Batman' ); Answer Line 6 : 'My name is Vishwas Batman' Explicit binding example Question What is logged to the console? const person = { name : 'Vishwas' } function sayMyName () { console . log ( `My name is ${ this . name } ` ); } const sayMyNameVishwas = sayMyName . bind ( person ) sayMyNameVishwas () Answer Line 6 : My name is Vishwas (Explicit binding) Implicit binding example Question What is logged to the console? const person = { name : 'Vishwas' , sayMyName () { console . log ( `My name is ${ this . name } ` ); }, superHero : { name : 'Batman' , sayMyName () { console . log ( `My name is ${ this . name } ` ); } } } person . superHero . sayMyName (); Answer Line 4: Batman (implicit binding)","title":"This examples"},{"location":"pages/advanced/javascript/this-examples/#binding-args-example","text":"bind method with arguments function bind ( fn , context ) { return function () { fn . apply ( context , [... arguments ]); } } Question What is logged to the console? // use the bind previous function code const person = { name : 'Vishwas' } function sayMyName ( lastname ) { console . log ( `My name is ${ this . name } ${ lastname } ` ); } const boundFn = bind ( sayMyName , person ); boundFn ( 'Batman' ); Answer Line 6 : 'My name is Vishwas Batman'","title":"Binding args example"},{"location":"pages/advanced/javascript/this-examples/#explicit-binding-example","text":"Question What is logged to the console? const person = { name : 'Vishwas' } function sayMyName () { console . log ( `My name is ${ this . name } ` ); } const sayMyNameVishwas = sayMyName . bind ( person ) sayMyNameVishwas () Answer Line 6 : My name is Vishwas (Explicit binding)","title":"Explicit binding example"},{"location":"pages/advanced/javascript/this-examples/#implicit-binding-example","text":"Question What is logged to the console? const person = { name : 'Vishwas' , sayMyName () { console . log ( `My name is ${ this . name } ` ); }, superHero : { name : 'Batman' , sayMyName () { console . log ( `My name is ${ this . name } ` ); } } } person . superHero . sayMyName (); Answer Line 4: Batman (implicit binding)","title":"Implicit binding example"},{"location":"pages/advanced/javascript/this/","text":"this with Arrow fonction Question What is logged to the console in this code? Lexical binding const person = { firstName : 'Vishwas' , lastName : 'Batman' , sayMyName () { const fullName = () => { return ` ${ this . firstName } ${ this . lastName } ` ; } console . log ( `Full name is ${ fullName () } ` ); } } person . sayMyName (); Answer Line 8: 'Full name is Vishwas Batman' Unlike normal functions, an arrow function does not define a this keyword at all. this keyword in an arrow function behaves like any other variable. It is going to lexically resolve to an enclosing scope that does define this keyword. this without Arrow fonction Question What is logged to the console in this code? const person = { firstName : 'Vishwas' , lastName : 'Batman' , sayMyName () { const fullName = function () { return ` ${ this . firstName } ${ this . lastName } ` ; } console . log ( `Full name is ${ fullName () } ` ); } } person . sayMyName (); Answer Line 8: 'Full name is undefined undefined' Problem is that implicit binding is on the sayMyName function Within sayMyName, this points to the person object On line 8, fullName() has no implicit, explicit or new binding Defaults to global binding Within the fullName function, this points to the window object In the global scope, we don't have any variables called firstName or lastName this with new Binding We can invoke a function with the 'new' keyword. In such a scenario, the function is invoked with this referencing an empty object. function Person ( name ) { // constructor function this . name = name ; } const pl = new Person ( 'Vishwas' ); const p2 = new Person ( 'Batman' ); When we invoke a function with the new keyword, JavaScript under the hood will create a new empty object that 'this' keyword will reference to. Add properties to that object using this followed by the dot notation. When a function is invoked with the new keyword, within that function this keyword will always reference a new empty object. this Implicit Binding const person = { name : 'Vishwas' , sayMyName () { console . log ( `My name is ${ this . name } ` ); } }; person . sayMyName (); // -> 'My name is Vishwas' When a function is invoked with the dot notation, the object to the left of that dot is what the this keyword is referencing. this keyword is referencing the person object. this with Object : implicit Binding Fallback if none of the other three rules are matched. function sayMyName () { console . log ( `My name is ${ this . name } ` ); } sayMyName () // My name is undefined var name = 'Vishwas' ; function sayMyName () { console . log ( `My name is ${ this . name } ` ); } sayMyName (); // My name is Vishwas Important If none of the three rules are satisfied, JavaScript will default to the global scope and set this keyword to the window object. this with bind Explicit Binding const person = { name : 'Vishwas' } function sayMyName () { console . log ( `My name is ${ this . name } ` ); } // -> 'My name is ' Bind works similar to the call method but instead of invoking the function, it returns a new function that you can invoke whenever you wish to. Bind method const person = { name : 'Vishwas' } function sayMyName ( hobby1 , hobby2 ) { console . log ( `My name is ${ this . name } ` , `I'm interested in ${ hobby1 } and ${ hobby2 } ` ); } const sayMyNameVishwas = sayMyName . bind ( person , 'Chess' , 'Football' ); sayMyNameVishwas (); // -> My name is Vishwas. I'm interested in Chess and Football this with call Every function has a built in method named call which allows you to specify the context with which a function is invoked. call method const person = { name : 'Vishwas' } function sayMyName () { console . log ( `My name is ${ this . name } ` ); } sayMyName . call ( person ); // -> 'My name is Vishwas' The first argument passed to call is what this keyword inside sayMyName is referencing. If you want to specify arguments to your function, you can pass them in after the first argument to call. const person = { name : 'Vishwas' } function sayMyName ( hobby1 , hobby2 ) { console . log ( `My name is ${ this . name } ` , `I'm interested in ${ hobby1 } and ${ hobby2 } ` ); } sayMyName . call ( person , 'Chess' , 'Football' ); // -> My name is Vishwas. I'm interested in Chess and Football this with apply Every function has a built in method named apply which allows you to specify the context with which a function is invoked. apply method const person = { name : 'Vishwas' } function sayMyName () { console . log ( `My name is ${ this . name } ` ); } sayMyName . apply ( person ); // -> 'My name is Vishwas' The first argument passed to apply is what this keyword inside sayMyName is referencing. apply expects an array as its second argument. const person = { name : 'Vishwas' } function sayMyName ( hobby1 , hobby2 ) { console . log ( `My name is ${ this . name } ` , `I'm interested in ${ hobby1 } and ${ hobby2 } ` ); } sayMyName . apply ( person , [ 'Chess' , 'Football' ]); // -> My name is Vishwas. I'm interested in Chess and Football this apply vs call call takes in a comma separated arguments. apply takes in array as arguments. c all : c omma a pply : a rray Important call and apply which invoke a function right away with the context you have specified.","title":"This"},{"location":"pages/advanced/javascript/this/#this-with-arrow-fonction","text":"Question What is logged to the console in this code? Lexical binding const person = { firstName : 'Vishwas' , lastName : 'Batman' , sayMyName () { const fullName = () => { return ` ${ this . firstName } ${ this . lastName } ` ; } console . log ( `Full name is ${ fullName () } ` ); } } person . sayMyName (); Answer Line 8: 'Full name is Vishwas Batman' Unlike normal functions, an arrow function does not define a this keyword at all. this keyword in an arrow function behaves like any other variable. It is going to lexically resolve to an enclosing scope that does define this keyword.","title":"this with Arrow fonction"},{"location":"pages/advanced/javascript/this/#this-without-arrow-fonction","text":"Question What is logged to the console in this code? const person = { firstName : 'Vishwas' , lastName : 'Batman' , sayMyName () { const fullName = function () { return ` ${ this . firstName } ${ this . lastName } ` ; } console . log ( `Full name is ${ fullName () } ` ); } } person . sayMyName (); Answer Line 8: 'Full name is undefined undefined' Problem is that implicit binding is on the sayMyName function Within sayMyName, this points to the person object On line 8, fullName() has no implicit, explicit or new binding Defaults to global binding Within the fullName function, this points to the window object In the global scope, we don't have any variables called firstName or lastName","title":"this without Arrow fonction"},{"location":"pages/advanced/javascript/this/#this-with-new-binding","text":"We can invoke a function with the 'new' keyword. In such a scenario, the function is invoked with this referencing an empty object. function Person ( name ) { // constructor function this . name = name ; } const pl = new Person ( 'Vishwas' ); const p2 = new Person ( 'Batman' ); When we invoke a function with the new keyword, JavaScript under the hood will create a new empty object that 'this' keyword will reference to. Add properties to that object using this followed by the dot notation. When a function is invoked with the new keyword, within that function this keyword will always reference a new empty object.","title":"this with new Binding"},{"location":"pages/advanced/javascript/this/#this-implicit-binding","text":"const person = { name : 'Vishwas' , sayMyName () { console . log ( `My name is ${ this . name } ` ); } }; person . sayMyName (); // -> 'My name is Vishwas' When a function is invoked with the dot notation, the object to the left of that dot is what the this keyword is referencing. this keyword is referencing the person object.","title":"this Implicit Binding"},{"location":"pages/advanced/javascript/this/#this-with-object-implicit-binding","text":"Fallback if none of the other three rules are matched. function sayMyName () { console . log ( `My name is ${ this . name } ` ); } sayMyName () // My name is undefined var name = 'Vishwas' ; function sayMyName () { console . log ( `My name is ${ this . name } ` ); } sayMyName (); // My name is Vishwas Important If none of the three rules are satisfied, JavaScript will default to the global scope and set this keyword to the window object.","title":"this with Object : implicit Binding"},{"location":"pages/advanced/javascript/this/#this-with-bind","text":"Explicit Binding const person = { name : 'Vishwas' } function sayMyName () { console . log ( `My name is ${ this . name } ` ); } // -> 'My name is ' Bind works similar to the call method but instead of invoking the function, it returns a new function that you can invoke whenever you wish to. Bind method const person = { name : 'Vishwas' } function sayMyName ( hobby1 , hobby2 ) { console . log ( `My name is ${ this . name } ` , `I'm interested in ${ hobby1 } and ${ hobby2 } ` ); } const sayMyNameVishwas = sayMyName . bind ( person , 'Chess' , 'Football' ); sayMyNameVishwas (); // -> My name is Vishwas. I'm interested in Chess and Football","title":"this with bind"},{"location":"pages/advanced/javascript/this/#this-with-call","text":"Every function has a built in method named call which allows you to specify the context with which a function is invoked. call method const person = { name : 'Vishwas' } function sayMyName () { console . log ( `My name is ${ this . name } ` ); } sayMyName . call ( person ); // -> 'My name is Vishwas' The first argument passed to call is what this keyword inside sayMyName is referencing. If you want to specify arguments to your function, you can pass them in after the first argument to call. const person = { name : 'Vishwas' } function sayMyName ( hobby1 , hobby2 ) { console . log ( `My name is ${ this . name } ` , `I'm interested in ${ hobby1 } and ${ hobby2 } ` ); } sayMyName . call ( person , 'Chess' , 'Football' ); // -> My name is Vishwas. I'm interested in Chess and Football","title":"this with call"},{"location":"pages/advanced/javascript/this/#this-with-apply","text":"Every function has a built in method named apply which allows you to specify the context with which a function is invoked. apply method const person = { name : 'Vishwas' } function sayMyName () { console . log ( `My name is ${ this . name } ` ); } sayMyName . apply ( person ); // -> 'My name is Vishwas' The first argument passed to apply is what this keyword inside sayMyName is referencing. apply expects an array as its second argument. const person = { name : 'Vishwas' } function sayMyName ( hobby1 , hobby2 ) { console . log ( `My name is ${ this . name } ` , `I'm interested in ${ hobby1 } and ${ hobby2 } ` ); } sayMyName . apply ( person , [ 'Chess' , 'Football' ]); // -> My name is Vishwas. I'm interested in Chess and Football","title":"this with apply"},{"location":"pages/advanced/javascript/this/#this-apply-vs-call","text":"call takes in a comma separated arguments. apply takes in array as arguments. c all : c omma a pply : a rray Important call and apply which invoke a function right away with the context you have specified.","title":"this apply vs call"},{"location":"pages/advanced/javascript/timeout/","text":"Intro The setTimeout() function executes a particular block of code once after a specified time has elapsed. setTimeout ( function , duration , param1 , param2 , ...); The first parameter is a function to run, or a reference to a function defined elsewhere. The second parameter is a number representing the duration in milliseconds to wait before executing the code. After the second parameter, you can pass in zero or more values that represent any parameters you want to pass to the function when it is run. function greet () { console . log ( 'Hello' ); } setTimeout ( greet , 2000 ); // -> Logs 'Hello\u2019 to the console after 2 seconds function greet ( name ) { console . log ( 'Hello ${name}' ); } setTimeout ( greet , 2000 , 'Vishwas' ); // -> Logs 'Hello Vishwas' to the console after 2 seconds Clear a timeout To clear a timeout, you can use the clearTimeout() method passing in the identifier returned by setTimeout as a parameter. function greet () { console . log ( 'Hello' ); } const timeoutId = setTimeout ( greet , 2000 , 'Vishwas' ); clearTimeout ( timeoutId ); // -> Nothing is logged to the console Amore practical scenario is clearing timeouts when the component is unmounting to free up the resources and also prevent code from incorrectly executing on an unmounted component.","title":"Timeout"},{"location":"pages/advanced/javascript/timeout/#intro","text":"The setTimeout() function executes a particular block of code once after a specified time has elapsed. setTimeout ( function , duration , param1 , param2 , ...); The first parameter is a function to run, or a reference to a function defined elsewhere. The second parameter is a number representing the duration in milliseconds to wait before executing the code. After the second parameter, you can pass in zero or more values that represent any parameters you want to pass to the function when it is run. function greet () { console . log ( 'Hello' ); } setTimeout ( greet , 2000 ); // -> Logs 'Hello\u2019 to the console after 2 seconds function greet ( name ) { console . log ( 'Hello ${name}' ); } setTimeout ( greet , 2000 , 'Vishwas' ); // -> Logs 'Hello Vishwas' to the console after 2 seconds","title":"Intro"},{"location":"pages/advanced/javascript/timeout/#clear-a-timeout","text":"To clear a timeout, you can use the clearTimeout() method passing in the identifier returned by setTimeout as a parameter. function greet () { console . log ( 'Hello' ); } const timeoutId = setTimeout ( greet , 2000 , 'Vishwas' ); clearTimeout ( timeoutId ); // -> Nothing is logged to the console Amore practical scenario is clearing timeouts when the component is unmounting to free up the resources and also prevent code from incorrectly executing on an unmounted component.","title":"Clear a timeout"},{"location":"pages/advanced/remix/","tags":["Remix","Remix-run"],"text":"","title":"Remix"},{"location":"pages/advanced/remix/discord-discussions/","text":"Discord Discussions Remix Catch boundary import type { LoaderFunction } from 'remix' export const loader : LoaderFunction = function () { throw new Response ( null , { status : 404 }) } export function CatchBoundary () { return < h1 > 404 Not Found < /h1> } export default function () {} Preload Images with remix so what I do is in Remix I import those hero images in different sizes, all are webp images compressed, then I set them as CSS variables using inline styles, and image-set let the browser pick what image to use based on the device pixel density # hero { background-image : var ( --hero-image-4x ); background-image : image-set ( var ( --hero-image-1x ) 1 x , var ( --hero-image-2x ) 2 x , var ( --hero-image-3x ) 3 x , var ( --hero-image-4x ) 4 x ); background-image : -webkit- image-set ( var ( --hero-image-1x ) 1 x , var ( --hero-image-2x ) 2 x , var ( --hero-image-3x ) 3 x , var ( --hero-image-4x ) 4 x ); } and I have a LinksFunction,. rendering a preload link which will also preload the image { rel : \"preload\" , as : \"image\" , href : heroBg4x , imagesrcset : ` ${ heroBg } 1x, ${ heroBg2x } 2x, ${ heroBg3x } 3x, ${ heroBg4x } 4x` , } this is the preload for the hero image using imagesrcset the browser will also use that srcset to choose the correct image which will match the image the CSS will ask for. Sure, the image-set is fine. But you run into the issue that the browser needs to parse your CSS first to get the image. the preload tag solves that image is preloaded before the CSS is even loaded the JS object? it's from a LinksFunction ? something like that, but with more links : // it preload heroBg4x image from header export let links : LinksFunction = () => { return [ { rel : \"preload\" , as : \"image\" , href : heroBg4x , imagesrcset : ` ${ heroBg } 1x, ${ heroBg2x } 2x, ${ heroBg3x } 3x, ${ heroBg4x } 4x` , } ] } Don't fight the browser preload scanner I have been testing this a lot for like a week to make that page load fast and don't have issues with the image not loading immediately Preload only works if you know exactly which of the images you need to preload, which in the case of a srcset or image set, defeats the purpose preload has a imagesrcset to let you preload based on an srcset. the browser only preload the same image from the srcset the CSS or img tag is gonna use later Preloading responsive images ok, so you use the link preloader, then the CSS uses whichever one fits. That all seems to work out well in my head yeah, so the image is preloaded while CSS is also being downloaded, once CSS loads and is parsed it will chose and image which will be the same image the browser preloaded before if internet is slow it can still happen that the hero takes a while to show up but at least it doesn't need to wait for CSS to start loading. most of the work is exporting each variant of the image and ensuring its compressed what would be cool is to have a resource route where I could render <Image src=\"/path/to/the/file\" /> and get the picture tag with multiple sources asking for different pixel densities < picture > < source srcSet = {`${mockupDesktop} 1x , ${ mockupDesktop2x } 2x , ${ mockupDesktop3x } 3x , ${ mockupDesktop4x } 4x `} media = \"(min-width: 768px)\" /> < source srcSet = {`${mockupMobile} 1x , ${ mockupMobile2x } 2x , ${ mockupMobile3x } 3x , ${ mockupMobile4x } 4x `} media = \"(max-width: 767px)\" /> < img src = {mockupDesktop4x} srcSet = {`${mockupDesktop} 1x , ${ mockupDesktop2x } 2x , ${ mockupDesktop3x } 3x , ${ mockupDesktop4x } 4x `} height = {589.82} width = {298.38} alt = \"\" className = \"max-w-48 md:max-w-72\" decoding = \"async\" /> </ picture > for more dynamic Image, yes you need some service to optimize the images you need the image component to send the URL to an API the optimization needs to happen at runtime but the response needs to have a cache-control header and the API needs to be behind a CDN so you only really do it once per image Cloudflare has an image optimization service that works this way Cloudflare Image Optimization \u00b7 Cloudflare Image Optimization docs Next.js Image component does that too, you could use Cloudinary for that too but this one becomes expensive and they charge the bandwidth too","title":"Discord Discussions"},{"location":"pages/advanced/remix/discord-discussions/#discord-discussions","text":"","title":"Discord Discussions"},{"location":"pages/advanced/remix/discord-discussions/#remix-catch-boundary","text":"import type { LoaderFunction } from 'remix' export const loader : LoaderFunction = function () { throw new Response ( null , { status : 404 }) } export function CatchBoundary () { return < h1 > 404 Not Found < /h1> } export default function () {}","title":"Remix Catch boundary"},{"location":"pages/advanced/remix/discord-discussions/#preload-images-with-remix","text":"so what I do is in Remix I import those hero images in different sizes, all are webp images compressed, then I set them as CSS variables using inline styles, and image-set let the browser pick what image to use based on the device pixel density # hero { background-image : var ( --hero-image-4x ); background-image : image-set ( var ( --hero-image-1x ) 1 x , var ( --hero-image-2x ) 2 x , var ( --hero-image-3x ) 3 x , var ( --hero-image-4x ) 4 x ); background-image : -webkit- image-set ( var ( --hero-image-1x ) 1 x , var ( --hero-image-2x ) 2 x , var ( --hero-image-3x ) 3 x , var ( --hero-image-4x ) 4 x ); } and I have a LinksFunction,. rendering a preload link which will also preload the image { rel : \"preload\" , as : \"image\" , href : heroBg4x , imagesrcset : ` ${ heroBg } 1x, ${ heroBg2x } 2x, ${ heroBg3x } 3x, ${ heroBg4x } 4x` , } this is the preload for the hero image using imagesrcset the browser will also use that srcset to choose the correct image which will match the image the CSS will ask for. Sure, the image-set is fine. But you run into the issue that the browser needs to parse your CSS first to get the image. the preload tag solves that image is preloaded before the CSS is even loaded the JS object? it's from a LinksFunction ? something like that, but with more links : // it preload heroBg4x image from header export let links : LinksFunction = () => { return [ { rel : \"preload\" , as : \"image\" , href : heroBg4x , imagesrcset : ` ${ heroBg } 1x, ${ heroBg2x } 2x, ${ heroBg3x } 3x, ${ heroBg4x } 4x` , } ] } Don't fight the browser preload scanner I have been testing this a lot for like a week to make that page load fast and don't have issues with the image not loading immediately Preload only works if you know exactly which of the images you need to preload, which in the case of a srcset or image set, defeats the purpose preload has a imagesrcset to let you preload based on an srcset. the browser only preload the same image from the srcset the CSS or img tag is gonna use later Preloading responsive images ok, so you use the link preloader, then the CSS uses whichever one fits. That all seems to work out well in my head yeah, so the image is preloaded while CSS is also being downloaded, once CSS loads and is parsed it will chose and image which will be the same image the browser preloaded before if internet is slow it can still happen that the hero takes a while to show up but at least it doesn't need to wait for CSS to start loading. most of the work is exporting each variant of the image and ensuring its compressed what would be cool is to have a resource route where I could render <Image src=\"/path/to/the/file\" /> and get the picture tag with multiple sources asking for different pixel densities < picture > < source srcSet = {`${mockupDesktop} 1x , ${ mockupDesktop2x } 2x , ${ mockupDesktop3x } 3x , ${ mockupDesktop4x } 4x `} media = \"(min-width: 768px)\" /> < source srcSet = {`${mockupMobile} 1x , ${ mockupMobile2x } 2x , ${ mockupMobile3x } 3x , ${ mockupMobile4x } 4x `} media = \"(max-width: 767px)\" /> < img src = {mockupDesktop4x} srcSet = {`${mockupDesktop} 1x , ${ mockupDesktop2x } 2x , ${ mockupDesktop3x } 3x , ${ mockupDesktop4x } 4x `} height = {589.82} width = {298.38} alt = \"\" className = \"max-w-48 md:max-w-72\" decoding = \"async\" /> </ picture > for more dynamic Image, yes you need some service to optimize the images you need the image component to send the URL to an API the optimization needs to happen at runtime but the response needs to have a cache-control header and the API needs to be behind a CDN so you only really do it once per image Cloudflare has an image optimization service that works this way Cloudflare Image Optimization \u00b7 Cloudflare Image Optimization docs Next.js Image component does that too, you could use Cloudinary for that too but this one becomes expensive and they charge the bandwidth too","title":"Preload Images with remix"},{"location":"pages/advanced/remix/remix-fly/","text":"Remix with Fly Needed Tools Install Git Install GitHub CLI Install Fly CLI : $ brew install flyctl # on mac, see Instal doc for others OS # login to fly $ fly auth signup # List all fly accounts with whoami: $ fly auth whoami Create remix app # via remix stack on blues-stack template # Taiwind + Docker + Postgres + Vitest + Cypress with CI/CD on Fly $ npx create-remix --template remix-run/blues-stack <repo-name> # or use efx/reapp # it does a pnpm setup + Postgres docker mount/migration + Git setup $ reapp.sh --remix <repo-name> $ cd <repo-name> Create the github repository # $ repo=\"my-repo\" # setup repo # $ read -p \"Enter your repo name : \" repo # or ask it # test if its a remix app $ [ ! -n $( grep \"^@remix-run/react\\$\" package.json ) ] && echo \"No remix app\" && exit # auto get from current repo $ repo = $( basename $( pwd )) # Login to gh $ gh auth login # <repository> is your github repository name in public $ gh repo create \" $repo \" --public # or in private : $ gh repo create \" $repo \" --private # repo url = https://github.com/<account>/<repository>.git $ git init # change master to main (prod) $ git branch -m master main # Add files $ git add . # Do the first commit $ git commit -m \"First Setup\" # create a dev branch for staging $ git branch dev # do not publish yet before to setup fly # main branch is for fly prod server # dev branch is for fly staging server Fly setup # get authentified $ fly auth signup # Create fly servers (prod and staging) $ fly create \" $repo \" $ fly create \" $repo \" -staging # Create secrets app $ fly secrets set SESSION_SECRET = $( openssl rand -hex 32 ) --app \" $repo \" $ fly secrets set SESSION_SECRET = $( openssl rand -hex 32 ) --app \" $repo \" -staging $ fly secrets set ADMIN_EMAIL = laurent@efxdesign.fr # Create Fly DBs $ fly postgres create --name \" $repo \" -db $ fly postgres create --name \" $repo \" -staging-db # Attach dbs to servers $ fly postgres attach --postgres-app \" $repo \" -db --app \" $repo \" $ fly postgres attach --postgres-app \" $repo \" -staging-db --app \" $repo \" -staging Publish to Git for deploy in fly Create FLY_API_TOKEN from Fly : Create New Fly Token Paste the FLY_API_TOKEN in Secrets>Actions>\u201dnew repository secret\u201c OR : # auth to githun gh $ gh auth login # setup origin repo $ git remote add origin \"https://github.com/electroheadfx/ ${ repo } .git\" # paste the key via cli $TOKEN $ gh secret set FLY_API_TOKEN --body \" $TOKEN \" # or paste via pasteboard $ gh secret set FLY_API_TOKEN Publish the code, it will run the deploy action from Github, to Fly : $ git push -u origin main How Delete an repo/app on git and fly # Delete Github repository # Get repo input # login $ gh auth login # delete repo $ gh repo delete \"https://github.com/electroheadfx/ ${ repo } .git\" # --confirm if you are sure # Delete Fly apps server $ fly apps list # see the fly apps # destroy the prod/staging servers $ fly destroy \" $repo \" && fly destroy \" $repo \" -staging # destroy the prod/staging DBs servers $ fly destroy \" $repo \" -db && fly destroy \" $repo \" -staging-db","title":"Remix with Fly"},{"location":"pages/advanced/remix/remix-fly/#remix-with-fly","text":"","title":"Remix with Fly"},{"location":"pages/advanced/remix/remix-fly/#needed-tools","text":"Install Git Install GitHub CLI Install Fly CLI : $ brew install flyctl # on mac, see Instal doc for others OS # login to fly $ fly auth signup # List all fly accounts with whoami: $ fly auth whoami","title":"Needed Tools"},{"location":"pages/advanced/remix/remix-fly/#create-remix-app","text":"# via remix stack on blues-stack template # Taiwind + Docker + Postgres + Vitest + Cypress with CI/CD on Fly $ npx create-remix --template remix-run/blues-stack <repo-name> # or use efx/reapp # it does a pnpm setup + Postgres docker mount/migration + Git setup $ reapp.sh --remix <repo-name> $ cd <repo-name>","title":"Create remix app"},{"location":"pages/advanced/remix/remix-fly/#create-the-github-repository","text":"# $ repo=\"my-repo\" # setup repo # $ read -p \"Enter your repo name : \" repo # or ask it # test if its a remix app $ [ ! -n $( grep \"^@remix-run/react\\$\" package.json ) ] && echo \"No remix app\" && exit # auto get from current repo $ repo = $( basename $( pwd )) # Login to gh $ gh auth login # <repository> is your github repository name in public $ gh repo create \" $repo \" --public # or in private : $ gh repo create \" $repo \" --private # repo url = https://github.com/<account>/<repository>.git $ git init # change master to main (prod) $ git branch -m master main # Add files $ git add . # Do the first commit $ git commit -m \"First Setup\" # create a dev branch for staging $ git branch dev # do not publish yet before to setup fly # main branch is for fly prod server # dev branch is for fly staging server","title":"Create the github repository"},{"location":"pages/advanced/remix/remix-fly/#fly-setup","text":"# get authentified $ fly auth signup # Create fly servers (prod and staging) $ fly create \" $repo \" $ fly create \" $repo \" -staging # Create secrets app $ fly secrets set SESSION_SECRET = $( openssl rand -hex 32 ) --app \" $repo \" $ fly secrets set SESSION_SECRET = $( openssl rand -hex 32 ) --app \" $repo \" -staging $ fly secrets set ADMIN_EMAIL = laurent@efxdesign.fr # Create Fly DBs $ fly postgres create --name \" $repo \" -db $ fly postgres create --name \" $repo \" -staging-db # Attach dbs to servers $ fly postgres attach --postgres-app \" $repo \" -db --app \" $repo \" $ fly postgres attach --postgres-app \" $repo \" -staging-db --app \" $repo \" -staging","title":"Fly setup"},{"location":"pages/advanced/remix/remix-fly/#publish-to-git-for-deploy-in-fly","text":"Create FLY_API_TOKEN from Fly : Create New Fly Token Paste the FLY_API_TOKEN in Secrets>Actions>\u201dnew repository secret\u201c OR : # auth to githun gh $ gh auth login # setup origin repo $ git remote add origin \"https://github.com/electroheadfx/ ${ repo } .git\" # paste the key via cli $TOKEN $ gh secret set FLY_API_TOKEN --body \" $TOKEN \" # or paste via pasteboard $ gh secret set FLY_API_TOKEN Publish the code, it will run the deploy action from Github, to Fly : $ git push -u origin main","title":"Publish to Git for deploy in fly"},{"location":"pages/advanced/remix/remix-fly/#how-delete-an-repoapp-on-git-and-fly","text":"# Delete Github repository # Get repo input # login $ gh auth login # delete repo $ gh repo delete \"https://github.com/electroheadfx/ ${ repo } .git\" # --confirm if you are sure # Delete Fly apps server $ fly apps list # see the fly apps # destroy the prod/staging servers $ fly destroy \" $repo \" && fly destroy \" $repo \" -staging # destroy the prod/staging DBs servers $ fly destroy \" $repo \" -db && fly destroy \" $repo \" -staging-db","title":"How Delete an repo/app on git and fly"},{"location":"pages/basis/","tags":["web","advanced"],"text":"","title":"Basis"},{"location":"pages/basis/es6/","text":"ES Module //fichier /helper/math/simple-math.js export function somme ( a , b ) { return a + b } export let auteur = 'Euler' export const PI = 3.14 // the default export export default function multiplication ( a , b ) { return a * b } // import the default import math from 'helper/math/simple-math' // or any name you need import myMath from 'helper/math/simple-math' // or import default and the others modules in one line: import math , { auteur , PI , somme } from 'helper/math/simple-math' // you can change module name normal export (author) import math , { auteur as author , PI , somme } from 'helper/math/simple-math' math ( 6 , 6 ) // retourne 36 somme ( 6 , 6 ) // retourne 12 console . log ( author ) // return Euler console . log ( PI ) // return 3.14 Template literal let a = 5 let b = 10 const name = 'toto' console . log ( `Mon nom ${ name } & Quinze vaut ${ a + b } etnon ${ 2 * a + b } .` ) // \"Quinze vaut 15 et // non 20.\" Destructuring With Object const personne = { nom : 'john' , prenom : 'doe' , age : 25 , ville : 'paris' } function sayHello ( personne ) { const nom = personne . nom const prenom = personne . prenom const age = personne . age const ville = personne . ville console . log ( `Bonjour ${ nom } ${ prenom } tu as ${ age } \u00e0 ${ ville } ` ) } // \u2193 identique \u00e0 \u2193 //m\u00eame fonction mais avec la destructuration function sayHello ( personne ) { const { nom , prenom , age , ville } = personne console . log ( `Bonjour ${ nom } ${ prenom } tu as ${ age } \u00e0 ${ ville } ` ) } //on peut aussi faire la destructuration en parametre function sayHello ({ nom , prenom , age , ville }) { console . log ( `Bonjour ${ nom } ${ prenom } tu as ${ age } \u00e0 ${ ville } ` ) } With Array const toto = [ 'un' , 'deux' , 'trois' ] // sans utiliser la d\u00e9composition const un = toto [ 0 ] const deux = toto [ 1 ] const trois = toto [ 2 ] // en utilisant la d\u00e9composition const [ un , deux , trois ] = toto With function const personne = { nom : 'john' , prenom : 'doe' , age : 25 , ville : 'paris' } const showPersonne = ({ nom , prenom , age , ville }) => { console . log ( `Bonjour ${ nom } ${ prenom } tu as ${ age } \u00e0 ${ ville } ` ) } showPersonne ( personne ) Shortlang const prenom = 'codeur' const age = 'bali' const ville = 'paris' // instead to do this: const personne = { prenom : prenom , age : age , ville : ville } // do: const personne = { prenom , age , ville } Arrow function Fonctions fl\u00e9ch\u00e9es - JavaScript | MDN ] //fonctions classiques function sayHello () { return 'hello' } function sayHelloName ( name ) { return 'hello ' + name } function somme ( a , b ) { return a + b } //fonctions fl\u00e9ch\u00e9es const sayHello = () => 'hello' const sayHelloName = name => 'hello ' + name const somme = ( a , b ) => a + b const somme = ( a , b ) => { let c = a + b return c } Nullish coalishing It allow to avoid js error with null or undefined data. Nullish coalescing operator Docs function sayHello ( name ) { let nameSafe = name ?? 'anonyme' return `Bonjour ${ nameSafe } ` } sayHello () // Bonjour anonyme sayHello ( null ) // Bonjour anonyme sayHello ( 'Mike' ) // Bonjour mike Optional chaining Optional chaining Docs For using data in object we need to test them if it's not undefined : const countryCode = personne . adress . country . code //\u274c non null safe //Uncaught TypeError: Cannot read property 'country' of undefined // manage the null safe if ( personne && personne . adress && personne . adress . country ) { const countryCode = personne . adress . country . code } // or const countryCode = personne && personne . adress && personne . adress . country . code With ES6 we can use the optional chaining : const countryCode = personne ? . adress ? . country ? . code // return the data or null without error Ternal operator L'op\u00e9rateur conditionnel Doc //m\u00e9thode classique function welcome ( isAdmin ) { if ( isAdmin ) { return 'Hello Admin' } else { return 'Hello Member' } } //\u00e9quivalent en ternaire function welcome ( isAdmin ) { return isAdmin ? 'Hello Admin' : 'Hello Member' } Array methods in ES6 Array.prototype.every() - Docs const computers = [ { id : 'pc-1' , name : 'MacBook Pro' , features : [ 'usb-c' , 'screen-15' , 'batterie' , 'keyboard' , 'webcam' , 'ssd-1to' , ], }, { id : 'pc-2' , name : 'Lenovo' , features : [ 'usb-a' , 'screen-15' , 'batterie' , 'keyboard' , 'ssd-500go' ], }, { id : 'pc-3' , name : 'MSI' , features : [ 'usb-a' , 'screen-13' , 'batterie' , 'keyboard' , 'webcam' , 'ssd-500go' , ], }, ] Use with : map => array computers . map ( computer => 'Brand/' + computer . name ) // ['Brand/MacBook Pro', 'Brand/Lenovo', 'Brand/MSI'] `forEach`` => executes your code once for each array element computers . forEach ( computer => { console . log ( computer . name ) } ) // 'MacBook Pro' // 'Lenovo' // 'MSI' let computerListName = []; computers . forEach ( function ( item ){ computerListName . push ( item ); }); // computerListName = [ 'MacBook Pro', 'Lenovo', 'MSI' ] filter (with includes ) => array // output only computers with 'screen-15' feature computers . filter ( computer => computer . features . includes ( 'screen-15' )) // [{id: 'pc-1', ..etc}, {id: 'pc-2', ...}] some => boolean // test if there is any computer with ''ssd-2to' feature computers . some ( computer => computer . features . includes ( 'ssd-2to' )) // output false every => boolean // Test if every computer has feature like 'ssd-1to' or 'keyboard' computers . every ( computer => computer . features . includes ( 'ssd-1to' )) // output false computers . every ( computer => computer . features . includes ( 'keyboard' )) // output true find => first element that satisfies the provided testing function // Find every computer which are ''MacBook Pro' (it found one) computers . find ( computer => computer . name === 'MacBook Pro' ) // {id: 'pc-1', name: 'MacBook Pro', ...} reduce => value from the calculation on the preceding element The scheme is : array.reduce((accumulator, element) // Output every computer's features in any array with a spray operators computers . reduce (( allFeatures , computer ) => { return [... allFeatures , ... computer . features ] }, []) // output : // [ 'usb-c', 'screen-15', 'batterie', 'keyboard', 'webcam', 'ssd-1to', // 'usb-a', 'screen-15', 'batterie', 'keyboard', 'ssd-500go', 'usb-a', // 'screen-13', 'batterie', 'keyboard', 'webcam', 'ssd-500go' ] Exemple with filter and map Find every computer with webcam and output their names. const webCamPcName = computers . filter ( computer => computer . features . includes ( 'webcam' ) ) . map ( computer => computer . name ); console . log ( webCamPcName ); // [show MacBook Pro, MSI] Rest parameters Math . min ( 100 , 10 , 1 ) // retoune 1 const arr = [ 5 , 6 , 8 , 4 , 9 ] Math . min ( arr [ 0 ], arr [ 1 ], arr [ 2 ], arr [ 3 ], arr [ 4 ]) // Same thing with with Rest Math . min (... arr ) Spread operator // spread with object const personne = { nom : 'mike' , prenom : 'codeur' , adresse : 'bali' } const personne2 = {... personne , rue : 17 } // spread with array let numberStore = [ 0 , 1 , 2 ]; let newNumber = 12 ; numberStore = [... numberStore , newNumber ]; Promise Async Await Promise - JavaScript | MDN Voir le cours plus \u00e9volu\u00e9 dans advanced async-await et callback Create the promise : //cr\u00e9ation d'un promise function simulationFetch ( duration = 0 ) { return new Promise (( resolve , reject ) => { setTimeout (() => { if ( duration > 400 ) { reject ( `KO Timeout` ) } else { resolve ( `OK` ) } }, duration ) }) } Use the promise simulationFetch ( 100 ). then ( callBackOK , callBakcError ) simulationFetch ( 100 ). then ( e => console . log ( e ), err => console . error ( err ), ) // OK simulationFetch ( 500 ). then ( e => console . log ( e ), err => console . error ( err ), ) // KO Use the promise with async/await async function simulationFetchAsyncSuccess () { const result = await simulationFetch ( 200 ) return `success: ${ result } ` } async function simulationFetchAsyncFailed () { const result = await simulationFetch ( 500 ) return `failed: ${ result } ` // ne devrait pas etre execut\u00e9 } async function simulationFetchAsyncCatch () { let result try { result = await simulationFetch ( 500 , true ) return `failed: ${ result } ` // this would not be executed } catch ( error ) { return `failed and recovered: ${ error } ` } }","title":"Es6"},{"location":"pages/basis/es6/#es-module","text":"//fichier /helper/math/simple-math.js export function somme ( a , b ) { return a + b } export let auteur = 'Euler' export const PI = 3.14 // the default export export default function multiplication ( a , b ) { return a * b } // import the default import math from 'helper/math/simple-math' // or any name you need import myMath from 'helper/math/simple-math' // or import default and the others modules in one line: import math , { auteur , PI , somme } from 'helper/math/simple-math' // you can change module name normal export (author) import math , { auteur as author , PI , somme } from 'helper/math/simple-math' math ( 6 , 6 ) // retourne 36 somme ( 6 , 6 ) // retourne 12 console . log ( author ) // return Euler console . log ( PI ) // return 3.14","title":"ES Module"},{"location":"pages/basis/es6/#template-literal","text":"let a = 5 let b = 10 const name = 'toto' console . log ( `Mon nom ${ name } & Quinze vaut ${ a + b } etnon ${ 2 * a + b } .` ) // \"Quinze vaut 15 et // non 20.\"","title":"Template literal"},{"location":"pages/basis/es6/#destructuring","text":"With Object const personne = { nom : 'john' , prenom : 'doe' , age : 25 , ville : 'paris' } function sayHello ( personne ) { const nom = personne . nom const prenom = personne . prenom const age = personne . age const ville = personne . ville console . log ( `Bonjour ${ nom } ${ prenom } tu as ${ age } \u00e0 ${ ville } ` ) } // \u2193 identique \u00e0 \u2193 //m\u00eame fonction mais avec la destructuration function sayHello ( personne ) { const { nom , prenom , age , ville } = personne console . log ( `Bonjour ${ nom } ${ prenom } tu as ${ age } \u00e0 ${ ville } ` ) } //on peut aussi faire la destructuration en parametre function sayHello ({ nom , prenom , age , ville }) { console . log ( `Bonjour ${ nom } ${ prenom } tu as ${ age } \u00e0 ${ ville } ` ) } With Array const toto = [ 'un' , 'deux' , 'trois' ] // sans utiliser la d\u00e9composition const un = toto [ 0 ] const deux = toto [ 1 ] const trois = toto [ 2 ] // en utilisant la d\u00e9composition const [ un , deux , trois ] = toto With function const personne = { nom : 'john' , prenom : 'doe' , age : 25 , ville : 'paris' } const showPersonne = ({ nom , prenom , age , ville }) => { console . log ( `Bonjour ${ nom } ${ prenom } tu as ${ age } \u00e0 ${ ville } ` ) } showPersonne ( personne )","title":"Destructuring"},{"location":"pages/basis/es6/#shortlang","text":"const prenom = 'codeur' const age = 'bali' const ville = 'paris' // instead to do this: const personne = { prenom : prenom , age : age , ville : ville } // do: const personne = { prenom , age , ville }","title":"Shortlang"},{"location":"pages/basis/es6/#arrow-function","text":"Fonctions fl\u00e9ch\u00e9es - JavaScript | MDN ] //fonctions classiques function sayHello () { return 'hello' } function sayHelloName ( name ) { return 'hello ' + name } function somme ( a , b ) { return a + b } //fonctions fl\u00e9ch\u00e9es const sayHello = () => 'hello' const sayHelloName = name => 'hello ' + name const somme = ( a , b ) => a + b const somme = ( a , b ) => { let c = a + b return c }","title":"Arrow function"},{"location":"pages/basis/es6/#nullish-coalishing","text":"It allow to avoid js error with null or undefined data. Nullish coalescing operator Docs function sayHello ( name ) { let nameSafe = name ?? 'anonyme' return `Bonjour ${ nameSafe } ` } sayHello () // Bonjour anonyme sayHello ( null ) // Bonjour anonyme sayHello ( 'Mike' ) // Bonjour mike","title":"Nullish coalishing"},{"location":"pages/basis/es6/#optional-chaining","text":"Optional chaining Docs For using data in object we need to test them if it's not undefined : const countryCode = personne . adress . country . code //\u274c non null safe //Uncaught TypeError: Cannot read property 'country' of undefined // manage the null safe if ( personne && personne . adress && personne . adress . country ) { const countryCode = personne . adress . country . code } // or const countryCode = personne && personne . adress && personne . adress . country . code With ES6 we can use the optional chaining : const countryCode = personne ? . adress ? . country ? . code // return the data or null without error","title":"Optional chaining"},{"location":"pages/basis/es6/#ternal-operator","text":"L'op\u00e9rateur conditionnel Doc //m\u00e9thode classique function welcome ( isAdmin ) { if ( isAdmin ) { return 'Hello Admin' } else { return 'Hello Member' } } //\u00e9quivalent en ternaire function welcome ( isAdmin ) { return isAdmin ? 'Hello Admin' : 'Hello Member' }","title":"Ternal operator"},{"location":"pages/basis/es6/#array-methods-in-es6","text":"Array.prototype.every() - Docs const computers = [ { id : 'pc-1' , name : 'MacBook Pro' , features : [ 'usb-c' , 'screen-15' , 'batterie' , 'keyboard' , 'webcam' , 'ssd-1to' , ], }, { id : 'pc-2' , name : 'Lenovo' , features : [ 'usb-a' , 'screen-15' , 'batterie' , 'keyboard' , 'ssd-500go' ], }, { id : 'pc-3' , name : 'MSI' , features : [ 'usb-a' , 'screen-13' , 'batterie' , 'keyboard' , 'webcam' , 'ssd-500go' , ], }, ] Use with : map => array computers . map ( computer => 'Brand/' + computer . name ) // ['Brand/MacBook Pro', 'Brand/Lenovo', 'Brand/MSI'] `forEach`` => executes your code once for each array element computers . forEach ( computer => { console . log ( computer . name ) } ) // 'MacBook Pro' // 'Lenovo' // 'MSI' let computerListName = []; computers . forEach ( function ( item ){ computerListName . push ( item ); }); // computerListName = [ 'MacBook Pro', 'Lenovo', 'MSI' ] filter (with includes ) => array // output only computers with 'screen-15' feature computers . filter ( computer => computer . features . includes ( 'screen-15' )) // [{id: 'pc-1', ..etc}, {id: 'pc-2', ...}] some => boolean // test if there is any computer with ''ssd-2to' feature computers . some ( computer => computer . features . includes ( 'ssd-2to' )) // output false every => boolean // Test if every computer has feature like 'ssd-1to' or 'keyboard' computers . every ( computer => computer . features . includes ( 'ssd-1to' )) // output false computers . every ( computer => computer . features . includes ( 'keyboard' )) // output true find => first element that satisfies the provided testing function // Find every computer which are ''MacBook Pro' (it found one) computers . find ( computer => computer . name === 'MacBook Pro' ) // {id: 'pc-1', name: 'MacBook Pro', ...} reduce => value from the calculation on the preceding element The scheme is : array.reduce((accumulator, element) // Output every computer's features in any array with a spray operators computers . reduce (( allFeatures , computer ) => { return [... allFeatures , ... computer . features ] }, []) // output : // [ 'usb-c', 'screen-15', 'batterie', 'keyboard', 'webcam', 'ssd-1to', // 'usb-a', 'screen-15', 'batterie', 'keyboard', 'ssd-500go', 'usb-a', // 'screen-13', 'batterie', 'keyboard', 'webcam', 'ssd-500go' ]","title":"Array methods in ES6"},{"location":"pages/basis/es6/#exemple-with-filter-and-map","text":"Find every computer with webcam and output their names. const webCamPcName = computers . filter ( computer => computer . features . includes ( 'webcam' ) ) . map ( computer => computer . name ); console . log ( webCamPcName ); // [show MacBook Pro, MSI]","title":"Exemple with filter and map"},{"location":"pages/basis/es6/#rest-parameters","text":"Math . min ( 100 , 10 , 1 ) // retoune 1 const arr = [ 5 , 6 , 8 , 4 , 9 ] Math . min ( arr [ 0 ], arr [ 1 ], arr [ 2 ], arr [ 3 ], arr [ 4 ]) // Same thing with with Rest Math . min (... arr )","title":"Rest parameters"},{"location":"pages/basis/es6/#spread-operator","text":"// spread with object const personne = { nom : 'mike' , prenom : 'codeur' , adresse : 'bali' } const personne2 = {... personne , rue : 17 } // spread with array let numberStore = [ 0 , 1 , 2 ]; let newNumber = 12 ; numberStore = [... numberStore , newNumber ];","title":"Spread operator"},{"location":"pages/basis/es6/#promise-async-await","text":"Promise - JavaScript | MDN Voir le cours plus \u00e9volu\u00e9 dans advanced async-await et callback Create the promise : //cr\u00e9ation d'un promise function simulationFetch ( duration = 0 ) { return new Promise (( resolve , reject ) => { setTimeout (() => { if ( duration > 400 ) { reject ( `KO Timeout` ) } else { resolve ( `OK` ) } }, duration ) }) } Use the promise simulationFetch ( 100 ). then ( callBackOK , callBakcError ) simulationFetch ( 100 ). then ( e => console . log ( e ), err => console . error ( err ), ) // OK simulationFetch ( 500 ). then ( e => console . log ( e ), err => console . error ( err ), ) // KO Use the promise with async/await async function simulationFetchAsyncSuccess () { const result = await simulationFetch ( 200 ) return `success: ${ result } ` } async function simulationFetchAsyncFailed () { const result = await simulationFetch ( 500 ) return `failed: ${ result } ` // ne devrait pas etre execut\u00e9 } async function simulationFetchAsyncCatch () { let result try { result = await simulationFetch ( 500 , true ) return `failed: ${ result } ` // this would not be executed } catch ( error ) { return `failed and recovered: ${ error } ` } }","title":"Promise Async Await"},{"location":"pages/basis/events/","text":"Events in js onclick <! DOCTYPE html > < html > < body > < div id = \"root\" > < h1 id = \"title\" > Pas d 'information</h1> <button onclick=\"handleClick()\">Click me</button> </div> <script> function handleClick() { var date = new Date().toLocaleDateString() var time = new Date().toLocaleTimeString() var label = ' Nous sommes le ' + date + ' il est ' + time document.getElementById(' title ' ). innerText = label } < /script> < /body> < /html> onmouseenter and onmouseleave <! DOCTYPE html > < html > < body > < div id = \"root\" > < h1 id = \"title\" onmouseover = \"handleClick()\" > Pas d 'information</h1> <button onclick=\"handleClick()\" onmouseover=\"handleClick()\"> Click me </button> <div style=\"background-color: lightblue\" onmouseenter=\"handleClick()\"> entre ici </div> <div style=\"background-color: lightcoral\" onmouseleave=\"handleClick()\"> sort d' ici < /div> < /div> < script > function handleClick () { var date = new Date (). toLocaleDateString () var time = new Date (). toLocaleTimeString () var label = 'Nous sommes le ' + date + ' il est ' + time document . getElementById ( 'title' ). innerText = label } < /script> < /body> < /html> addEventListener with keydown Le lien vers la doc HTML DOM Document addEventListener() Method <! DOCTYPE html > < html > < body > < div id = \"root\" > < h1 id = \"title\" onmouseover = \"handleClick()\" > Pas d 'information</h1> <button onclick=\"document.removeEventListener(' keydown ',handlePress)\"> supprime le listener </button> <div style=\"background-color: lightblue\" onmouseenter=\"handleClick()\"> entre ici </div> <div style=\"background-color: lightcoral\" onmouseleave=\"handleClick()\"> sort d' ici < /div> < /div> < script > function handleClick () { var date = new Date (). toLocaleDateString () var time = new Date (). toLocaleTimeString () var label = 'Nous sommes le ' + date + ' il est ' + time document . getElementById ( 'title' ). innerText = label } function handlePress ( event ) { var name = event . key var code = event . code console . log ( 'name ' + name + ' : code ' + code ) if ( code === 'Enter' || code === 'ArrowDown ' || code === 'ArrowUp' ) { handleClick () } } //add keydown Listener document . addEventListener ( 'keydown' , handlePress ) < /script> < /body> < /html>","title":"Events in js"},{"location":"pages/basis/events/#events-in-js","text":"onclick <! DOCTYPE html > < html > < body > < div id = \"root\" > < h1 id = \"title\" > Pas d 'information</h1> <button onclick=\"handleClick()\">Click me</button> </div> <script> function handleClick() { var date = new Date().toLocaleDateString() var time = new Date().toLocaleTimeString() var label = ' Nous sommes le ' + date + ' il est ' + time document.getElementById(' title ' ). innerText = label } < /script> < /body> < /html> onmouseenter and onmouseleave <! DOCTYPE html > < html > < body > < div id = \"root\" > < h1 id = \"title\" onmouseover = \"handleClick()\" > Pas d 'information</h1> <button onclick=\"handleClick()\" onmouseover=\"handleClick()\"> Click me </button> <div style=\"background-color: lightblue\" onmouseenter=\"handleClick()\"> entre ici </div> <div style=\"background-color: lightcoral\" onmouseleave=\"handleClick()\"> sort d' ici < /div> < /div> < script > function handleClick () { var date = new Date (). toLocaleDateString () var time = new Date (). toLocaleTimeString () var label = 'Nous sommes le ' + date + ' il est ' + time document . getElementById ( 'title' ). innerText = label } < /script> < /body> < /html> addEventListener with keydown Le lien vers la doc HTML DOM Document addEventListener() Method <! DOCTYPE html > < html > < body > < div id = \"root\" > < h1 id = \"title\" onmouseover = \"handleClick()\" > Pas d 'information</h1> <button onclick=\"document.removeEventListener(' keydown ',handlePress)\"> supprime le listener </button> <div style=\"background-color: lightblue\" onmouseenter=\"handleClick()\"> entre ici </div> <div style=\"background-color: lightcoral\" onmouseleave=\"handleClick()\"> sort d' ici < /div> < /div> < script > function handleClick () { var date = new Date (). toLocaleDateString () var time = new Date (). toLocaleTimeString () var label = 'Nous sommes le ' + date + ' il est ' + time document . getElementById ( 'title' ). innerText = label } function handlePress ( event ) { var name = event . key var code = event . code console . log ( 'name ' + name + ' : code ' + code ) if ( code === 'Enter' || code === 'ArrowDown ' || code === 'ArrowUp' ) { handleClick () } } //add keydown Listener document . addEventListener ( 'keydown' , handlePress ) < /script> < /body> < /html>","title":"Events in js"},{"location":"pages/basis/html/","text":"Modern HTML5 Client-side form validation Doc Mozilla sur la validation HTML HTML Tag validation Use tag validation (type, min, max ...) with required if data is required. < input type = 'username' name = \"username\" min = \"2\" , max = \"12\" required > Use it for data-validation in form : Input form with js Use form with javascript for trigger input element. < form onsubmit = \"myFunction()\" > Enter name : < input type = \"text\" name = \"fname\" > </ form > SEO Open Graph (for social) in meta use OG meta for your social media SEO < html xmlns:og = \"http://ogp.me/ns#\" > < head > < title > Open Graph : pourquoi utiliser les balises OGP ? </ title > < meta property = \"og:title\" content = \"Article sur l'Open Graph par Referenseo\" /> < meta property = \"og:type\" content = \"article\" /> < meta property = \"og:url\" content = \"http://www.yakaferci.com/open-graph/\" /> < meta property = \"og:image\" content = \"http://referenseo/images/open-graph.jpg\" /> < meta property = \"og:site_name\" content = \"Agence de r\u00e9f\u00e9rencement Referenseo\" /> </ head > </ html > Link to OG Semantic use Semantic HTML5 element instead of div. Performance Content visibility Le content visibility increase your css performance loading ! Toutes les info sur le content visibility ici Async / Defer Instead to put script below body for HTML loading, use async or defer Web component Shadow DOM","title":"Modern HTML5"},{"location":"pages/basis/html/#modern-html5","text":"","title":"Modern HTML5"},{"location":"pages/basis/html/#client-side-form-validation","text":"Doc Mozilla sur la validation HTML","title":"Client-side form validation"},{"location":"pages/basis/html/#html-tag-validation","text":"Use tag validation (type, min, max ...) with required if data is required. < input type = 'username' name = \"username\" min = \"2\" , max = \"12\" required > Use it for data-validation in form :","title":"HTML Tag validation"},{"location":"pages/basis/html/#input-form-with-js","text":"Use form with javascript for trigger input element. < form onsubmit = \"myFunction()\" > Enter name : < input type = \"text\" name = \"fname\" > </ form >","title":"Input form with js"},{"location":"pages/basis/html/#seo","text":"","title":"SEO"},{"location":"pages/basis/html/#open-graph-for-social-in-meta","text":"use OG meta for your social media SEO < html xmlns:og = \"http://ogp.me/ns#\" > < head > < title > Open Graph : pourquoi utiliser les balises OGP ? </ title > < meta property = \"og:title\" content = \"Article sur l'Open Graph par Referenseo\" /> < meta property = \"og:type\" content = \"article\" /> < meta property = \"og:url\" content = \"http://www.yakaferci.com/open-graph/\" /> < meta property = \"og:image\" content = \"http://referenseo/images/open-graph.jpg\" /> < meta property = \"og:site_name\" content = \"Agence de r\u00e9f\u00e9rencement Referenseo\" /> </ head > </ html > Link to OG","title":"Open Graph (for social) in meta"},{"location":"pages/basis/html/#semantic","text":"use Semantic HTML5 element instead of div.","title":"Semantic"},{"location":"pages/basis/html/#performance","text":"","title":"Performance"},{"location":"pages/basis/html/#content-visibility","text":"Le content visibility increase your css performance loading ! Toutes les info sur le content visibility ici","title":"Content visibility"},{"location":"pages/basis/html/#async-defer","text":"Instead to put script below body for HTML loading, use async or defer","title":"Async / Defer"},{"location":"pages/basis/html/#web-component","text":"","title":"Web component"},{"location":"pages/basis/html/#shadow-dom","text":"","title":"Shadow DOM"},{"location":"pages/basis/css/","tags":["web","basis","CSS","css"],"text":"toto coco tptp","title":"CSS"},{"location":"pages/basis/css/#toto","text":"","title":"toto"},{"location":"pages/basis/css/#coco","text":"tptp","title":"coco"},{"location":"pages/basis/css/css-units/","text":"CSS Units px (absolute) Pretty self explanatory absolute lenght in pixel Info Avoid using pixel for font-sizes. Use mostly for small details like border and shadow . Fixed in size Not responsive Overrides user's browser preference % (relative) Relative to the value of parent element. 100% is the width of the parent element Info I recommend using percentages for layouts and width/height. For example, laying out links on navbar, placing images inside a div ... Size is defined as percentage of another value (mostly parent element) Sometimes size is defined as percentage of the element itself vw / vh (relative) Equal to 1% of the height or width of the browser window size vw stands for Viewport Width and represents a percentage of the width of the viewport. The number placed before vw is the percentage of the width of the viewport this length will be. For example if you wrote 10vw then this would represent a length of 10% of the width of your viewport. Important The viewport is just a fancy word for the size of your screen, so if you were on a large desktop with a width of 1920px, 10vw would represent 192px. If you were instead on a mobile phone with a width of 300px, then 10vw would only be 30px. vh stands for Viewport Height and is the exact same as vw but for the height instead of the width. These two units can be used in combination to easily make an element fill the entire size of the screen. . full-screen { width : 100 vw ; height : 100 vh ; } Info vh/vh are relative to the width/height of the browser window. 100vw means full width of the screen. Use vw/vh for bigger layouts, like background. Useful for responsive website because everything scales. em (relative) Relative to the font-size of the parent element. Info You can use em for font-size and margin/padding. Use em when you want to adjust margin/padding based on that element's font-size (if you font-sized is big, you maybe want bigger spacing) Changes behavior based on property 1 em = parent font-size if parent doesn't have a size, defaults to 16 px (body) rem (relative) Relative to the font-size of the root element Info You can also use rem for font-size and margin/padding. rem is easier to work than em because its more consistent. Relative to the root HTML, no matter what (default is 16px) You can change the root HTML size. For exemple if you change it to 20px, 1 rem will always 20 px. dvh / lvh / svh (relative) For mobile screen height","title":"CSS Units"},{"location":"pages/basis/css/css-units/#css-units","text":"","title":"CSS Units"},{"location":"pages/basis/css/css-units/#px-absolute","text":"Pretty self explanatory absolute lenght in pixel Info Avoid using pixel for font-sizes. Use mostly for small details like border and shadow . Fixed in size Not responsive Overrides user's browser preference","title":"px (absolute)"},{"location":"pages/basis/css/css-units/#relative","text":"Relative to the value of parent element. 100% is the width of the parent element Info I recommend using percentages for layouts and width/height. For example, laying out links on navbar, placing images inside a div ... Size is defined as percentage of another value (mostly parent element) Sometimes size is defined as percentage of the element itself","title":"% (relative)"},{"location":"pages/basis/css/css-units/#vw-vh-relative","text":"Equal to 1% of the height or width of the browser window size vw stands for Viewport Width and represents a percentage of the width of the viewport. The number placed before vw is the percentage of the width of the viewport this length will be. For example if you wrote 10vw then this would represent a length of 10% of the width of your viewport. Important The viewport is just a fancy word for the size of your screen, so if you were on a large desktop with a width of 1920px, 10vw would represent 192px. If you were instead on a mobile phone with a width of 300px, then 10vw would only be 30px. vh stands for Viewport Height and is the exact same as vw but for the height instead of the width. These two units can be used in combination to easily make an element fill the entire size of the screen. . full-screen { width : 100 vw ; height : 100 vh ; } Info vh/vh are relative to the width/height of the browser window. 100vw means full width of the screen. Use vw/vh for bigger layouts, like background. Useful for responsive website because everything scales.","title":"vw / vh (relative)"},{"location":"pages/basis/css/css-units/#em-relative","text":"Relative to the font-size of the parent element. Info You can use em for font-size and margin/padding. Use em when you want to adjust margin/padding based on that element's font-size (if you font-sized is big, you maybe want bigger spacing) Changes behavior based on property 1 em = parent font-size if parent doesn't have a size, defaults to 16 px (body)","title":"em (relative)"},{"location":"pages/basis/css/css-units/#rem-relative","text":"Relative to the font-size of the root element Info You can also use rem for font-size and margin/padding. rem is easier to work than em because its more consistent. Relative to the root HTML, no matter what (default is 16px) You can change the root HTML size. For exemple if you change it to 20px, 1 rem will always 20 px.","title":"rem (relative)"},{"location":"pages/basis/css/css-units/#dvh-lvh-svh-relative","text":"For mobile screen height","title":"dvh / lvh / svh (relative)"},{"location":"pages/basis/css/fundamentals/","text":"The fundamentals in CSS CSS Calculation CSS Calc function div { width : calc ( 100 % + 50 px ); } div { width : calc ( 100 % * 2 ); } CSS Variables for unit variable (size, width...) : root { --unit : 16 px ; } header { padding : var ( --unit ); } h1 { margin-bottom : var ( --unit ); } for color variable : root { --primary-color : #333 ; } div { background-color : var ( --primary-color ); } . test { color : var ( --primarycolor ); }","title":"The fundamentals in CSS"},{"location":"pages/basis/css/fundamentals/#the-fundamentals-in-css","text":"","title":"The fundamentals in CSS"},{"location":"pages/basis/css/fundamentals/#css-calculation","text":"CSS Calc function div { width : calc ( 100 % + 50 px ); } div { width : calc ( 100 % * 2 ); }","title":"CSS Calculation"},{"location":"pages/basis/css/fundamentals/#css-variables","text":"","title":"CSS Variables"},{"location":"pages/basis/css/fundamentals/#for-unit-variable-size-width","text":": root { --unit : 16 px ; } header { padding : var ( --unit ); } h1 { margin-bottom : var ( --unit ); }","title":"for unit variable (size, width...)"},{"location":"pages/basis/css/fundamentals/#for-color-variable","text":": root { --primary-color : #333 ; } div { background-color : var ( --primary-color ); } . test { color : var ( --primarycolor ); }","title":"for color variable"},{"location":"pages/basis/css/references/","text":"Links for CSS bases CSS Selector A Complete Guide to Flexbox | CSS-Tricks - CSS-Tricks A Complete Guide to Grid | CSS-Tricks - CSS-Tricks","title":"References"},{"location":"pages/basis/css/references/#links-for-css-bases","text":"CSS Selector A Complete Guide to Flexbox | CSS-Tricks - CSS-Tricks A Complete Guide to Grid | CSS-Tricks - CSS-Tricks","title":"Links for CSS bases"},{"location":"pages/basis/javascript/","tags":["web","basis","JS","javascript"],"text":"","title":"Javascript"},{"location":"pages/basis/javascript/js-basics/","text":"Javascript basics html DOM creation create HTML elements and element content < script > document . getElementById ( 'title' ). innerHTML = 'Welcome!' //h2 var newH2 = document . createElement ( 'h2' ) newH2 . innerHTML = 'Introduction' //add h2 to root var rootDiv = document . getElementById ( 'root' ) rootDiv . appendChild ( newH2 ) //add p to root var newP = document . createElement ( 'p' ) newP . innerHTML = 'Ceci est un paragraphe' rootDiv . appendChild ( newP ) //add footer to root var newFooter = document . createElement ( 'footer' ) newFooter . innerHTML = 'Site cr\u00e9\u00e9 par ..' rootDiv . appendChild ( newFooter ) < /script> Create attributes <! DOCTYPE html > < html > < body > < div id = \"root\" > < h1 id = \"title\" > Hello World < /h1> < /div> < script > var rootDiv = document . getElementById ( 'root' ) var styleAttr = document . createAttribute ( 'style' ) styleAttr . value = 'background-color:powderblue;' rootDiv . setAttributeNode ( styleAttr ) < /script> < /body> < /html> for loop in array * var langageList = [ 'html' , 'css' , 'js' ] for ( var i = 0 ; i < langageList . length ; i ++ ) { console . log ( langageList [ i ]) } *we use ES6 functionnal programming now with map, find, filter ... Splice for array // remove last element in array langageList . splice ( langageList . length - 1 ) [Mozilla splice Docs]( JavaScript Array splice() Method Object Docs JavaScript Objects Docs for...in - JavaScript Docs for ( var key in personne ) { console . log ( key ) } include test an array inside object var personne = { nom : 'Chirac' , langages : [ 'html' , 'css' , 'js' ], } if ( personne . langages . includes ( 'js' )) { console . log ( 'condition langages est ok' ) } else { console . error ( 'condition langages est ko' ) } Array Methods in JavaScript JavaScript gives us four methods to add or remove items from the beginning or end of arrays: pop() : Remove an item from the end of an array let cats = [ 'Bob' , 'Willy' , 'Mini' ]; cats . pop (); // ['Bob', 'Willy'] pop() returns the removed item. push() : Add items to the end of an array let cats = [ 'Bob' ]; cats . push ( 'Willy' ); // ['Bob', 'Willy'] cats . push ( 'Puff' , 'George' ); // ['Bob', 'Willy', 'Puff', 'George'] push() returns the new array length. shift() : Remove an item from the beginning of an array let cats = [ 'Bob' , 'Willy' , 'Mini' ]; cats . shift (); // ['Willy', 'Mini'] shift() returns the removed item. unshift() : Add items to the beginning of an array let cats = [ 'Bob' ]; cats . unshift ( 'Willy' ); // ['Willy', 'Bob'] cats . unshift ( 'Puff' , 'George' ); // ['Puff', 'George', 'Willy', 'Bob'] unshift() returns the new array length.","title":"Javascript basics"},{"location":"pages/basis/javascript/js-basics/#javascript-basics","text":"","title":"Javascript basics"},{"location":"pages/basis/javascript/js-basics/#html-dom-creation","text":"create HTML elements and element content < script > document . getElementById ( 'title' ). innerHTML = 'Welcome!' //h2 var newH2 = document . createElement ( 'h2' ) newH2 . innerHTML = 'Introduction' //add h2 to root var rootDiv = document . getElementById ( 'root' ) rootDiv . appendChild ( newH2 ) //add p to root var newP = document . createElement ( 'p' ) newP . innerHTML = 'Ceci est un paragraphe' rootDiv . appendChild ( newP ) //add footer to root var newFooter = document . createElement ( 'footer' ) newFooter . innerHTML = 'Site cr\u00e9\u00e9 par ..' rootDiv . appendChild ( newFooter ) < /script> Create attributes <! DOCTYPE html > < html > < body > < div id = \"root\" > < h1 id = \"title\" > Hello World < /h1> < /div> < script > var rootDiv = document . getElementById ( 'root' ) var styleAttr = document . createAttribute ( 'style' ) styleAttr . value = 'background-color:powderblue;' rootDiv . setAttributeNode ( styleAttr ) < /script> < /body> < /html>","title":"html DOM creation"},{"location":"pages/basis/javascript/js-basics/#for-loop-in-array","text":"var langageList = [ 'html' , 'css' , 'js' ] for ( var i = 0 ; i < langageList . length ; i ++ ) { console . log ( langageList [ i ]) } *we use ES6 functionnal programming now with map, find, filter ...","title":"for loop in array*"},{"location":"pages/basis/javascript/js-basics/#splice-for-array","text":"// remove last element in array langageList . splice ( langageList . length - 1 ) [Mozilla splice Docs]( JavaScript Array splice() Method","title":"Splice for array"},{"location":"pages/basis/javascript/js-basics/#object-docs","text":"JavaScript Objects Docs for...in - JavaScript Docs for ( var key in personne ) { console . log ( key ) }","title":"Object Docs"},{"location":"pages/basis/javascript/js-basics/#include-test-an-array-inside-object","text":"var personne = { nom : 'Chirac' , langages : [ 'html' , 'css' , 'js' ], } if ( personne . langages . includes ( 'js' )) { console . log ( 'condition langages est ok' ) } else { console . error ( 'condition langages est ko' ) }","title":"include test an array inside object"},{"location":"pages/basis/javascript/js-basics/#array-methods-in-javascript","text":"JavaScript gives us four methods to add or remove items from the beginning or end of arrays:","title":"Array Methods in JavaScript"},{"location":"pages/basis/javascript/js-basics/#pop-remove-an-item-from-the-end-of-an-array","text":"let cats = [ 'Bob' , 'Willy' , 'Mini' ]; cats . pop (); // ['Bob', 'Willy'] pop() returns the removed item.","title":"pop(): Remove an item from the end of an array"},{"location":"pages/basis/javascript/js-basics/#push-add-items-to-the-end-of-an-array","text":"let cats = [ 'Bob' ]; cats . push ( 'Willy' ); // ['Bob', 'Willy'] cats . push ( 'Puff' , 'George' ); // ['Bob', 'Willy', 'Puff', 'George'] push() returns the new array length.","title":"push(): Add items to the end of an array"},{"location":"pages/basis/javascript/js-basics/#shift-remove-an-item-from-the-beginning-of-an-array","text":"let cats = [ 'Bob' , 'Willy' , 'Mini' ]; cats . shift (); // ['Willy', 'Mini'] shift() returns the removed item.","title":"shift(): Remove an item from the beginning of an array"},{"location":"pages/basis/javascript/js-basics/#unshift-add-items-to-the-beginning-of-an-array","text":"let cats = [ 'Bob' ]; cats . unshift ( 'Willy' ); // ['Willy', 'Bob'] cats . unshift ( 'Puff' , 'George' ); // ['Puff', 'George', 'Willy', 'Bob'] unshift() returns the new array length.","title":"unshift(): Add items to the beginning of an array"},{"location":"pages/basis/javascript/js-loop/","text":"Initial data let list = [ 4 , 5 , 6 ]; 'for in' iterate on keys for ( let i in list ) { console . log ( i ); // Output: 0, 1, 2, console . log ( list [ i ]); // Output: 4, 5, 6 } 'for of' iterate on values for ( let i of list ) { console . log ( i ); // output: \"4\", \"5\", \"6\" } 'forEach' iterate on values with a callback list . forEach ( ( id ) => { console . log ( id ); // Output: \"4\", \"5\", \"6\" }) Alert Bonus with promise ! difference between for..of AND forEach / map / for Promise with for..of Ouput the user ID with 1000 ms delay one per one // Create the promise with timeout const getUserID = ( id ) => { return new Promise ( ( resolve ) => { setTimeout (() => { console . log ( `Got user ID ${ id } ` ); resolve ( id ); }, 1000 ); }) } ( async function () { const users = [ 30 , 20 , 10 , 5 , 1 ]; for ( const user of users ) { await getUserID ( user ) } })() // output at 1000 ms frequence one per one the users (5 x 1000 ms): // 'Got user ID 30' >1000 ms // 'Got user ID 20' >1000 ms // 'Got user ID 10' >1000 ms // 'Got user ID 5' >1000 ms // 'Got user ID 1' >1000 ms Promise with forEach , map or for // with forEach, map, for, it run in parrallels users . forEach ( async ( user ) => { await getUserID ( user ) }) // output with 1000 ms delay All the users in one time:","title":"Js loop"},{"location":"pages/basis/javascript/js-loop/#initial-data","text":"let list = [ 4 , 5 , 6 ];","title":"Initial data"},{"location":"pages/basis/javascript/js-loop/#for-in-iterate-on-keys","text":"for ( let i in list ) { console . log ( i ); // Output: 0, 1, 2, console . log ( list [ i ]); // Output: 4, 5, 6 }","title":"'for in' iterate on keys"},{"location":"pages/basis/javascript/js-loop/#for-of-iterate-on-values","text":"for ( let i of list ) { console . log ( i ); // output: \"4\", \"5\", \"6\" }","title":"'for of' iterate on values"},{"location":"pages/basis/javascript/js-loop/#foreach-iterate-on-values-with-a-callback","text":"list . forEach ( ( id ) => { console . log ( id ); // Output: \"4\", \"5\", \"6\" }) Alert Bonus with promise ! difference between for..of AND forEach / map / for","title":"'forEach' iterate on values with a callback"},{"location":"pages/basis/javascript/js-loop/#promise-with-forof","text":"Ouput the user ID with 1000 ms delay one per one // Create the promise with timeout const getUserID = ( id ) => { return new Promise ( ( resolve ) => { setTimeout (() => { console . log ( `Got user ID ${ id } ` ); resolve ( id ); }, 1000 ); }) } ( async function () { const users = [ 30 , 20 , 10 , 5 , 1 ]; for ( const user of users ) { await getUserID ( user ) } })() // output at 1000 ms frequence one per one the users (5 x 1000 ms): // 'Got user ID 30' >1000 ms // 'Got user ID 20' >1000 ms // 'Got user ID 10' >1000 ms // 'Got user ID 5' >1000 ms // 'Got user ID 1' >1000 ms","title":"Promise with for..of"},{"location":"pages/basis/javascript/js-loop/#promise-with-foreach-map-or-for","text":"// with forEach, map, for, it run in parrallels users . forEach ( async ( user ) => { await getUserID ( user ) }) // output with 1000 ms delay All the users in one time:","title":"Promise with forEach, map or for"},{"location":"pages/react/","tags":["react"],"text":"","title":"ReactJS"},{"location":"pages/react/react-fetching/","text":"Fetching in react 1) Fetch-On-Render : UseEffect with useFetch hook (contained data, isLoading, error states) with an Abort controller (See Ryan Florence tip: doc in progress). ISSUE : it doesn't start fetching until after the component was render on screen -> Lead problem to waterfall loading (component wait the previous, one per one) 2) Fetch-Then-Render : with Relay, React-query, Swr, Redux RTK Query : kick off Fetching early as possible (put fetch hook from parent) ISSUE : it solve waterfall but all component render wait that all was fetched 3) Render-As-You-Fetch : With Concurrent/Suspense (react 17-18.1). NO MORE ISSUE: Here we dont wait to the response to come back before we start rendering. But it need to work with React 18 new render. 4) React Router 6.4 (doc in progress) : combine concurrent/Suspense and Remix Router 5) Use SWR with concurrent/suspense actived (react 18). Exemple - samselikoff 6) React Concurrent Futur (>18.1) : combine 3 (Render-As-You-Fetch) with react-fetch : What changes are planned for Suspense in React 18 ? / The Journey of SWR and Suspense \u00b7 GitHub / Example with the new react-fetch/suspence react-fetch is experimental, in progress, not ready for prod 2) 'Fetch-Then-Render' with legacy mode Create Fetch functions : fetchUser , FetchPosts ... which return a fetch Promise const fetchUser = () => { console . log ( 'Fetching user' ); return fetch ( 'your-url-user-fetch' ) . then ( response => response . json ()) . then ( data => data ) . catch ( error => console . error ( error )) } Create a Wrap Promise function : const wrapPromise = ( promise ) => { // promise is the fetch return let status = 'pending' ; let result ; // it execute the promise let suspender = promise . then ( response => { status = 'success' ; result = response ; }, error => { status = 'error' ; result = error ; } ); return { // return an object with read function read () { switch ( status ) { case 'pending' throw suspender ; // it run the fetch break ; case 'success' throw result ; // store the data break ; case 'error' throw result ; // return the error break ; default : throw new Error ( 'Forbidden call' ); } } } } Create a FetchData function which call fetchUser , FetchPosts functions in a const and return them wraped in the Wrap Promise function : export const fetchData = () => { const userPromise = fetchUser (); const postsPromise = fetchPosts (); return { user : wrapPromise ( userPromise ), posts : wrapPromise ( postsPromise ) } } Call the component in this way: const resource = fetchData (); export ProfilDetail = () => { const user = resource . user . read (); return < div > < p > username : { user . name } < /p> < p > usercity : { user . city } < /p> < /div> } From the app call the component: const App = () => ( < div > < React . Suspense fallback = { < h4 > Loading user ... < /h4>}> < ProfilDetail /> < /React.Suspense> < /div> ); Github project example 3) 'Fetch-Then-Render' with 'Suspend' GitHub - pmndrs/suspend-react: \ud83d\udea5 Async/await for React components import { Suspense } from 'react' import { suspend } from 'suspend-react' function Post ({ id , version }) { const data = suspend ( async () => { const res = await fetch ( `https://hacker-news.firebaseio.com/ ${ version } /item/ ${ id } .json` ) return await res . json () }, [ id , version ]) return ( < div > { data . title } by { data . by } < /div> ) } function App () { return ( < Suspense fallback = { < div > loading ... < /div>}> < Post id = { 1000 } version = \"v0\" /> < /Suspense> ) } suspend-react hackernews - CodeSandbox Revalidate Live Queries \u2013 No cache management, no manual refetches! - YouTube 5) Coding 'Fetch-Then-Render' with 'SWR' GitHub - vercel/swr: React Hooks for Data Fetching The Coin.jsx component : import useSWR from 'swr' ; const fetcher = (... args ) => fetch (... args ) . then (( response ) => response . json ()); export default function Coins () { const { data } = useSWR ( \"https://api2.binance.com/api/v3/ticker/24hr\" , fetcher , { suspence : true } ); return ( < div className = \"App\" > { data ? . map ( ( coin ) => { return < h1 > { coin . lastprice } < /h1> })} < /div> ); } The App.jsx : import Coins from './Coins' ; import { Suspense } from 'react' ; export default function App () { return ( < div className = 'App' > < h1 > Coin List < /h1> < Suspense fallback = { < h1 > Loading ... < /h1>}> < Coins /> < /Suspense> < /div> ); } swr/examples at main \u00b7 GitHub Adding error-boundary Use react-error-boundary to handle errors in React with 'react-error-boundary' import * as React from 'react' import ReactDOM from 'react-dom' import { ErrorBoundary } from 'react-error-boundary' function ErrorFallback ({ error }) { return ( < div role = \"alert\" > < p > Something went wrong :< /p> < pre style = {{ color : 'red' }} > { error . message } < /pre> < /div> ) } function Greeting ({ subject }) { return < div > Hello { subject . toUpperCase ()} < /div> } function Farewell ({ subject }) { return < div > Goodbye { subject . toUpperCase ()} < /div> } function App () { return ( < div > < ErrorBoundary FallbackComponent = { ErrorFallback } > < Greeting /> < Farewell /> < /ErrorBoundary> < /div> ) } Built-in with React error boundaries React doc Create a component class error : class ErrorBoundary extends React . Component { constructor ( props ) { super ( props ); this . state = { hasError : false }; } static getDerivedStateFromError ( error ) { // Update state so the next render will show the fallback UI. return { hasError : true }; } componentDidCatch ( error , errorInfo ) { // You can also log the error to an error reporting service logErrorToMyService ( error , errorInfo ); } render () { if ( this . state . hasError ) { // You can render any custom fallback UI return < h1 > Something went wrong . < /h1>; } return this . props . children ; } } then use it with : < ErrorBoundary > < MyWidget /> < /ErrorBoundary> Exemple Transition API React Transition official Doc Create the transition const [ isPending , startTransition ] = useTransition (); use it for exemple a fetching and setData : return ( <> < button disabled = { isPending } onClick = {() => { startTransition (() => { const nextUserId = getNextId ( resource . userId ); setResource ( fetchProfileData ( nextUserId )); }); }} > Next < /button> { isPending ? \" Loading...\" : null } < ProfilePage resource = { resource } /> < /> ); Try it on CodeSandbox Discussion more on Transition Another exemple code : const [ isPending , startTransition ] = useTransition (); function handleClick () { startTransition (() => { setTab ( 'comments' ); }); } < Suspense fallback = { < Spinner /> } > <!-- dim the content while update is being worked on --> < div style = {{ opacity : isPending ? 0.8 : 1 }} > { tab === 'photos' ? < Photos /> : < Comments /> } < /div> < /Suspense>","title":"Fetching in react"},{"location":"pages/react/react-fetching/#fetching-in-react","text":"1) Fetch-On-Render : UseEffect with useFetch hook (contained data, isLoading, error states) with an Abort controller (See Ryan Florence tip: doc in progress). ISSUE : it doesn't start fetching until after the component was render on screen -> Lead problem to waterfall loading (component wait the previous, one per one) 2) Fetch-Then-Render : with Relay, React-query, Swr, Redux RTK Query : kick off Fetching early as possible (put fetch hook from parent) ISSUE : it solve waterfall but all component render wait that all was fetched 3) Render-As-You-Fetch : With Concurrent/Suspense (react 17-18.1). NO MORE ISSUE: Here we dont wait to the response to come back before we start rendering. But it need to work with React 18 new render. 4) React Router 6.4 (doc in progress) : combine concurrent/Suspense and Remix Router 5) Use SWR with concurrent/suspense actived (react 18). Exemple - samselikoff 6) React Concurrent Futur (>18.1) : combine 3 (Render-As-You-Fetch) with react-fetch : What changes are planned for Suspense in React 18 ? / The Journey of SWR and Suspense \u00b7 GitHub / Example with the new react-fetch/suspence react-fetch is experimental, in progress, not ready for prod","title":"Fetching in react"},{"location":"pages/react/react-fetching/#2-fetch-then-render-with-legacy-mode","text":"Create Fetch functions : fetchUser , FetchPosts ... which return a fetch Promise const fetchUser = () => { console . log ( 'Fetching user' ); return fetch ( 'your-url-user-fetch' ) . then ( response => response . json ()) . then ( data => data ) . catch ( error => console . error ( error )) } Create a Wrap Promise function : const wrapPromise = ( promise ) => { // promise is the fetch return let status = 'pending' ; let result ; // it execute the promise let suspender = promise . then ( response => { status = 'success' ; result = response ; }, error => { status = 'error' ; result = error ; } ); return { // return an object with read function read () { switch ( status ) { case 'pending' throw suspender ; // it run the fetch break ; case 'success' throw result ; // store the data break ; case 'error' throw result ; // return the error break ; default : throw new Error ( 'Forbidden call' ); } } } } Create a FetchData function which call fetchUser , FetchPosts functions in a const and return them wraped in the Wrap Promise function : export const fetchData = () => { const userPromise = fetchUser (); const postsPromise = fetchPosts (); return { user : wrapPromise ( userPromise ), posts : wrapPromise ( postsPromise ) } } Call the component in this way: const resource = fetchData (); export ProfilDetail = () => { const user = resource . user . read (); return < div > < p > username : { user . name } < /p> < p > usercity : { user . city } < /p> < /div> } From the app call the component: const App = () => ( < div > < React . Suspense fallback = { < h4 > Loading user ... < /h4>}> < ProfilDetail /> < /React.Suspense> < /div> ); Github project example","title":"2) 'Fetch-Then-Render' with legacy mode"},{"location":"pages/react/react-fetching/#3-fetch-then-render-with-suspend","text":"GitHub - pmndrs/suspend-react: \ud83d\udea5 Async/await for React components import { Suspense } from 'react' import { suspend } from 'suspend-react' function Post ({ id , version }) { const data = suspend ( async () => { const res = await fetch ( `https://hacker-news.firebaseio.com/ ${ version } /item/ ${ id } .json` ) return await res . json () }, [ id , version ]) return ( < div > { data . title } by { data . by } < /div> ) } function App () { return ( < Suspense fallback = { < div > loading ... < /div>}> < Post id = { 1000 } version = \"v0\" /> < /Suspense> ) } suspend-react hackernews - CodeSandbox Revalidate Live Queries \u2013 No cache management, no manual refetches! - YouTube","title":"3) 'Fetch-Then-Render' with 'Suspend'"},{"location":"pages/react/react-fetching/#5-coding-fetch-then-render-with-swr","text":"GitHub - vercel/swr: React Hooks for Data Fetching The Coin.jsx component : import useSWR from 'swr' ; const fetcher = (... args ) => fetch (... args ) . then (( response ) => response . json ()); export default function Coins () { const { data } = useSWR ( \"https://api2.binance.com/api/v3/ticker/24hr\" , fetcher , { suspence : true } ); return ( < div className = \"App\" > { data ? . map ( ( coin ) => { return < h1 > { coin . lastprice } < /h1> })} < /div> ); } The App.jsx : import Coins from './Coins' ; import { Suspense } from 'react' ; export default function App () { return ( < div className = 'App' > < h1 > Coin List < /h1> < Suspense fallback = { < h1 > Loading ... < /h1>}> < Coins /> < /Suspense> < /div> ); } swr/examples at main \u00b7 GitHub","title":"5) Coding 'Fetch-Then-Render' with 'SWR'"},{"location":"pages/react/react-fetching/#adding-error-boundary","text":"Use react-error-boundary to handle errors in React","title":"Adding error-boundary"},{"location":"pages/react/react-fetching/#with-react-error-boundary","text":"import * as React from 'react' import ReactDOM from 'react-dom' import { ErrorBoundary } from 'react-error-boundary' function ErrorFallback ({ error }) { return ( < div role = \"alert\" > < p > Something went wrong :< /p> < pre style = {{ color : 'red' }} > { error . message } < /pre> < /div> ) } function Greeting ({ subject }) { return < div > Hello { subject . toUpperCase ()} < /div> } function Farewell ({ subject }) { return < div > Goodbye { subject . toUpperCase ()} < /div> } function App () { return ( < div > < ErrorBoundary FallbackComponent = { ErrorFallback } > < Greeting /> < Farewell /> < /ErrorBoundary> < /div> ) }","title":"with 'react-error-boundary'"},{"location":"pages/react/react-fetching/#built-in-with-react-error-boundaries","text":"React doc Create a component class error : class ErrorBoundary extends React . Component { constructor ( props ) { super ( props ); this . state = { hasError : false }; } static getDerivedStateFromError ( error ) { // Update state so the next render will show the fallback UI. return { hasError : true }; } componentDidCatch ( error , errorInfo ) { // You can also log the error to an error reporting service logErrorToMyService ( error , errorInfo ); } render () { if ( this . state . hasError ) { // You can render any custom fallback UI return < h1 > Something went wrong . < /h1>; } return this . props . children ; } } then use it with : < ErrorBoundary > < MyWidget /> < /ErrorBoundary> Exemple","title":"Built-in with React error boundaries"},{"location":"pages/react/react-fetching/#transition-api","text":"React Transition official Doc Create the transition const [ isPending , startTransition ] = useTransition (); use it for exemple a fetching and setData : return ( <> < button disabled = { isPending } onClick = {() => { startTransition (() => { const nextUserId = getNextId ( resource . userId ); setResource ( fetchProfileData ( nextUserId )); }); }} > Next < /button> { isPending ? \" Loading...\" : null } < ProfilePage resource = { resource } /> < /> ); Try it on CodeSandbox Discussion more on Transition Another exemple code : const [ isPending , startTransition ] = useTransition (); function handleClick () { startTransition (() => { setTab ( 'comments' ); }); } < Suspense fallback = { < Spinner /> } > <!-- dim the content while update is being worked on --> < div style = {{ opacity : isPending ? 0.8 : 1 }} > { tab === 'photos' ? < Photos /> : < Comments /> } < /div> < /Suspense>","title":"Transition API"},{"location":"pages/react/useRef-or-useState/","text":"useRef or useState Counter App to see useRef does not rerender If you create a simple counter app using useRef to store the state: import { useRef } from \"react\" ; const App = () => { const count = useRef ( 0 ); return ( < div > < h2 > count : { count . current } < /h2> < button onClick = {() => { count . current = count . current + 1 ; console . log ( count . current ); }} > increase count < /button> < /div> ); }; If you click on the button, <h2>count: {count.current}</h2> this value will not change because component is NOT RE-RENDERING. If you check the console console.log(count.current) , you will see that value is actually increasing but since the component is not rerendering, UI does not get updated. If you set the state with useState , clicking on the button would rerender the component so UI would get updated. Prevent the unnecessary re-renderings while typing into input . Rerendering is an expensive operation. In some cases you do not want to keep rerendering the app. For example, when you store the input value in state to create a controlled component. In this case for each keystroke you would rerender the app. If you use the ref to get a reference to the DOM element, with useState you would rerender the component only once: import { useState , useRef } from \"react\" ; const App = () => { const [ value , setValue ] = useState ( \"\" ); const valueRef = useRef (); const handleClick = () => { console . log ( valueRef ); setValue ( valueRef . current . value ); }; return ( < div > < h4 > Input Value : { value } < /h4> < input ref = { valueRef } /> < button onClick = { handleClick } > click < /button> < /div> ); }; Prevent the infinite loop inside useEffect to create a simple flipping animation, we need to 2 state values. one is a boolean value to flip or not in an interval, another one is to clear the subscription when we leave the component: const [ isFlipping , setIsFlipping ] = useState ( false ); let flipInterval = useRef < ReturnType < typeof setInterval >> (); useEffect (() => { startAnimation (); return () => flipInterval . current && clearInterval ( flipInterval . current ); }, []); const startAnimation = () => { flipInterval . current = setInterval (() => { setIsFlipping (( prevFlipping ) => ! prevFlipping ); }, 10000 ); }; setInterval returns an id and we pass it to clearInterval to end the subscription when we leave the component. flipInterval.current is either null or this id. If we did not use ref here, everytime we switched from null to id or from id to null, this component would rerender and this would create an infinite loop. If you do not need to update UI, use useRef to store state variables. Let's say in react native app, we set the sound for certain actions which have no effect on UI. For one state variable it might not be that much performance savings but If you play a game and you need to set different sound based on game status. const popSoundRef = useRef < Audio . Sound | null > ( null ); const pop2SoundRef = useRef < Audio . Sound | null > ( null ); const winSoundRef = useRef < Audio . Sound | null > ( null ); const lossSoundRef = useRef < Audio . Sound | null > ( null ); const drawSoundRef = useRef < Audio . Sound | null > ( null ); If I used useState , I would keep rerendering every time I change a state value.","title":"useRef or useState"},{"location":"pages/react/useRef-or-useState/#useref-or-usestate","text":"Counter App to see useRef does not rerender If you create a simple counter app using useRef to store the state: import { useRef } from \"react\" ; const App = () => { const count = useRef ( 0 ); return ( < div > < h2 > count : { count . current } < /h2> < button onClick = {() => { count . current = count . current + 1 ; console . log ( count . current ); }} > increase count < /button> < /div> ); }; If you click on the button, <h2>count: {count.current}</h2> this value will not change because component is NOT RE-RENDERING. If you check the console console.log(count.current) , you will see that value is actually increasing but since the component is not rerendering, UI does not get updated. If you set the state with useState , clicking on the button would rerender the component so UI would get updated. Prevent the unnecessary re-renderings while typing into input . Rerendering is an expensive operation. In some cases you do not want to keep rerendering the app. For example, when you store the input value in state to create a controlled component. In this case for each keystroke you would rerender the app. If you use the ref to get a reference to the DOM element, with useState you would rerender the component only once: import { useState , useRef } from \"react\" ; const App = () => { const [ value , setValue ] = useState ( \"\" ); const valueRef = useRef (); const handleClick = () => { console . log ( valueRef ); setValue ( valueRef . current . value ); }; return ( < div > < h4 > Input Value : { value } < /h4> < input ref = { valueRef } /> < button onClick = { handleClick } > click < /button> < /div> ); }; Prevent the infinite loop inside useEffect to create a simple flipping animation, we need to 2 state values. one is a boolean value to flip or not in an interval, another one is to clear the subscription when we leave the component: const [ isFlipping , setIsFlipping ] = useState ( false ); let flipInterval = useRef < ReturnType < typeof setInterval >> (); useEffect (() => { startAnimation (); return () => flipInterval . current && clearInterval ( flipInterval . current ); }, []); const startAnimation = () => { flipInterval . current = setInterval (() => { setIsFlipping (( prevFlipping ) => ! prevFlipping ); }, 10000 ); }; setInterval returns an id and we pass it to clearInterval to end the subscription when we leave the component. flipInterval.current is either null or this id. If we did not use ref here, everytime we switched from null to id or from id to null, this component would rerender and this would create an infinite loop. If you do not need to update UI, use useRef to store state variables. Let's say in react native app, we set the sound for certain actions which have no effect on UI. For one state variable it might not be that much performance savings but If you play a game and you need to set different sound based on game status. const popSoundRef = useRef < Audio . Sound | null > ( null ); const pop2SoundRef = useRef < Audio . Sound | null > ( null ); const winSoundRef = useRef < Audio . Sound | null > ( null ); const lossSoundRef = useRef < Audio . Sound | null > ( null ); const drawSoundRef = useRef < Audio . Sound | null > ( null ); If I used useState , I would keep rerendering every time I change a state value.","title":"useRef or useState"},{"location":"pages/react/typescript/","tags":["typescript","cheatsheets/react","react"],"text":"","title":"Typescript Cheatsheets ReactJS"},{"location":"pages/react/typescript/advanced/","text":"This Advanced Cheatsheet helps show and explain advanced usage of generic types for people writing reusable type utilities/functions/render prop/higher order components and TS+React libraries . It also has miscellaneous tips and tricks for pro users. Advice for contributing to DefinitelyTyped The goal is to take full advantage of TypeScript. Creating React + TypeScript Libraries The best tool for creating React + TS libraries right now is tsdx . Run npx tsdx create and select the \"react\" option. You can view the React User Guide for a few tips on React+TS library best practices and optimizations for production. Another option is Rollpkg , which uses Rollup and the TypeScript compiler (not Babel) to create packages. It includes default configs for TypeScript, Prettier, ESLint, and Jest (setup for use with React), as well as Bundlephobia package stats for each build. Be sure to also check basarat 's guide for library tsconfig settings. Alec Larson: The best Rollup config for TypeScript libraries From the Angular world, check out https://github.com/bitjson/typescript-starter","title":"Advanced Cheatsheet"},{"location":"pages/react/typescript/advanced/misc-concerns/","text":"Sometimes writing React isn't just about React. While we don't focus on other libraries like Redux (see below for more on that), here are some tips on other common concerns when making apps with React + TypeScript. Writing TypeScript Libraries instead of Apps propTypes may seem unnecessary with TypeScript, especially when building React + TypeScript apps , but they are still relevant when writing libraries which may be used by developers working in Javascript. interface MyComponentProps { autoHeight : boolean ; secondProp : number ; } export class MyComponent extends React . Component < MyComponentProps , {} > { static propTypes = { autoHeight : PropTypes.bool , secondProp : PropTypes.number.isRequired , }; } Something to add? File an issue . Commenting Components TypeScript uses TSDoc , a variant of JSDoc for TypeScript. This is very handy for writing component libraries and having useful descriptions pop up in autocomplete and other tooling (like the Docz PropsTable ). The main thing to remember is to use /** YOUR_COMMENT_HERE */ syntax in the line just above whatever you're annotating. interface MyComponentProps { /** Description of prop \"label\". * @default foobar * */ label? : string ; } /** * General component description in JSDoc format. Markdown is *supported*. */ export default function MyComponent ({ label = \"foobar\" } : MyComponentProps ) { return < div > Hello world { label } < /div>; } View in the TypeScript Playground Something to add? File an issue . Namespaced Components Often when creating similar components or components that have a parent-child relationship, it is useful to namespace your components. Types can easily be added be using Object.assign() ; import { forwardRef } from \"react\" ; const Input = ( props : any ) => < input {... props } /> ; const Form = forwardRef < HTMLDivElement , any > ( ({ children , ... otherProps }, ref ) => ( < form {... otherProps } ref = { ref } > { children } < /form> ) ); /** * Exported components now can be used as `<Form>` and `<Form.Input>` */ export default Object . assign ( Form , { Input : Input }); View in the TypeScript Playground (Contributed by @bryceosterhaus, see further discussion ) Something to add? File an issue . Design System Development I do like Docz which takes basically 1 line of config to accept TypeScript. However it is newer and has a few more rough edges (many breaking changes since it is still < v1.0) For developing with Storybook, read the docs I wrote over here: https://storybook.js.org/configurations/typescript-config/ . This includes automatic proptype documentation generation, which is awesome :) Something to add? File an issue . Migrating From Flow You should check out large projects that are migrating from flow to pick up concerns and tips: Jest Expo React-beautiful-dnd Storybook VueJS Useful libraries: https://github.com/bcherny/flow-to-typescript https://github.com/Khan/flow-to-ts https://github.com/piotrwitek/utility-types If you have specific advice in this area, please file a PR! Something to add? File an issue . Prettier There isn't any real secret to Prettier for TypeScript. But its a great idea to run prettier on every commit! $ yarn add -D prettier husky lint-staged // inside package.json { //... \"husky\" : { \"hooks\" : { \"pre-commit\" : \"lint-staged\" } }, \"lint-staged\" : { \"linters\" : { \"src/*.{ts,tsx,js,jsx,css,scss,md}\" : [ \"prettier --trailing-comma es5 --single-quote --write\" , \"git add\" ], \"ignore\" : [ \"**/dist/*, **/node_modules/*\" ] } }, \"prettier\" : { \"printWidth\" : 80 , \"semi\" : false , \"singleQuote\" : true , \"trailingComma\" : \"es5\" } } Integrating this with ESlint may be a problem. We haven't written much on this yet, please contribute if you have a strong opinion. Here's a helpful gist. For library authors, this is set up for you in tsdx . You may also wish to check out the newer https://ts-engine.dev/ project. Testing Yes, you can test your types! You shouldn't use it for EVERYTHING, but it can help prevent regressions: https://github.com/azz/jest-runner-tsc https://github.com/SamVerschueren/tsd https://github.com/ikatyang/dts-jest ( Demo ) https://github.com/microsoft/dtslint ( Intro to dtslint ) Working with Non-TypeScript Libraries (writing your own index.d.ts) Lets say you want to use de-indent , but it isn't typed or on DefinitelyTyped. You get an error like this: [ts] Could not find a declaration file for module 'de-indent'. '/Users/swyx/Work/react-sfc-loader/node_modules/de-indent/index.js' implicitly has an 'any' type. Try `npm install @types/de-indent` if it exists or add a new declaration (.d.ts) file containing `declare module 'de-indent';` [7016] So create a .d.ts file anywhere in your project with the module definition: // de-indent.d.ts declare module \"de-indent\" { function deindent () : void ; export = deindent ; // default export } Further Discussion Any other tips? Please contribute on this topic! [We have an ongoing issue here with some references](https://github.com/typescript-cheatsheets/react/issues/8). We have more discussion and examples [in our issue here](https://github.com/typescript-cheatsheets/react/issues/12). Compilation Speed Compiling large TS projects can get slow. Here are some tips: We have a dedicated repo tracking TS speed recommendations: https://github.com/typescript-cheatsheets/speed Use TS 3.0 Project references Check the official TS performance wiki guidelines - note that Dan Rossenwasser says to take it with a grain of salt Webpack ( see CRA diff ): set output.pathinfo = false set optimization.splitChunks , optimization.removeAvailableModules , optimization.removeEmptyChunks to false","title":"Misc. Concerns"},{"location":"pages/react/typescript/advanced/misc-concerns/#writing-typescript-libraries-instead-of-apps","text":"propTypes may seem unnecessary with TypeScript, especially when building React + TypeScript apps , but they are still relevant when writing libraries which may be used by developers working in Javascript. interface MyComponentProps { autoHeight : boolean ; secondProp : number ; } export class MyComponent extends React . Component < MyComponentProps , {} > { static propTypes = { autoHeight : PropTypes.bool , secondProp : PropTypes.number.isRequired , }; } Something to add? File an issue .","title":"Writing TypeScript Libraries instead of Apps"},{"location":"pages/react/typescript/advanced/misc-concerns/#commenting-components","text":"TypeScript uses TSDoc , a variant of JSDoc for TypeScript. This is very handy for writing component libraries and having useful descriptions pop up in autocomplete and other tooling (like the Docz PropsTable ). The main thing to remember is to use /** YOUR_COMMENT_HERE */ syntax in the line just above whatever you're annotating. interface MyComponentProps { /** Description of prop \"label\". * @default foobar * */ label? : string ; } /** * General component description in JSDoc format. Markdown is *supported*. */ export default function MyComponent ({ label = \"foobar\" } : MyComponentProps ) { return < div > Hello world { label } < /div>; } View in the TypeScript Playground Something to add? File an issue .","title":"Commenting Components"},{"location":"pages/react/typescript/advanced/misc-concerns/#namespaced-components","text":"Often when creating similar components or components that have a parent-child relationship, it is useful to namespace your components. Types can easily be added be using Object.assign() ; import { forwardRef } from \"react\" ; const Input = ( props : any ) => < input {... props } /> ; const Form = forwardRef < HTMLDivElement , any > ( ({ children , ... otherProps }, ref ) => ( < form {... otherProps } ref = { ref } > { children } < /form> ) ); /** * Exported components now can be used as `<Form>` and `<Form.Input>` */ export default Object . assign ( Form , { Input : Input }); View in the TypeScript Playground (Contributed by @bryceosterhaus, see further discussion ) Something to add? File an issue .","title":"Namespaced Components"},{"location":"pages/react/typescript/advanced/misc-concerns/#design-system-development","text":"I do like Docz which takes basically 1 line of config to accept TypeScript. However it is newer and has a few more rough edges (many breaking changes since it is still < v1.0) For developing with Storybook, read the docs I wrote over here: https://storybook.js.org/configurations/typescript-config/ . This includes automatic proptype documentation generation, which is awesome :) Something to add? File an issue .","title":"Design System Development"},{"location":"pages/react/typescript/advanced/misc-concerns/#migrating-from-flow","text":"You should check out large projects that are migrating from flow to pick up concerns and tips: Jest Expo React-beautiful-dnd Storybook VueJS Useful libraries: https://github.com/bcherny/flow-to-typescript https://github.com/Khan/flow-to-ts https://github.com/piotrwitek/utility-types If you have specific advice in this area, please file a PR! Something to add? File an issue .","title":"Migrating From Flow"},{"location":"pages/react/typescript/advanced/misc-concerns/#prettier","text":"There isn't any real secret to Prettier for TypeScript. But its a great idea to run prettier on every commit! $ yarn add -D prettier husky lint-staged // inside package.json { //... \"husky\" : { \"hooks\" : { \"pre-commit\" : \"lint-staged\" } }, \"lint-staged\" : { \"linters\" : { \"src/*.{ts,tsx,js,jsx,css,scss,md}\" : [ \"prettier --trailing-comma es5 --single-quote --write\" , \"git add\" ], \"ignore\" : [ \"**/dist/*, **/node_modules/*\" ] } }, \"prettier\" : { \"printWidth\" : 80 , \"semi\" : false , \"singleQuote\" : true , \"trailingComma\" : \"es5\" } } Integrating this with ESlint may be a problem. We haven't written much on this yet, please contribute if you have a strong opinion. Here's a helpful gist. For library authors, this is set up for you in tsdx . You may also wish to check out the newer https://ts-engine.dev/ project.","title":"Prettier"},{"location":"pages/react/typescript/advanced/misc-concerns/#testing","text":"Yes, you can test your types! You shouldn't use it for EVERYTHING, but it can help prevent regressions: https://github.com/azz/jest-runner-tsc https://github.com/SamVerschueren/tsd https://github.com/ikatyang/dts-jest ( Demo ) https://github.com/microsoft/dtslint ( Intro to dtslint )","title":"Testing"},{"location":"pages/react/typescript/advanced/misc-concerns/#working-with-non-typescript-libraries-writing-your-own-indexdts","text":"Lets say you want to use de-indent , but it isn't typed or on DefinitelyTyped. You get an error like this: [ts] Could not find a declaration file for module 'de-indent'. '/Users/swyx/Work/react-sfc-loader/node_modules/de-indent/index.js' implicitly has an 'any' type. Try `npm install @types/de-indent` if it exists or add a new declaration (.d.ts) file containing `declare module 'de-indent';` [7016] So create a .d.ts file anywhere in your project with the module definition: // de-indent.d.ts declare module \"de-indent\" { function deindent () : void ; export = deindent ; // default export } Further Discussion Any other tips? Please contribute on this topic! [We have an ongoing issue here with some references](https://github.com/typescript-cheatsheets/react/issues/8). We have more discussion and examples [in our issue here](https://github.com/typescript-cheatsheets/react/issues/12).","title":"Working with Non-TypeScript Libraries (writing your own index.d.ts)"},{"location":"pages/react/typescript/advanced/misc-concerns/#compilation-speed","text":"Compiling large TS projects can get slow. Here are some tips: We have a dedicated repo tracking TS speed recommendations: https://github.com/typescript-cheatsheets/speed Use TS 3.0 Project references Check the official TS performance wiki guidelines - note that Dan Rossenwasser says to take it with a grain of salt Webpack ( see CRA diff ): set output.pathinfo = false set optimization.splitChunks , optimization.removeAvailableModules , optimization.removeEmptyChunks to false","title":"Compilation Speed"},{"location":"pages/react/typescript/advanced/patterns_by_usecase/","text":"Wrapping/Mirroring Wrapping/Mirroring a HTML Element Usecase: you want to make a <Button> that takes all the normal props of <button> and does extra stuff. Strategy: extend React.ComponentPropsWithoutRef<'button'> // usage function App () { // Type '\"foo\"' is not assignable to type '\"button\" | \"submit\" | \"reset\" | undefined'.(2322) // return <Button type=\"foo\"> sldkj </Button> // no error return < Button type = \"button\" > text < /Button>; } // implementation export interface ButtonProps extends React . ComponentPropsWithoutRef < \"button\" > { specialProp? : string ; } export function Button ( props : ButtonProps ) { const { specialProp , ... rest } = props ; // do something with specialProp return < button {... rest } /> ; } See this in the TS Playground Forwarding Refs : As the React docs themselves note , most usecases will not need to obtain a ref to the inner element. But for people making reusable component libraries, you will need to forwardRef the underlying element, and then you can use ComponentPropsWithRef to grab props for your wrapper component. Check our docs on forwarding Refs for more. In future, the need to forwardRef may go away in React 17+, but for now we still have to deal with this. \ud83d\ude43 Why not `ComponentProps` or `IntrinsicElements` or `[Element]HTMLAttributes` or `HTMLProps` or `HTMLAttributes`? ## `ComponentProps` You CAN use `ComponentProps` in place of `ComponentPropsWithRef`, but you may prefer to be explicit about whether or not the component's refs are forwarded, which is what we have chosen to demonstrate. The tradeoff is slightly more intimidating terminology. More info: https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forward_and_create_ref/ ### Maybe `JSX.IntrinsicElements` or `[Element]HTMLAttributes` There are at least 2 other equivalent ways to do this, but they are more verbose: // Method 1: JSX.IntrinsicElements type BtnType = JSX . IntrinsicElements [ \"button\" ]; // cannot inline or will error export interface ButtonProps extends BtnType {} // etc // Method 2: React.[Element]HTMLAttributes export interface ButtonProps extends React . ButtonHTMLAttributes < HTMLButtonElement > Looking at [the source for `ComponentProps`](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/f3134f4897c8473f590cbcdd5788da8d59796f45/types/react/index.d.ts#L821) shows that this is a clever wrapper for `JSX.IntrinsicElements`, whereas the second method relies on specialized interfaces with unfamiliar naming/capitalization. > Note: There are over 50 of these specialized interfaces available - look for `HTMLAttributes` in our [`@types/react` commentary](https://react-typescript-cheatsheet.netlify.app/docs/advanced/types_react_api#typesreact). Ultimately, [we picked the `ComponentProps` method](https://github.com/typescript-cheatsheets/react/pull/276) as it involves the least TS specific jargon and has the most ease of use. But you'll be fine with either of these methods if you prefer. ### Definitely not `React.HTMLProps` or `React.HTMLAttributes` This is what happens when you use `React.HTMLProps`: export interface ButtonProps extends React . HTMLProps < HTMLButtonElement > { specialProp : string ; } export function Button ( props : ButtonProps ) { const { specialProp , ... rest } = props ; // ERROR: Type 'string' is not assignable to type '\"button\" | \"submit\" | \"reset\" | undefined'. return < button {... rest } /> ; } It infers a too-wide type of `string` for `type`, because it [uses `AllHTMLAttributes` under the hood](https://github.com/typescript-cheatsheets/react/issues/128#issuecomment-508103558). This is what happens when you use `React.HTMLAttributes`: import { HTMLAttributes } from \"react\" ; export interface ButtonProps extends HTMLAttributes < HTMLButtonElement > { /* etc */ } function App () { // Property 'type' does not exist on type 'IntrinsicAttributes & ButtonProps' return < Button type = \"submit\" > text < /Button>; } Wrapping/Mirroring a Component TODO: this section needs work to make it simplified. Usecase: same as above, but for a React Component you don't have access to the underlying props import { CSSProperties } from \"react\" ; const Box = ( props : CSSProperties ) => < div style = { props } /> ; const Card = ( { title , children , ... props } : { title : string } & $ElementProps < typeof Box > // new utility, see below ) => ( < Box {... props } > { title } : { children } < /Box> ); Strategy: extract a component's props by inferring them Example: // ReactUtilityTypes.d.ts declare type $ElementProps < T > = T extends React . ComponentType < infer Props > ? Props extends object ? Props : never : never ; Usage: import * as Recompose from \"recompose\" ; export const defaultProps = < C extends React . ComponentType , D extends Partial < $ElementProps < C >> > ( defaults : D , Component : C ) : React . ComponentType < $ElementProps < C > & Partial < D >> => Recompose . defaultProps ( defaults )( Component ); thanks dmisdm You should also consider whether to explicitly forward refs: import { forwardRef , ReactNode } from \"react\" ; // base button, with ref forwarding type Props = { children : ReactNode ; type : \"submit\" | \"button\" }; export type Ref = HTMLButtonElement ; export const FancyButton = forwardRef < Ref , Props > (( props , ref ) => ( < button ref = { ref } className = \"MyCustomButtonClass\" type = { props . type } > { props . children } < /button> )); // second layer button, no need for forwardRef (TODO: doublecheck this) export interface DoubleWrappedProps extends React . ComponentPropsWithRef < typeof FancyButton > { specialProp? : string ; } export function DoubleWrappedButton ( props : DoubleWrappedProps ) { const { specialProp , ref , ... rest } = props ; return < button ref = { ref } {... rest } /> ; } // usage import { useRef } from \"react\" ; function App () { const btnRef = useRef < HTMLButtonElement > ( null ! ); return ( < DoubleWrappedButton type = \"button\" ref = { btnRef } > { \" \" } text { \" \" } < /DoubleWrappedButton> ); } TS Playground link Polymorphic Components (e.g. with as props) \"Polymorphic Components\" = passing a component to be rendered, e.g. with as props ElementType is pretty useful to cover most types that can be passed to createElement e.g. function PassThrough ( props : { as : React.ElementType < any > }) { const { as : Component } = props ; return < Component /> ; } You might also see this with React Router: const PrivateRoute = ({ component : Component , ... rest } : PrivateRouteProps ) => { const { isLoggedIn } = useAuth (); return isLoggedIn ? < Component {... rest } /> : < Redirect to = \"/\" /> ; }; For more info you can refer to these resources: https://blog.andrewbran.ch/polymorphic-react-components/ https://github.com/kripod/react-polymorphic-box https://stackoverflow.com/questions/58200824/generic-react-typescript-component-with-as-prop-able-to-render-any-valid-dom Thanks @eps1lon and @karol-majewski for thoughts! Generic Components Just as you can make generic functions and classes in TypeScript, you can also make generic components to take advantage of the type system for reusable type safety. Both Props and State can take advantage of the same generic types, although it probably makes more sense for Props than for State. You can then use the generic type to annotate types of any variables defined inside your function / class scope. import { ReactNode , useState } from \"react\" ; interface Props < T > { items : T []; renderItem : ( item : T ) => ReactNode ; } function List < T > ( props : Props < T > ) { const { items , renderItem } = props ; const [ state , setState ] = useState < T [] > ([]); // You can use type T in List function scope. return ( < div > { items . map ( renderItem )} < button onClick = {() => setState ( items )} > Clone < /button> { JSON . stringify ( state , null , 2 )} < /div> ); } You can then use the generic components and get nice type safety through type inference: ReactDOM . render ( < List items = {[ \"a\" , \"b\" ]} // type of 'string' inferred renderItem = {( item ) => ( < li key = { item } > { /* Error: Property 'toPrecision' does not exist on type 'string'. */ } { item . toPrecision ( 3 )} < /li> )} /> , document . body ); As of TS 2.9 , you can also supply the type parameter in your JSX to opt out of type inference: ReactDOM . render ( < List < number > items = {[ \"a\" , \"b\" ]} // Error: Type 'string' is not assignable to type 'number'. renderItem = {( item ) => < li key = { item } > { item . toPrecision ( 3 )} < /li>} />, document . body ); You can also use Generics using fat arrow function style: import { ReactNode , useState } from \"react\" ; interface Props < T > { items : T []; renderItem : ( item : T ) => ReactNode ; } // Note the <T extends unknown> before the function definition. // You can't use just `<T>` as it will confuse the TSX parser whether it's a JSX tag or a Generic Declaration. // You can also use <T,> https://github.com/microsoft/TypeScript/issues/15713#issuecomment-499474386 const List = < T extends unknown > ( props : Props < T > ) => { const { items , renderItem } = props ; const [ state , setState ] = useState < T [] > ([]); // You can use type T in List function scope. return ( < div > { items . map ( renderItem )} < button onClick = {() => setState ( items )} > Clone < /button> { JSON . stringify ( state , null , 2 )} < /div> ); }; The same for using classes: (Credit: Karol Majewski 's gist ) import { PureComponent , ReactNode } from \"react\" ; interface Props < T > { items : T []; renderItem : ( item : T ) => ReactNode ; } interface State < T > { items : T []; } class List < T > extends PureComponent < Props < T > , State < T >> { // You can use type T inside List class. state : Readonly < State < T >> = { items : [], }; render () { const { items , renderItem } = this . props ; // You can use type T inside List class. const clone : T [] = items . slice ( 0 ); return ( < div > { items . map ( renderItem )} < button onClick = {() => this . setState ({ items : clone })} > Clone < /button> { JSON . stringify ( this . state , null , 2 )} < /div> ); } } Though you can't use Generic Type Parameters for Static Members: class List < T > extends React . PureComponent < Props < T > , State < T >> { // Static members cannot reference class type parameters.ts(2302) static getDerivedStateFromProps ( props : Props < T > , state : State < T > ) { return { items : props.items }; } } To fix this you need to convert your static function to a type inferred function: class List < T > extends React . PureComponent < Props < T > , State < T >> { static getDerivedStateFromProps < T > ( props : Props < T > , state : State < T > ) { return { items : props.items }; } } Typing Children Some API designs require some restriction on children passed to a parent component. It is common to want to enforce these in types, but you should be aware of limitations to this ability. What You CAN Do You can type the structure of your children: just one child, or a tuple of children. The following are valid: type OneChild = React . ReactElement ; type TwoChildren = [ React . ReactElement , React . ReactElement ]; type ArrayOfProps = SomeProp []; type NumbersChildren = number []; type TwoNumbersChildren = [ number , number ]; Don't forget that you can also use `prop-types` if TS fails you. Parent . propTypes = { children : PropTypes.shape ({ props : PropTypes.shape ({ // could share `propTypes` to the child value : PropTypes.string.isRequired , }), }). isRequired , }; What You CANNOT Do The thing you cannot do is specify which components the children are, e.g. If you want to express the fact that \"React Router <Routes> can only have <Route> as children, nothing else is allowed\" in TypeScript. This is because when you write a JSX expression ( const foo = <MyComponent foo='foo' /> ), the resultant type is blackboxed into a generic JSX.Element type. ( thanks @ferdaber ) Type Narrowing based on Props What you want: // Usage function App () { return ( <> { /* \ud83d\ude0e All good */ } < Button target = \"_blank\" href = \"https://www.google.com\" > Test < /Button> { /* \ud83d\ude2d Error, `disabled` doesnt exist on anchor element */ } < Button disabled href = \"x\" > Test < /Button> < /> ); } How to implement: Use type guards ! // Button props type ButtonProps = React . ButtonHTMLAttributes < HTMLButtonElement > & { href? : undefined ; }; // Anchor props type AnchorProps = React . AnchorHTMLAttributes < HTMLAnchorElement > & { href? : string ; }; // Input/output options type Overload = { ( props : ButtonProps ) : JSX . Element ; ( props : AnchorProps ) : JSX . Element ; }; // Guard to check if href exists in props const hasHref = ( props : ButtonProps | AnchorProps ) : props is AnchorProps => \"href\" in props ; // Component const Button : Overload = ( props : ButtonProps | AnchorProps ) => { // anchor render if ( hasHref ( props )) return < a {... props } /> ; // button render return < button {... props } /> ; }; View in the TypeScript Playground Components, and JSX in general, are analogous to functions. When a component can render differently based on their props, it's similar to how a function can be overloaded to have multiple call signatures. In the same way, you can overload a function component's call signature to list all of its different \"versions\". A very common use case for this is to render something as either a button or an anchor, based on if it receives a href attribute. type ButtonProps = JSX . IntrinsicElements [ \"button\" ]; type AnchorProps = JSX . IntrinsicElements [ \"a\" ]; // optionally use a custom type guard function isPropsForAnchorElement ( props : ButtonProps | AnchorProps ) : props is AnchorProps { return \"href\" in props ; } function Clickable ( props : ButtonProps | AnchorProps ) { if ( isPropsForAnchorElement ( props )) { return < a {... props } /> ; } else { return < button {... props } /> ; } } They don't even need to be completely different props, as long as they have at least one difference in properties: type LinkProps = Omit < JSX . IntrinsicElements [ \"a\" ], \"href\" > & { to? : string }; function RouterLink ( props : LinkProps | AnchorProps ) { if ( \"href\" in props ) { return < a {... props } /> ; } else { return < Link {... props } /> ; } } Approach: Generic Components Here is an example solution, see the further discussion for other solutions. _thanks to [@jpavon](https://github.com/typescript-cheatsheets/react/issues/12#issuecomment-394440577)_ interface LinkProps {} type AnchorProps = React . AnchorHTMLAttributes < HTMLAnchorElement > ; type RouterLinkProps = Omit < NavLinkProps , \"href\" > ; const Link = < T extends {} > ( props : LinkProps & T extends RouterLinkProps ? RouterLinkProps : AnchorProps ) => { if (( props as RouterLinkProps ). to ) { return < NavLink {...( props as RouterLinkProps )} /> ; } else { return < a {...( props as AnchorProps )} /> ; } }; < Link < RouterLinkProps > to = \"/\" > My link < /Link>; / / ok < Link < AnchorProps > href = \"/\" > My link < /Link>; / / ok < Link < RouterLinkProps > to = \"/\" href = \"/\" > My link < /Link>; / / error Approach: Composition If you want to conditionally render a component, sometimes is better to use [React's composition model](https://reactjs.org/docs/composition-vs-inheritance.html) to have simpler components and better to understand typings: type AnchorProps = React . AnchorHTMLAttributes < HTMLAnchorElement > ; type RouterLinkProps = Omit < AnchorProps , \"href\" > ; interface ButtonProps { as : React.ComponentClass | \"a\" ; children? : React.ReactNode ; } const Button : React.FunctionComponent < ButtonProps > = ( props ) => { const { as : Component , children , ... rest } = props ; return ( < Component className = \"button\" {... rest } > { children } < /Component> ); }; const AnchorButton : React.FunctionComponent < AnchorProps > = ( props ) => ( < Button as = \"a\" {... props } /> ); const LinkButton : React.FunctionComponent < RouterLinkProps > = ( props ) => ( < Button as = { NavLink } {... props } /> ); < LinkButton to = \"/login\" > Login < /LinkButton>; < AnchorButton href = \"/login\" > Login < /AnchorButton>; < AnchorButton href = \"/login\" to = \"/test\" > Login < /AnchorButton>; / / Error : Property 'to' does not exist on type ... You may also want to use Discriminated Unions, please check out Expressive React Component APIs with Discriminated Unions . Here is a brief intuition for Discriminated Union Types : type UserTextEvent = { type : \"TextEvent\" ; value : string ; target : HTMLInputElement ; }; type UserMouseEvent = { type : \"MouseEvent\" ; value : [ number , number ]; target : HTMLElement ; }; type UserEvent = UserTextEvent | UserMouseEvent ; function handle ( event : UserEvent ) { if ( event . type === \"TextEvent\" ) { event . value ; // string event . target ; // HTMLInputElement return ; } event . value ; // [number, number] event . target ; // HTMLElement } Take care: TypeScript does not narrow the type of a Discriminated Union on the basis of typeof checks. The type guard has to be on the value of a key and not it's type. type UserTextEvent = { value : string ; target : HTMLInputElement }; type UserMouseEvent = { value : [ number , number ]; target : HTMLElement }; type UserEvent = UserTextEvent | UserMouseEvent ; function handle ( event : UserEvent ) { if ( typeof event . value === \"string\" ) { event . value ; // string event . target ; // HTMLInputElement | HTMLElement (!!!!) return ; } event . value ; // [number, number] event . target ; // HTMLInputElement | HTMLElement (!!!!) } The above example does not work as we are not checking the value of `event.value` but only it's type. Read more about it [microsoft/TypeScript#30506 (comment)](https://github.com/microsoft/TypeScript/issues/30506#issuecomment-474858198) Discriminated Unions in TypeScript can also work with hook dependencies in React. The type matched is automatically updated when the corresponding union member based on which a hook depends, changes. Expand more to see an example usecase. import { useMemo } from \"react\" ; interface SingleElement { isArray : true ; value : string []; } interface MultiElement { isArray : false ; value : string ; } type Props = SingleElement | MultiElement ; function Sequence ( p : Props ) { return useMemo ( () => ( < div > value ( s ) : { p . isArray && p . value . join ( \",\" )} { ! p . isArray && p . value } < /div> ), [ p . isArray , p . value ] // TypeScript automatically matches the corresponding value type based on dependency change ); } function App () { return ( < div > < Sequence isArray = { false } value = { \"foo\" } /> < Sequence isArray = { true } value = {[ \"foo\" , \"bar\" , \"baz\" ]} /> < /div> ); } See this in TS Playground In the above example, based on the `isArray` union member, the type of the `value` hook dependency changes. To streamline this you may also combine this with the concept of User-Defined Type Guards : function isString ( a : unknown ) : a is string { return typeof a === \"string\" ; } Read more about User-Defined Type Guards in the Handbook . Narrowing using extends See this quick guide: https://twitter.com/mpocock1/status/1500813765973053440?s=20&t=ImUA-NnZc4iUuPDx-XiMTA Props: One or the Other but not Both Use the in keyword, function overloading, and union types to make components that take either one or another sets of props, but not both: type Props1 = { foo : string }; type Props2 = { bar : string }; function MyComponent ( props : Props1 | Props2 ) { if ( \"foo\" in props ) { // props.bar // error return < div > { props . foo } < /div>; } else { // props.foo // error return < div > { props . bar } < /div>; } } const UsageComponent = () => ( < div > < MyComponent foo = \"foo\" /> < MyComponent bar = \"bar\" /> { /* <MyComponent foo=\"foo\" bar=\"bar\"/> // invalid */ } < /div> ); View in the TypeScript Playground Further reading: how to ban passing {} if you have a NoFields type. Props: Must Pass Both type OneOrAnother < T1 , T2 > = | ( T1 & { [ K in keyof T2 ] ? : undefined }) | ( T2 & { [ K in keyof T1 ] ? : undefined }); type Props = OneOrAnother < { a : string ; b : string }, {} > ; const a : Props = { a : \"a\" }; // error const b : Props = { b : \"b\" }; // error const ab : Props = { a : \"a\" , b : \"b\" }; // ok Thanks diegohaz Props: Pass One ONLY IF the Other Is Passed Say you want a Text component that gets truncated if truncate prop is passed but expands to show the full text when expanded prop is passed (e.g. when the user clicks the text). You want to allow expanded to be passed only if truncate is also passed, because there is no use for expanded if the text is not truncated. Usage example: const App = () => ( <> { /* these all typecheck */ } < Text > not truncated < /Text> < Text truncate > truncated < /Text> < Text truncate expanded > truncate - able but expanded < /Text> { /* TS error: Property 'truncate' is missing in type '{ children: string; expanded: true; }' but required in type '{ truncate: true; expanded?: boolean | undefined; }'. */ } < Text expanded > truncate - able but expanded < /Text> < /> ); You can implement this by function overloads: import { ReactNode } from \"react\" ; interface CommonProps { children? : ReactNode ; miscProps? : any ; } type NoTruncateProps = CommonProps & { truncate? : false }; type TruncateProps = CommonProps & { truncate : true ; expanded? : boolean }; // Function overloads to accept both prop types NoTruncateProps & TruncateProps function Text ( props : NoTruncateProps ) : JSX . Element ; function Text ( props : TruncateProps ) : JSX . Element ; function Text ( props : CommonProps & { truncate? : boolean ; expanded? : boolean }) { const { children , truncate , expanded , ... otherProps } = props ; const classNames = truncate ? \".truncate\" : \"\" ; return ( < div className = { classNames } aria - expanded = { !! expanded } {... otherProps } > { children } < /div> ); } Props: Omit prop from a type Note: Omit was added as a first class utility in TS 3.5 ! \ud83c\udf89 Sometimes when intersecting types, we want to define our own version of a prop. For example, I want my component to have a label , but the type I am intersecting with also has a label prop. Here's how to extract that out: export interface Props { label : React.ReactNode ; // this will conflict with the InputElement's label } // this comes inbuilt with TS 3.5 type Omit < T , K extends keyof T > = Pick < T , Exclude < keyof T , K >> ; // usage export const Checkbox = ( props : Props & Omit < React . HTMLProps < HTMLInputElement > , \"label\" > ) => { const { label } = props ; return ( < div className = \"Checkbox\" > < label className = \"Checkbox-label\" > < input type = \"checkbox\" {... props } /> < /label> < span > { label } < /span> < /div> ); }; When your component defines multiple props, chances of those conflicts increase. However you can explicitly state that all your fields should be removed from the underlying component using the keyof operator: export interface Props { label : React.ReactNode ; // conflicts with the InputElement's label onChange : ( text : string ) => void ; // conflicts with InputElement's onChange } export const Textbox = ( props : Props & Omit < React . HTMLProps < HTMLInputElement > , keyof Props > ) => { // implement Textbox component ... }; As you can see from the Omit example above, you can write significant logic in your types as well. type-zoo is a nice toolkit of operators you may wish to check out (includes Omit), as well as utility-types (especially for those migrating from Flow). Props: Extracting Prop Types of a Component Sometimes you want the prop types of a component, but it isn't exported. A simple solution is to use React.ComponentProps : // a Modal component defined elsewhere const defaultProps : React.ComponentProps < typeof Modal > = { title : \"Hello World\" , visible : true , onClick : jest.fn (), }; There are advanced edge cases if you want to extract the prop types of a component taking into account internal props, propTypes , and defaultProps - check our issue here for helper utilities that resolve these . Props: Render Props Advice: Where possible, you should try to use Hooks instead of Render Props. We include this merely for completeness. Sometimes you will want to write a function that can take a React element or a string or something else as a prop. The best Type to use for such a situation is ReactNode which fits anywhere a normal, well, React Node would fit: import { ReactNode } from \"react\" ; interface Props { label? : ReactNode ; children? : ReactNode ; } const Card = ({ children , label } : Props ) => { return ( < div > { label && < div > { label } < /div>} { children } < /div> ); }; If you are using a function-as-a-child render prop: import { ReactNode } from \"react\" ; interface Props { children : ( foo : string ) => ReactNode ; } Something to add? File an issue . Handling Exceptions You can provide good information when bad things happen. class InvalidDateFormatError extends RangeError {} class DateIsInFutureError extends RangeError {} /** * // optional docblock * @throws {InvalidDateFormatError} The user entered date incorrectly * @throws {DateIsInFutureError} The user entered date in future * */ function parse ( date : string ) { if ( ! isValid ( date )) throw new InvalidDateFormatError ( \"not a valid date format\" ); if ( isInFuture ( date )) throw new DateIsInFutureError ( \"date is in the future\" ); // ... } try { // call parse(date) somewhere } catch ( e ) { if ( e instanceof InvalidDateFormatError ) { console . error ( \"invalid date format\" , e ); } else if ( e instanceof DateIsInFutureError ) { console . warn ( \"date is in future\" , e ); } else { throw e ; } } View in TypeScript Playground Simply throwing an exception is fine, however it would be nice to make TypeScript remind the consumer of your code to handle your exception. We can do that just by returning instead of throwing: function parse ( date : string ) : Date | InvalidDateFormatError | DateIsInFutureError { if ( ! isValid ( date )) return new InvalidDateFormatError ( \"not a valid date format\" ); if ( isInFuture ( date )) return new DateIsInFutureError ( \"date is in the future\" ); // ... } // now consumer *has* to handle the errors let result = parse ( \"mydate\" ); if ( result instanceof InvalidDateFormatError ) { console . error ( \"invalid date format\" , result . message ); } else if ( result instanceof DateIsInFutureError ) { console . warn ( \"date is in future\" , result . message ); } else { /// use result safely } // alternately you can just handle all errors if ( result instanceof Error ) { console . error ( \"error\" , result ); } else { /// use result safely } You can also describe exceptions with special-purpose data types (don't say monads...) like the Try , Option (or Maybe ), and Either data types: interface Option < T > { flatMap < U > ( f : ( value : T ) => None ) : None ; flatMap < U > ( f : ( value : T ) => Option < U > ) : FormikOption < U > ; getOrElse ( value : T ) : T ; } class Some < T > implements Option < T > { constructor ( private value : T ) {} flatMap < U > ( f : ( value : T ) => None ) : None ; flatMap < U > ( f : ( value : T ) => Some < U > ) : Some < U > ; flatMap < U > ( f : ( value : T ) => Option < U > ) : Option < U > { return f ( this . value ); } getOrElse () : T { return this . value ; } } class None implements Option < never > { flatMap < U > () : None { return this ; } getOrElse < U > ( value : U ) : U { return value ; } } // now you can use it like: let result = Option ( 6 ) // Some<number> . flatMap (( n ) => Option ( n * 3 )) // Some<number> . flatMap (( n = new None ())) // None . getOrElse ( 7 ); // or: let result = ask () // Option<string> . flatMap ( parse ) // Option<Date> . flatMap (( d ) => new Some ( d . toISOString ())) // Option<string> . getOrElse ( \"error parsing string\" );","title":"Useful Patterns"},{"location":"pages/react/typescript/advanced/patterns_by_usecase/#wrappingmirroring","text":"","title":"Wrapping/Mirroring"},{"location":"pages/react/typescript/advanced/patterns_by_usecase/#wrappingmirroring-a-html-element","text":"Usecase: you want to make a <Button> that takes all the normal props of <button> and does extra stuff. Strategy: extend React.ComponentPropsWithoutRef<'button'> // usage function App () { // Type '\"foo\"' is not assignable to type '\"button\" | \"submit\" | \"reset\" | undefined'.(2322) // return <Button type=\"foo\"> sldkj </Button> // no error return < Button type = \"button\" > text < /Button>; } // implementation export interface ButtonProps extends React . ComponentPropsWithoutRef < \"button\" > { specialProp? : string ; } export function Button ( props : ButtonProps ) { const { specialProp , ... rest } = props ; // do something with specialProp return < button {... rest } /> ; } See this in the TS Playground Forwarding Refs : As the React docs themselves note , most usecases will not need to obtain a ref to the inner element. But for people making reusable component libraries, you will need to forwardRef the underlying element, and then you can use ComponentPropsWithRef to grab props for your wrapper component. Check our docs on forwarding Refs for more. In future, the need to forwardRef may go away in React 17+, but for now we still have to deal with this. \ud83d\ude43 Why not `ComponentProps` or `IntrinsicElements` or `[Element]HTMLAttributes` or `HTMLProps` or `HTMLAttributes`? ## `ComponentProps` You CAN use `ComponentProps` in place of `ComponentPropsWithRef`, but you may prefer to be explicit about whether or not the component's refs are forwarded, which is what we have chosen to demonstrate. The tradeoff is slightly more intimidating terminology. More info: https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forward_and_create_ref/ ### Maybe `JSX.IntrinsicElements` or `[Element]HTMLAttributes` There are at least 2 other equivalent ways to do this, but they are more verbose: // Method 1: JSX.IntrinsicElements type BtnType = JSX . IntrinsicElements [ \"button\" ]; // cannot inline or will error export interface ButtonProps extends BtnType {} // etc // Method 2: React.[Element]HTMLAttributes export interface ButtonProps extends React . ButtonHTMLAttributes < HTMLButtonElement > Looking at [the source for `ComponentProps`](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/f3134f4897c8473f590cbcdd5788da8d59796f45/types/react/index.d.ts#L821) shows that this is a clever wrapper for `JSX.IntrinsicElements`, whereas the second method relies on specialized interfaces with unfamiliar naming/capitalization. > Note: There are over 50 of these specialized interfaces available - look for `HTMLAttributes` in our [`@types/react` commentary](https://react-typescript-cheatsheet.netlify.app/docs/advanced/types_react_api#typesreact). Ultimately, [we picked the `ComponentProps` method](https://github.com/typescript-cheatsheets/react/pull/276) as it involves the least TS specific jargon and has the most ease of use. But you'll be fine with either of these methods if you prefer. ### Definitely not `React.HTMLProps` or `React.HTMLAttributes` This is what happens when you use `React.HTMLProps`: export interface ButtonProps extends React . HTMLProps < HTMLButtonElement > { specialProp : string ; } export function Button ( props : ButtonProps ) { const { specialProp , ... rest } = props ; // ERROR: Type 'string' is not assignable to type '\"button\" | \"submit\" | \"reset\" | undefined'. return < button {... rest } /> ; } It infers a too-wide type of `string` for `type`, because it [uses `AllHTMLAttributes` under the hood](https://github.com/typescript-cheatsheets/react/issues/128#issuecomment-508103558). This is what happens when you use `React.HTMLAttributes`: import { HTMLAttributes } from \"react\" ; export interface ButtonProps extends HTMLAttributes < HTMLButtonElement > { /* etc */ } function App () { // Property 'type' does not exist on type 'IntrinsicAttributes & ButtonProps' return < Button type = \"submit\" > text < /Button>; }","title":"Wrapping/Mirroring a HTML Element"},{"location":"pages/react/typescript/advanced/patterns_by_usecase/#wrappingmirroring-a-component","text":"TODO: this section needs work to make it simplified. Usecase: same as above, but for a React Component you don't have access to the underlying props import { CSSProperties } from \"react\" ; const Box = ( props : CSSProperties ) => < div style = { props } /> ; const Card = ( { title , children , ... props } : { title : string } & $ElementProps < typeof Box > // new utility, see below ) => ( < Box {... props } > { title } : { children } < /Box> ); Strategy: extract a component's props by inferring them Example: // ReactUtilityTypes.d.ts declare type $ElementProps < T > = T extends React . ComponentType < infer Props > ? Props extends object ? Props : never : never ; Usage: import * as Recompose from \"recompose\" ; export const defaultProps = < C extends React . ComponentType , D extends Partial < $ElementProps < C >> > ( defaults : D , Component : C ) : React . ComponentType < $ElementProps < C > & Partial < D >> => Recompose . defaultProps ( defaults )( Component ); thanks dmisdm You should also consider whether to explicitly forward refs: import { forwardRef , ReactNode } from \"react\" ; // base button, with ref forwarding type Props = { children : ReactNode ; type : \"submit\" | \"button\" }; export type Ref = HTMLButtonElement ; export const FancyButton = forwardRef < Ref , Props > (( props , ref ) => ( < button ref = { ref } className = \"MyCustomButtonClass\" type = { props . type } > { props . children } < /button> )); // second layer button, no need for forwardRef (TODO: doublecheck this) export interface DoubleWrappedProps extends React . ComponentPropsWithRef < typeof FancyButton > { specialProp? : string ; } export function DoubleWrappedButton ( props : DoubleWrappedProps ) { const { specialProp , ref , ... rest } = props ; return < button ref = { ref } {... rest } /> ; } // usage import { useRef } from \"react\" ; function App () { const btnRef = useRef < HTMLButtonElement > ( null ! ); return ( < DoubleWrappedButton type = \"button\" ref = { btnRef } > { \" \" } text { \" \" } < /DoubleWrappedButton> ); } TS Playground link","title":"Wrapping/Mirroring a Component"},{"location":"pages/react/typescript/advanced/patterns_by_usecase/#polymorphic-components-eg-with-as-props","text":"\"Polymorphic Components\" = passing a component to be rendered, e.g. with as props ElementType is pretty useful to cover most types that can be passed to createElement e.g. function PassThrough ( props : { as : React.ElementType < any > }) { const { as : Component } = props ; return < Component /> ; } You might also see this with React Router: const PrivateRoute = ({ component : Component , ... rest } : PrivateRouteProps ) => { const { isLoggedIn } = useAuth (); return isLoggedIn ? < Component {... rest } /> : < Redirect to = \"/\" /> ; }; For more info you can refer to these resources: https://blog.andrewbran.ch/polymorphic-react-components/ https://github.com/kripod/react-polymorphic-box https://stackoverflow.com/questions/58200824/generic-react-typescript-component-with-as-prop-able-to-render-any-valid-dom Thanks @eps1lon and @karol-majewski for thoughts!","title":"Polymorphic Components (e.g. with as props)"},{"location":"pages/react/typescript/advanced/patterns_by_usecase/#generic-components","text":"Just as you can make generic functions and classes in TypeScript, you can also make generic components to take advantage of the type system for reusable type safety. Both Props and State can take advantage of the same generic types, although it probably makes more sense for Props than for State. You can then use the generic type to annotate types of any variables defined inside your function / class scope. import { ReactNode , useState } from \"react\" ; interface Props < T > { items : T []; renderItem : ( item : T ) => ReactNode ; } function List < T > ( props : Props < T > ) { const { items , renderItem } = props ; const [ state , setState ] = useState < T [] > ([]); // You can use type T in List function scope. return ( < div > { items . map ( renderItem )} < button onClick = {() => setState ( items )} > Clone < /button> { JSON . stringify ( state , null , 2 )} < /div> ); } You can then use the generic components and get nice type safety through type inference: ReactDOM . render ( < List items = {[ \"a\" , \"b\" ]} // type of 'string' inferred renderItem = {( item ) => ( < li key = { item } > { /* Error: Property 'toPrecision' does not exist on type 'string'. */ } { item . toPrecision ( 3 )} < /li> )} /> , document . body ); As of TS 2.9 , you can also supply the type parameter in your JSX to opt out of type inference: ReactDOM . render ( < List < number > items = {[ \"a\" , \"b\" ]} // Error: Type 'string' is not assignable to type 'number'. renderItem = {( item ) => < li key = { item } > { item . toPrecision ( 3 )} < /li>} />, document . body ); You can also use Generics using fat arrow function style: import { ReactNode , useState } from \"react\" ; interface Props < T > { items : T []; renderItem : ( item : T ) => ReactNode ; } // Note the <T extends unknown> before the function definition. // You can't use just `<T>` as it will confuse the TSX parser whether it's a JSX tag or a Generic Declaration. // You can also use <T,> https://github.com/microsoft/TypeScript/issues/15713#issuecomment-499474386 const List = < T extends unknown > ( props : Props < T > ) => { const { items , renderItem } = props ; const [ state , setState ] = useState < T [] > ([]); // You can use type T in List function scope. return ( < div > { items . map ( renderItem )} < button onClick = {() => setState ( items )} > Clone < /button> { JSON . stringify ( state , null , 2 )} < /div> ); }; The same for using classes: (Credit: Karol Majewski 's gist ) import { PureComponent , ReactNode } from \"react\" ; interface Props < T > { items : T []; renderItem : ( item : T ) => ReactNode ; } interface State < T > { items : T []; } class List < T > extends PureComponent < Props < T > , State < T >> { // You can use type T inside List class. state : Readonly < State < T >> = { items : [], }; render () { const { items , renderItem } = this . props ; // You can use type T inside List class. const clone : T [] = items . slice ( 0 ); return ( < div > { items . map ( renderItem )} < button onClick = {() => this . setState ({ items : clone })} > Clone < /button> { JSON . stringify ( this . state , null , 2 )} < /div> ); } } Though you can't use Generic Type Parameters for Static Members: class List < T > extends React . PureComponent < Props < T > , State < T >> { // Static members cannot reference class type parameters.ts(2302) static getDerivedStateFromProps ( props : Props < T > , state : State < T > ) { return { items : props.items }; } } To fix this you need to convert your static function to a type inferred function: class List < T > extends React . PureComponent < Props < T > , State < T >> { static getDerivedStateFromProps < T > ( props : Props < T > , state : State < T > ) { return { items : props.items }; } }","title":"Generic Components"},{"location":"pages/react/typescript/advanced/patterns_by_usecase/#typing-children","text":"Some API designs require some restriction on children passed to a parent component. It is common to want to enforce these in types, but you should be aware of limitations to this ability.","title":"Typing Children"},{"location":"pages/react/typescript/advanced/patterns_by_usecase/#what-you-can-do","text":"You can type the structure of your children: just one child, or a tuple of children. The following are valid: type OneChild = React . ReactElement ; type TwoChildren = [ React . ReactElement , React . ReactElement ]; type ArrayOfProps = SomeProp []; type NumbersChildren = number []; type TwoNumbersChildren = [ number , number ]; Don't forget that you can also use `prop-types` if TS fails you. Parent . propTypes = { children : PropTypes.shape ({ props : PropTypes.shape ({ // could share `propTypes` to the child value : PropTypes.string.isRequired , }), }). isRequired , };","title":"What You CAN Do"},{"location":"pages/react/typescript/advanced/patterns_by_usecase/#what-you-cannot-do","text":"The thing you cannot do is specify which components the children are, e.g. If you want to express the fact that \"React Router <Routes> can only have <Route> as children, nothing else is allowed\" in TypeScript. This is because when you write a JSX expression ( const foo = <MyComponent foo='foo' /> ), the resultant type is blackboxed into a generic JSX.Element type. ( thanks @ferdaber )","title":"What You CANNOT Do"},{"location":"pages/react/typescript/advanced/patterns_by_usecase/#type-narrowing-based-on-props","text":"What you want: // Usage function App () { return ( <> { /* \ud83d\ude0e All good */ } < Button target = \"_blank\" href = \"https://www.google.com\" > Test < /Button> { /* \ud83d\ude2d Error, `disabled` doesnt exist on anchor element */ } < Button disabled href = \"x\" > Test < /Button> < /> ); } How to implement: Use type guards ! // Button props type ButtonProps = React . ButtonHTMLAttributes < HTMLButtonElement > & { href? : undefined ; }; // Anchor props type AnchorProps = React . AnchorHTMLAttributes < HTMLAnchorElement > & { href? : string ; }; // Input/output options type Overload = { ( props : ButtonProps ) : JSX . Element ; ( props : AnchorProps ) : JSX . Element ; }; // Guard to check if href exists in props const hasHref = ( props : ButtonProps | AnchorProps ) : props is AnchorProps => \"href\" in props ; // Component const Button : Overload = ( props : ButtonProps | AnchorProps ) => { // anchor render if ( hasHref ( props )) return < a {... props } /> ; // button render return < button {... props } /> ; }; View in the TypeScript Playground Components, and JSX in general, are analogous to functions. When a component can render differently based on their props, it's similar to how a function can be overloaded to have multiple call signatures. In the same way, you can overload a function component's call signature to list all of its different \"versions\". A very common use case for this is to render something as either a button or an anchor, based on if it receives a href attribute. type ButtonProps = JSX . IntrinsicElements [ \"button\" ]; type AnchorProps = JSX . IntrinsicElements [ \"a\" ]; // optionally use a custom type guard function isPropsForAnchorElement ( props : ButtonProps | AnchorProps ) : props is AnchorProps { return \"href\" in props ; } function Clickable ( props : ButtonProps | AnchorProps ) { if ( isPropsForAnchorElement ( props )) { return < a {... props } /> ; } else { return < button {... props } /> ; } } They don't even need to be completely different props, as long as they have at least one difference in properties: type LinkProps = Omit < JSX . IntrinsicElements [ \"a\" ], \"href\" > & { to? : string }; function RouterLink ( props : LinkProps | AnchorProps ) { if ( \"href\" in props ) { return < a {... props } /> ; } else { return < Link {... props } /> ; } } Approach: Generic Components Here is an example solution, see the further discussion for other solutions. _thanks to [@jpavon](https://github.com/typescript-cheatsheets/react/issues/12#issuecomment-394440577)_ interface LinkProps {} type AnchorProps = React . AnchorHTMLAttributes < HTMLAnchorElement > ; type RouterLinkProps = Omit < NavLinkProps , \"href\" > ; const Link = < T extends {} > ( props : LinkProps & T extends RouterLinkProps ? RouterLinkProps : AnchorProps ) => { if (( props as RouterLinkProps ). to ) { return < NavLink {...( props as RouterLinkProps )} /> ; } else { return < a {...( props as AnchorProps )} /> ; } }; < Link < RouterLinkProps > to = \"/\" > My link < /Link>; / / ok < Link < AnchorProps > href = \"/\" > My link < /Link>; / / ok < Link < RouterLinkProps > to = \"/\" href = \"/\" > My link < /Link>; / / error Approach: Composition If you want to conditionally render a component, sometimes is better to use [React's composition model](https://reactjs.org/docs/composition-vs-inheritance.html) to have simpler components and better to understand typings: type AnchorProps = React . AnchorHTMLAttributes < HTMLAnchorElement > ; type RouterLinkProps = Omit < AnchorProps , \"href\" > ; interface ButtonProps { as : React.ComponentClass | \"a\" ; children? : React.ReactNode ; } const Button : React.FunctionComponent < ButtonProps > = ( props ) => { const { as : Component , children , ... rest } = props ; return ( < Component className = \"button\" {... rest } > { children } < /Component> ); }; const AnchorButton : React.FunctionComponent < AnchorProps > = ( props ) => ( < Button as = \"a\" {... props } /> ); const LinkButton : React.FunctionComponent < RouterLinkProps > = ( props ) => ( < Button as = { NavLink } {... props } /> ); < LinkButton to = \"/login\" > Login < /LinkButton>; < AnchorButton href = \"/login\" > Login < /AnchorButton>; < AnchorButton href = \"/login\" to = \"/test\" > Login < /AnchorButton>; / / Error : Property 'to' does not exist on type ... You may also want to use Discriminated Unions, please check out Expressive React Component APIs with Discriminated Unions . Here is a brief intuition for Discriminated Union Types : type UserTextEvent = { type : \"TextEvent\" ; value : string ; target : HTMLInputElement ; }; type UserMouseEvent = { type : \"MouseEvent\" ; value : [ number , number ]; target : HTMLElement ; }; type UserEvent = UserTextEvent | UserMouseEvent ; function handle ( event : UserEvent ) { if ( event . type === \"TextEvent\" ) { event . value ; // string event . target ; // HTMLInputElement return ; } event . value ; // [number, number] event . target ; // HTMLElement } Take care: TypeScript does not narrow the type of a Discriminated Union on the basis of typeof checks. The type guard has to be on the value of a key and not it's type. type UserTextEvent = { value : string ; target : HTMLInputElement }; type UserMouseEvent = { value : [ number , number ]; target : HTMLElement }; type UserEvent = UserTextEvent | UserMouseEvent ; function handle ( event : UserEvent ) { if ( typeof event . value === \"string\" ) { event . value ; // string event . target ; // HTMLInputElement | HTMLElement (!!!!) return ; } event . value ; // [number, number] event . target ; // HTMLInputElement | HTMLElement (!!!!) } The above example does not work as we are not checking the value of `event.value` but only it's type. Read more about it [microsoft/TypeScript#30506 (comment)](https://github.com/microsoft/TypeScript/issues/30506#issuecomment-474858198) Discriminated Unions in TypeScript can also work with hook dependencies in React. The type matched is automatically updated when the corresponding union member based on which a hook depends, changes. Expand more to see an example usecase. import { useMemo } from \"react\" ; interface SingleElement { isArray : true ; value : string []; } interface MultiElement { isArray : false ; value : string ; } type Props = SingleElement | MultiElement ; function Sequence ( p : Props ) { return useMemo ( () => ( < div > value ( s ) : { p . isArray && p . value . join ( \",\" )} { ! p . isArray && p . value } < /div> ), [ p . isArray , p . value ] // TypeScript automatically matches the corresponding value type based on dependency change ); } function App () { return ( < div > < Sequence isArray = { false } value = { \"foo\" } /> < Sequence isArray = { true } value = {[ \"foo\" , \"bar\" , \"baz\" ]} /> < /div> ); } See this in TS Playground In the above example, based on the `isArray` union member, the type of the `value` hook dependency changes. To streamline this you may also combine this with the concept of User-Defined Type Guards : function isString ( a : unknown ) : a is string { return typeof a === \"string\" ; } Read more about User-Defined Type Guards in the Handbook .","title":"Type Narrowing based on Props"},{"location":"pages/react/typescript/advanced/patterns_by_usecase/#narrowing-using-extends","text":"See this quick guide: https://twitter.com/mpocock1/status/1500813765973053440?s=20&t=ImUA-NnZc4iUuPDx-XiMTA","title":"Narrowing using extends"},{"location":"pages/react/typescript/advanced/patterns_by_usecase/#props-one-or-the-other-but-not-both","text":"Use the in keyword, function overloading, and union types to make components that take either one or another sets of props, but not both: type Props1 = { foo : string }; type Props2 = { bar : string }; function MyComponent ( props : Props1 | Props2 ) { if ( \"foo\" in props ) { // props.bar // error return < div > { props . foo } < /div>; } else { // props.foo // error return < div > { props . bar } < /div>; } } const UsageComponent = () => ( < div > < MyComponent foo = \"foo\" /> < MyComponent bar = \"bar\" /> { /* <MyComponent foo=\"foo\" bar=\"bar\"/> // invalid */ } < /div> ); View in the TypeScript Playground Further reading: how to ban passing {} if you have a NoFields type.","title":"Props: One or the Other but not Both"},{"location":"pages/react/typescript/advanced/patterns_by_usecase/#props-must-pass-both","text":"type OneOrAnother < T1 , T2 > = | ( T1 & { [ K in keyof T2 ] ? : undefined }) | ( T2 & { [ K in keyof T1 ] ? : undefined }); type Props = OneOrAnother < { a : string ; b : string }, {} > ; const a : Props = { a : \"a\" }; // error const b : Props = { b : \"b\" }; // error const ab : Props = { a : \"a\" , b : \"b\" }; // ok Thanks diegohaz","title":"Props: Must Pass Both"},{"location":"pages/react/typescript/advanced/patterns_by_usecase/#props-pass-one-only-if-the-other-is-passed","text":"Say you want a Text component that gets truncated if truncate prop is passed but expands to show the full text when expanded prop is passed (e.g. when the user clicks the text). You want to allow expanded to be passed only if truncate is also passed, because there is no use for expanded if the text is not truncated. Usage example: const App = () => ( <> { /* these all typecheck */ } < Text > not truncated < /Text> < Text truncate > truncated < /Text> < Text truncate expanded > truncate - able but expanded < /Text> { /* TS error: Property 'truncate' is missing in type '{ children: string; expanded: true; }' but required in type '{ truncate: true; expanded?: boolean | undefined; }'. */ } < Text expanded > truncate - able but expanded < /Text> < /> ); You can implement this by function overloads: import { ReactNode } from \"react\" ; interface CommonProps { children? : ReactNode ; miscProps? : any ; } type NoTruncateProps = CommonProps & { truncate? : false }; type TruncateProps = CommonProps & { truncate : true ; expanded? : boolean }; // Function overloads to accept both prop types NoTruncateProps & TruncateProps function Text ( props : NoTruncateProps ) : JSX . Element ; function Text ( props : TruncateProps ) : JSX . Element ; function Text ( props : CommonProps & { truncate? : boolean ; expanded? : boolean }) { const { children , truncate , expanded , ... otherProps } = props ; const classNames = truncate ? \".truncate\" : \"\" ; return ( < div className = { classNames } aria - expanded = { !! expanded } {... otherProps } > { children } < /div> ); }","title":"Props: Pass One ONLY IF the Other Is Passed"},{"location":"pages/react/typescript/advanced/patterns_by_usecase/#props-omit-prop-from-a-type","text":"Note: Omit was added as a first class utility in TS 3.5 ! \ud83c\udf89 Sometimes when intersecting types, we want to define our own version of a prop. For example, I want my component to have a label , but the type I am intersecting with also has a label prop. Here's how to extract that out: export interface Props { label : React.ReactNode ; // this will conflict with the InputElement's label } // this comes inbuilt with TS 3.5 type Omit < T , K extends keyof T > = Pick < T , Exclude < keyof T , K >> ; // usage export const Checkbox = ( props : Props & Omit < React . HTMLProps < HTMLInputElement > , \"label\" > ) => { const { label } = props ; return ( < div className = \"Checkbox\" > < label className = \"Checkbox-label\" > < input type = \"checkbox\" {... props } /> < /label> < span > { label } < /span> < /div> ); }; When your component defines multiple props, chances of those conflicts increase. However you can explicitly state that all your fields should be removed from the underlying component using the keyof operator: export interface Props { label : React.ReactNode ; // conflicts with the InputElement's label onChange : ( text : string ) => void ; // conflicts with InputElement's onChange } export const Textbox = ( props : Props & Omit < React . HTMLProps < HTMLInputElement > , keyof Props > ) => { // implement Textbox component ... }; As you can see from the Omit example above, you can write significant logic in your types as well. type-zoo is a nice toolkit of operators you may wish to check out (includes Omit), as well as utility-types (especially for those migrating from Flow).","title":"Props: Omit prop from a type"},{"location":"pages/react/typescript/advanced/patterns_by_usecase/#props-extracting-prop-types-of-a-component","text":"Sometimes you want the prop types of a component, but it isn't exported. A simple solution is to use React.ComponentProps : // a Modal component defined elsewhere const defaultProps : React.ComponentProps < typeof Modal > = { title : \"Hello World\" , visible : true , onClick : jest.fn (), }; There are advanced edge cases if you want to extract the prop types of a component taking into account internal props, propTypes , and defaultProps - check our issue here for helper utilities that resolve these .","title":"Props: Extracting Prop Types of a Component"},{"location":"pages/react/typescript/advanced/patterns_by_usecase/#props-render-props","text":"Advice: Where possible, you should try to use Hooks instead of Render Props. We include this merely for completeness. Sometimes you will want to write a function that can take a React element or a string or something else as a prop. The best Type to use for such a situation is ReactNode which fits anywhere a normal, well, React Node would fit: import { ReactNode } from \"react\" ; interface Props { label? : ReactNode ; children? : ReactNode ; } const Card = ({ children , label } : Props ) => { return ( < div > { label && < div > { label } < /div>} { children } < /div> ); }; If you are using a function-as-a-child render prop: import { ReactNode } from \"react\" ; interface Props { children : ( foo : string ) => ReactNode ; } Something to add? File an issue .","title":"Props: Render Props"},{"location":"pages/react/typescript/advanced/patterns_by_usecase/#handling-exceptions","text":"You can provide good information when bad things happen. class InvalidDateFormatError extends RangeError {} class DateIsInFutureError extends RangeError {} /** * // optional docblock * @throws {InvalidDateFormatError} The user entered date incorrectly * @throws {DateIsInFutureError} The user entered date in future * */ function parse ( date : string ) { if ( ! isValid ( date )) throw new InvalidDateFormatError ( \"not a valid date format\" ); if ( isInFuture ( date )) throw new DateIsInFutureError ( \"date is in the future\" ); // ... } try { // call parse(date) somewhere } catch ( e ) { if ( e instanceof InvalidDateFormatError ) { console . error ( \"invalid date format\" , e ); } else if ( e instanceof DateIsInFutureError ) { console . warn ( \"date is in future\" , e ); } else { throw e ; } } View in TypeScript Playground Simply throwing an exception is fine, however it would be nice to make TypeScript remind the consumer of your code to handle your exception. We can do that just by returning instead of throwing: function parse ( date : string ) : Date | InvalidDateFormatError | DateIsInFutureError { if ( ! isValid ( date )) return new InvalidDateFormatError ( \"not a valid date format\" ); if ( isInFuture ( date )) return new DateIsInFutureError ( \"date is in the future\" ); // ... } // now consumer *has* to handle the errors let result = parse ( \"mydate\" ); if ( result instanceof InvalidDateFormatError ) { console . error ( \"invalid date format\" , result . message ); } else if ( result instanceof DateIsInFutureError ) { console . warn ( \"date is in future\" , result . message ); } else { /// use result safely } // alternately you can just handle all errors if ( result instanceof Error ) { console . error ( \"error\" , result ); } else { /// use result safely } You can also describe exceptions with special-purpose data types (don't say monads...) like the Try , Option (or Maybe ), and Either data types: interface Option < T > { flatMap < U > ( f : ( value : T ) => None ) : None ; flatMap < U > ( f : ( value : T ) => Option < U > ) : FormikOption < U > ; getOrElse ( value : T ) : T ; } class Some < T > implements Option < T > { constructor ( private value : T ) {} flatMap < U > ( f : ( value : T ) => None ) : None ; flatMap < U > ( f : ( value : T ) => Some < U > ) : Some < U > ; flatMap < U > ( f : ( value : T ) => Option < U > ) : Option < U > { return f ( this . value ); } getOrElse () : T { return this . value ; } } class None implements Option < never > { flatMap < U > () : None { return this ; } getOrElse < U > ( value : U ) : U { return value ; } } // now you can use it like: let result = Option ( 6 ) // Some<number> . flatMap (( n ) => Option ( n * 3 )) // Some<number> . flatMap (( n = new None ())) // None . getOrElse ( 7 ); // or: let result = ask () // Option<string> . flatMap ( parse ) // Option<Date> . flatMap (( d ) => new Some ( d . toISOString ())) // Option<string> . getOrElse ( \"error parsing string\" );","title":"Handling Exceptions"},{"location":"pages/react/typescript/advanced/patterns_by_version/","text":"TypeScript Versions often introduce new ways to do things; this section helps current users of React + TypeScript upgrade TypeScript versions and explore patterns commonly used by TypeScript + React apps and libraries. This may have duplications with other sections; if you spot any discrepancies, file an issue ! TypeScript version guides before 2.9 are unwritten, please feel free to send a PR! Apart from official TS team communication we also recommend Marius Schulz's blog for version notes . For more TypeScript history, see A Brief History of TypeScript Types and A Brief History of DefinitelyTyped . You may also wish to explore lesser known alternative typings of React like prop-types , om , reason-react , and typed-react . TypeScript 2.9 [ Release Notes | Blog Post ] Type arguments for tagged template strings (e.g. styled-components ): export interface InputFormProps { foo : string ; // this is understood inside the template string below } export const InputForm = styledInput < InputFormProps > ` color: ${ ({ themeName } ) => (themeName === \"dark\" ? \"black\" : \"white\")}; border-color: ${ ({ foo } ) => (foo ? \"red\" : \"black\")}; ` ; JSX Generics https://github.com/Microsoft/TypeScript/pull/22415 Helps with typing/using generic components: // instead of < Formik render = {( props : FormikProps < Values > ) => { /* your code here ... */ }} />; // usage < Formik < Values > render = {( props ) => { /* your code here ... */ }} />; < MyComponent < number > data = { 12 } /> ; More info: https://github.com/basarat/typescript-book/blob/master/docs/jsx/react.md#react-jsx-tip-generic-components TypeScript 3.0 [ Release Notes | Blog Post ] Typed rest parameters for writing arguments of variable length: // `rest` accepts any number of strings - even none! function foo ( ...rest : string []) { // ... } foo ( \"hello\" ); // works foo ( \"hello\" , \"world\" ); // also works Support for propTypes and static defaultProps in JSX using LibraryManagedAttributes : export interface Props { name : string ; } export class Greet extends React . Component < Props > { render () { const { name } = this . props ; return < div > Hello $ { name . toUpperCase ()} !< /div>; } static defaultProps = { name : \"world\" }; } // Type-checks! No type assertions needed! let el = < Greet /> ; new Unknown type For typing API's to force type checks - not specifically React related, however very handy for dealing with API responses: interface IComment { date : Date ; message : string ; } interface IDataService1 { getData () : any ; } let service1 : IDataService1 ; const response = service1 . getData (); response . a . b . c . d ; // RUNTIME ERROR // ----- compare with ------- interface IDataService2 { getData () : unknown ; // ooo } let service2 : IDataService2 ; const response2 = service2 . getData (); // response2.a.b.c.d; // COMPILE TIME ERROR if you do this if ( typeof response === \"string\" ) { console . log ( response . toUpperCase ()); // `response` now has type 'string' } TODO: blame this change. Don't know what this should've done You can also assert a type, or use a type guard against an unknown type. This is better than resorting to any . Project References Project references allow TypeScript projects to depend on other TypeScript projects \u2013 specifically, allowing tsconfig.json files to reference other tsconfig.json files. This lets large codebases scale without recompiling every part of the codebase every time, by breaking it up into multiple projects. In each folder, create a tsconfig.json that includes at least: { \"compilerOptions\" : { \"composite\" : true , // tells TSC it is a subproject of a larger project \"declaration\" : true , // emit .d.ts declaration files since project references dont have access to source ts files. important for project references to work! \"declarationMap\" : true , // sourcemaps for .d.ts \"rootDir\" : \".\" // specify compile it relative to root project at . }, \"include\" : [ \"./**/*.ts\" ], \"references\" : [ // (optional) array of subprojects your subproject depends on { \"path\" : \"../myreferencedproject\" , // must have tsconfig.json \"prepend\" : true // concatenate js and sourcemaps generated by this subproject, if and only if using outFile } ] } and the root tsconfig.json that references top level subproject: { \"files\" : [], \"references\" : [{ \"path\" : \"./proj1\" }, { \"path\" : \"./proj2\" }] } and you must run tsc --build or tsc -b . To save the tsconfig boilerplate, you can use the extends option: { \"extends\" : \"../tsconfig.base\" // more stuff here } TypeScript 3.1 [ Release Notes | Blog Post ] Properties declarations on functions Attaching properties to functions like this \"just works\" now: export const FooComponent = ({ name }) => < div > Hello ! I am { name } < /div>; FooComponent . defaultProps = { name : \"swyx\" , }; TypeScript 3.2 [ Release Notes | Blog Post ] nothing specifically React related. TypeScript 3.3 [ Release Notes | Blog Post ] nothing specifically React related. TypeScript 3.4 [ Release Notes | Blog Post ] const assertions function useLoading () { const [ isLoading , setState ] = useState ( false ); const load = ( aPromise : Promise < any > ) => { setState ( true ); return aPromise . finally (() => setState ( false )); }; return [ isLoading , load ] as const ; // infers [boolean, typeof load] instead of (boolean | typeof load)[] } More info on places you can use const assertions . TypeScript 3.5 [ Release Notes | Blog Post ] Built-in <Omit> Type!! Higher order type inference from generic constructors type ComponentClass < P > = new ( props : P ) => Component < P > ; declare class Component < P > { props : P ; constructor ( props : P ); } declare function myHoc < P > ( C : ComponentClass < P > ) : ComponentClass < P > ; type NestedProps < T > = { foo : number ; stuff : T }; declare class GenericComponent < T > extends Component < NestedProps < T >> {} // type is 'new <T>(props: NestedProps<T>) => Component<NestedProps<T>>' const GenericComponent2 = myHoc ( GenericComponent ); See also Notes from Google upgrading to 3.5 TypeScript 3.6 [ Release Notes | Blog Post ] Nothing particularly React specific but the playground got an upgrade and Ambient Classes and Functions Can Merge TypeScript 3.7 [ Release Notes | Blog Post ] Optional Chaining let x = foo ? . bar . baz (); // is equivalent to let x = foo === null || foo === undefined ? undefined : foo.bar.baz (); // Optional Element access function tryGetFirstElement < T > ( arr? : T []) { return arr ? .[ 0 ]; } // Optional Call async function makeRequest ( url : string , log ?: ( msg : string ) => void ) { log ? .( `Request started at ${ new Date (). toISOString () } ` ); const result = ( await fetch ( url )). json (); log ? .( `Request finished at at ${ new Date (). toISOString () } ` ); return result ; } Nullish Coalescing let x = foo ?? bar (); // equivalent to let x = foo !== null && foo !== undefined ? foo : bar (); YOU SHOULD USUALLY USE ?? WHEREVER YOU NORMALLY USE || unless you truly mean falsiness: function ShowNumber ({ value } : { value : number }) { let _value = value || 0.5 ; // will replace 0 with 0.5 even if user really means 0 // etc... } Assertion Functions function assert ( condition : any , msg? : string ) : asserts condition { if ( ! condition ) { throw new AssertionError ( msg ); } } function yell ( str ) { assert ( typeof str === \"string\" ); return str . toUppercase (); // ~~~~~~~~~~~ // error: Property 'toUppercase' does not exist on type 'string'. // Did you mean 'toUpperCase'? } You can also assert without a custom function: function assertIsString ( val : any ) : asserts val is string { if ( typeof val !== \"string\" ) { throw new AssertionError ( \"Not a string!\" ); } } function yell ( str : any ) { assertIsString ( str ); // Now TypeScript knows that 'str' is a 'string'. return str . toUppercase (); // ~~~~~~~~~~~ // error: Property 'toUppercase' does not exist on type 'string'. // Did you mean 'toUpperCase'? } ts-nocheck You can now add // @ts-nocheck to the top of TypeScript files! good for migrations. TypeScript 3.8 [ Release Notes | Blog Post ] Type-Only Imports and Exports import type { SomeThing } from \"./some-module.js\" ; export type { SomeThing }; ECMAScript Private Fields Not really React specific but ok Bloomberg export * as ns Syntax This is ES2020 syntax. Instead of import * as utilities from \"./utilities.js\" ; export { utilities }; you can do export * as utilities from \"./utilities.js\" ; Top-Level await not React specific but gj Myles JSDoc Property Modifiers handy for JSDoc users - @public, @private, @protected, @readonly Better Directory Watching on Linux and watchOptions \u201cFast and Loose\u201d Incremental Checking assumeChangesOnlyAffectDirectDependencies reduces build times for extremely large codebases. TypeScript 3.9 [ Release Notes | Blog Post ] (minor feature) New ts-expect-error directive. Use this when writing tests you expect to error. // @ts-expect-error console . log ( 47 * \"octopus\" ); Pick ts-expect-error if: you\u2019re writing test code where you actually want the type system to error on an operation you expect a fix to be coming in fairly quickly and you just need a quick workaround you\u2019re in a reasonably-sized project with a proactive team that wants to remove suppression comments as soon affected code is valid again Pick ts-ignore if: you have an a larger project and and new errors have appeared in code with no clear owner you are in the middle of an upgrade between two different versions of TypeScript, and a line of code errors in one version but not another. you honestly don\u2019t have the time to decide which of these options is better. } and > are Now Invalid JSX Text Characters They were always invalid, but now TypeScript and Babel are enforcing it: Unexpected token. Did you mean `{'>'}` or `&gt;`? Unexpected token. Did you mean `{'}'}` or `&rbrace;`? You can convert these in bulk if needed. TypeScript 4.0 [ Release Notes | Blog Post ] Variadic Tuple Types useful for simplified Reducer-like State Custom JSX Factories It's for custom pragmas with Preact // Note: these pragma comments need to be written // with a JSDoc-style multiline syntax to take effect. /** @jsx h */ /** @jsxFrag Fragment */ import { h , Fragment } from \"preact\" ; let stuff = ( <> < div > Hello < /div> < /> ); // transformed to let stuff = h ( Fragment , null , h ( \"div\" , null , \"Hello\" )); TypeScript 4.1 [ Release Notes | Blog Post ] Template Literal Types This is a HUGE feature. Usecase 1 - Generating string literal types from permutations of other string literal types: type VerticalAlignment = \"top\" | \"middle\" | \"bottom\" ; type HorizontalAlignment = \"left\" | \"center\" | \"right\" ; // Takes // | \"top-left\" | \"top-center\" | \"top-right\" // | \"middle-left\" | \"middle-center\" | \"middle-right\" // | \"bottom-left\" | \"bottom-center\" | \"bottom-right\" declare function setAlignment ( value : ` ${ VerticalAlignment } - ${ HorizontalAlignment } ` ) : void ; setAlignment ( \"top-left\" ); // works! setAlignment ( \"top-middel\" ); // error! setAlignment ( \"top-pot\" ); // error! but good doughnuts if you're ever in Seattle Usecase 2 - Modeling dynaming string literal types: type PropEventSource < T > = { on ( eventName : ` ${ string & keyof T } Changed` , callback : () => void ) : void ; }; /// Create a \"watched object\" with an 'on' method /// so that you can watch for changes to properties. declare function makeWatchedObject < T > ( obj : T ) : T & PropEventSource < T > ; To make string manipulation easier there are new generics: Uppercase , Lowercase , Capitalize and Uncapitalize . You can combine it with the infer keyword like this : type ParseRouteParams < Rte > = Rte extends ` ${ string } /: ${ infer P } ` ? P : never ; type Params = ParseRouteParams < \"/api/user/:userID\" > ; // Params is \"userID\" type NoParams = ParseRouteParams < \"/api/user\" > ; // NoParams is never --> no params! This feature is extremely flexible, see other usecase ideas here: https://hasura.io/blog/how-typescript-template-literal-types-helped-us-with-multiple-database-support/ https://github.com/ghoullier/awesome-template-literal-types React 17 jsx Factories This is a new compiler option to offer output inline with React 17 support in general: // ./src/tsconfig.json - for production { \"compilerOptions\" : { \"module\" : \"esnext\" , \"target\" : \"es2015\" , \"jsx\" : \"react-jsx\" , \"strict\" : true }, \"include\" : [ \"./**/*\" ] } // ./src/tsconfig.dev.json - for development - extending the production config { \"extends\" : \"./tsconfig.json\" , \"compilerOptions\" : { \"jsx\" : \"react-jsxdev\" } } Misc Key Remapping in Mapped Types Recursive Conditional Types Checked Indexed Accesses TypeScript 4.2 [ Release Notes | Blog Post ] nothing react specific TypeScript 4.3 [ Release Notes | Blog Post ] nothing react specific TypeScript 4.4 [ Release Notes | Blog Post ] nothing react specific TypeScript 4.5 [ Release Notes | Blog Post ] (minor VSCode improvement) Snippet Completions for JSX Attributes TypeScript 4.6 [ Release Notes | Blog Post ] (extremely minor) Removed Unnecessary Arguments in react-jsx compile output TypeScript Roadmap and Spec https://github.com/Microsoft/TypeScript/wiki/Roadmap Did you also know you can read the TypeScript spec online?? https://github.com/microsoft/TypeScript/blob/master/doc/spec-ARCHIVED.md","title":"Useful Patterns"},{"location":"pages/react/typescript/advanced/patterns_by_version/#typescript-29","text":"[ Release Notes | Blog Post ] Type arguments for tagged template strings (e.g. styled-components ): export interface InputFormProps { foo : string ; // this is understood inside the template string below } export const InputForm = styledInput < InputFormProps > ` color: ${ ({ themeName } ) => (themeName === \"dark\" ? \"black\" : \"white\")}; border-color: ${ ({ foo } ) => (foo ? \"red\" : \"black\")}; ` ; JSX Generics https://github.com/Microsoft/TypeScript/pull/22415 Helps with typing/using generic components: // instead of < Formik render = {( props : FormikProps < Values > ) => { /* your code here ... */ }} />; // usage < Formik < Values > render = {( props ) => { /* your code here ... */ }} />; < MyComponent < number > data = { 12 } /> ; More info: https://github.com/basarat/typescript-book/blob/master/docs/jsx/react.md#react-jsx-tip-generic-components","title":"TypeScript 2.9"},{"location":"pages/react/typescript/advanced/patterns_by_version/#typescript-30","text":"[ Release Notes | Blog Post ] Typed rest parameters for writing arguments of variable length: // `rest` accepts any number of strings - even none! function foo ( ...rest : string []) { // ... } foo ( \"hello\" ); // works foo ( \"hello\" , \"world\" ); // also works Support for propTypes and static defaultProps in JSX using LibraryManagedAttributes : export interface Props { name : string ; } export class Greet extends React . Component < Props > { render () { const { name } = this . props ; return < div > Hello $ { name . toUpperCase ()} !< /div>; } static defaultProps = { name : \"world\" }; } // Type-checks! No type assertions needed! let el = < Greet /> ; new Unknown type For typing API's to force type checks - not specifically React related, however very handy for dealing with API responses: interface IComment { date : Date ; message : string ; } interface IDataService1 { getData () : any ; } let service1 : IDataService1 ; const response = service1 . getData (); response . a . b . c . d ; // RUNTIME ERROR // ----- compare with ------- interface IDataService2 { getData () : unknown ; // ooo } let service2 : IDataService2 ; const response2 = service2 . getData (); // response2.a.b.c.d; // COMPILE TIME ERROR if you do this if ( typeof response === \"string\" ) { console . log ( response . toUpperCase ()); // `response` now has type 'string' } TODO: blame this change. Don't know what this should've done You can also assert a type, or use a type guard against an unknown type. This is better than resorting to any . Project References Project references allow TypeScript projects to depend on other TypeScript projects \u2013 specifically, allowing tsconfig.json files to reference other tsconfig.json files. This lets large codebases scale without recompiling every part of the codebase every time, by breaking it up into multiple projects. In each folder, create a tsconfig.json that includes at least: { \"compilerOptions\" : { \"composite\" : true , // tells TSC it is a subproject of a larger project \"declaration\" : true , // emit .d.ts declaration files since project references dont have access to source ts files. important for project references to work! \"declarationMap\" : true , // sourcemaps for .d.ts \"rootDir\" : \".\" // specify compile it relative to root project at . }, \"include\" : [ \"./**/*.ts\" ], \"references\" : [ // (optional) array of subprojects your subproject depends on { \"path\" : \"../myreferencedproject\" , // must have tsconfig.json \"prepend\" : true // concatenate js and sourcemaps generated by this subproject, if and only if using outFile } ] } and the root tsconfig.json that references top level subproject: { \"files\" : [], \"references\" : [{ \"path\" : \"./proj1\" }, { \"path\" : \"./proj2\" }] } and you must run tsc --build or tsc -b . To save the tsconfig boilerplate, you can use the extends option: { \"extends\" : \"../tsconfig.base\" // more stuff here }","title":"TypeScript 3.0"},{"location":"pages/react/typescript/advanced/patterns_by_version/#typescript-31","text":"[ Release Notes | Blog Post ] Properties declarations on functions Attaching properties to functions like this \"just works\" now: export const FooComponent = ({ name }) => < div > Hello ! I am { name } < /div>; FooComponent . defaultProps = { name : \"swyx\" , };","title":"TypeScript 3.1"},{"location":"pages/react/typescript/advanced/patterns_by_version/#typescript-32","text":"[ Release Notes | Blog Post ] nothing specifically React related.","title":"TypeScript 3.2"},{"location":"pages/react/typescript/advanced/patterns_by_version/#typescript-33","text":"[ Release Notes | Blog Post ] nothing specifically React related.","title":"TypeScript 3.3"},{"location":"pages/react/typescript/advanced/patterns_by_version/#typescript-34","text":"[ Release Notes | Blog Post ] const assertions function useLoading () { const [ isLoading , setState ] = useState ( false ); const load = ( aPromise : Promise < any > ) => { setState ( true ); return aPromise . finally (() => setState ( false )); }; return [ isLoading , load ] as const ; // infers [boolean, typeof load] instead of (boolean | typeof load)[] } More info on places you can use const assertions .","title":"TypeScript 3.4"},{"location":"pages/react/typescript/advanced/patterns_by_version/#typescript-35","text":"[ Release Notes | Blog Post ] Built-in <Omit> Type!! Higher order type inference from generic constructors type ComponentClass < P > = new ( props : P ) => Component < P > ; declare class Component < P > { props : P ; constructor ( props : P ); } declare function myHoc < P > ( C : ComponentClass < P > ) : ComponentClass < P > ; type NestedProps < T > = { foo : number ; stuff : T }; declare class GenericComponent < T > extends Component < NestedProps < T >> {} // type is 'new <T>(props: NestedProps<T>) => Component<NestedProps<T>>' const GenericComponent2 = myHoc ( GenericComponent ); See also Notes from Google upgrading to 3.5","title":"TypeScript 3.5"},{"location":"pages/react/typescript/advanced/patterns_by_version/#typescript-36","text":"[ Release Notes | Blog Post ] Nothing particularly React specific but the playground got an upgrade and Ambient Classes and Functions Can Merge","title":"TypeScript 3.6"},{"location":"pages/react/typescript/advanced/patterns_by_version/#typescript-37","text":"[ Release Notes | Blog Post ] Optional Chaining let x = foo ? . bar . baz (); // is equivalent to let x = foo === null || foo === undefined ? undefined : foo.bar.baz (); // Optional Element access function tryGetFirstElement < T > ( arr? : T []) { return arr ? .[ 0 ]; } // Optional Call async function makeRequest ( url : string , log ?: ( msg : string ) => void ) { log ? .( `Request started at ${ new Date (). toISOString () } ` ); const result = ( await fetch ( url )). json (); log ? .( `Request finished at at ${ new Date (). toISOString () } ` ); return result ; } Nullish Coalescing let x = foo ?? bar (); // equivalent to let x = foo !== null && foo !== undefined ? foo : bar (); YOU SHOULD USUALLY USE ?? WHEREVER YOU NORMALLY USE || unless you truly mean falsiness: function ShowNumber ({ value } : { value : number }) { let _value = value || 0.5 ; // will replace 0 with 0.5 even if user really means 0 // etc... } Assertion Functions function assert ( condition : any , msg? : string ) : asserts condition { if ( ! condition ) { throw new AssertionError ( msg ); } } function yell ( str ) { assert ( typeof str === \"string\" ); return str . toUppercase (); // ~~~~~~~~~~~ // error: Property 'toUppercase' does not exist on type 'string'. // Did you mean 'toUpperCase'? } You can also assert without a custom function: function assertIsString ( val : any ) : asserts val is string { if ( typeof val !== \"string\" ) { throw new AssertionError ( \"Not a string!\" ); } } function yell ( str : any ) { assertIsString ( str ); // Now TypeScript knows that 'str' is a 'string'. return str . toUppercase (); // ~~~~~~~~~~~ // error: Property 'toUppercase' does not exist on type 'string'. // Did you mean 'toUpperCase'? } ts-nocheck You can now add // @ts-nocheck to the top of TypeScript files! good for migrations.","title":"TypeScript 3.7"},{"location":"pages/react/typescript/advanced/patterns_by_version/#typescript-38","text":"[ Release Notes | Blog Post ] Type-Only Imports and Exports import type { SomeThing } from \"./some-module.js\" ; export type { SomeThing }; ECMAScript Private Fields Not really React specific but ok Bloomberg export * as ns Syntax This is ES2020 syntax. Instead of import * as utilities from \"./utilities.js\" ; export { utilities }; you can do export * as utilities from \"./utilities.js\" ; Top-Level await not React specific but gj Myles JSDoc Property Modifiers handy for JSDoc users - @public, @private, @protected, @readonly Better Directory Watching on Linux and watchOptions \u201cFast and Loose\u201d Incremental Checking assumeChangesOnlyAffectDirectDependencies reduces build times for extremely large codebases.","title":"TypeScript 3.8"},{"location":"pages/react/typescript/advanced/patterns_by_version/#typescript-39","text":"[ Release Notes | Blog Post ] (minor feature) New ts-expect-error directive. Use this when writing tests you expect to error. // @ts-expect-error console . log ( 47 * \"octopus\" ); Pick ts-expect-error if: you\u2019re writing test code where you actually want the type system to error on an operation you expect a fix to be coming in fairly quickly and you just need a quick workaround you\u2019re in a reasonably-sized project with a proactive team that wants to remove suppression comments as soon affected code is valid again Pick ts-ignore if: you have an a larger project and and new errors have appeared in code with no clear owner you are in the middle of an upgrade between two different versions of TypeScript, and a line of code errors in one version but not another. you honestly don\u2019t have the time to decide which of these options is better. } and > are Now Invalid JSX Text Characters They were always invalid, but now TypeScript and Babel are enforcing it: Unexpected token. Did you mean `{'>'}` or `&gt;`? Unexpected token. Did you mean `{'}'}` or `&rbrace;`? You can convert these in bulk if needed.","title":"TypeScript 3.9"},{"location":"pages/react/typescript/advanced/patterns_by_version/#typescript-40","text":"[ Release Notes | Blog Post ] Variadic Tuple Types useful for simplified Reducer-like State Custom JSX Factories It's for custom pragmas with Preact // Note: these pragma comments need to be written // with a JSDoc-style multiline syntax to take effect. /** @jsx h */ /** @jsxFrag Fragment */ import { h , Fragment } from \"preact\" ; let stuff = ( <> < div > Hello < /div> < /> ); // transformed to let stuff = h ( Fragment , null , h ( \"div\" , null , \"Hello\" ));","title":"TypeScript 4.0"},{"location":"pages/react/typescript/advanced/patterns_by_version/#typescript-41","text":"[ Release Notes | Blog Post ] Template Literal Types This is a HUGE feature. Usecase 1 - Generating string literal types from permutations of other string literal types: type VerticalAlignment = \"top\" | \"middle\" | \"bottom\" ; type HorizontalAlignment = \"left\" | \"center\" | \"right\" ; // Takes // | \"top-left\" | \"top-center\" | \"top-right\" // | \"middle-left\" | \"middle-center\" | \"middle-right\" // | \"bottom-left\" | \"bottom-center\" | \"bottom-right\" declare function setAlignment ( value : ` ${ VerticalAlignment } - ${ HorizontalAlignment } ` ) : void ; setAlignment ( \"top-left\" ); // works! setAlignment ( \"top-middel\" ); // error! setAlignment ( \"top-pot\" ); // error! but good doughnuts if you're ever in Seattle Usecase 2 - Modeling dynaming string literal types: type PropEventSource < T > = { on ( eventName : ` ${ string & keyof T } Changed` , callback : () => void ) : void ; }; /// Create a \"watched object\" with an 'on' method /// so that you can watch for changes to properties. declare function makeWatchedObject < T > ( obj : T ) : T & PropEventSource < T > ; To make string manipulation easier there are new generics: Uppercase , Lowercase , Capitalize and Uncapitalize . You can combine it with the infer keyword like this : type ParseRouteParams < Rte > = Rte extends ` ${ string } /: ${ infer P } ` ? P : never ; type Params = ParseRouteParams < \"/api/user/:userID\" > ; // Params is \"userID\" type NoParams = ParseRouteParams < \"/api/user\" > ; // NoParams is never --> no params! This feature is extremely flexible, see other usecase ideas here: https://hasura.io/blog/how-typescript-template-literal-types-helped-us-with-multiple-database-support/ https://github.com/ghoullier/awesome-template-literal-types React 17 jsx Factories This is a new compiler option to offer output inline with React 17 support in general: // ./src/tsconfig.json - for production { \"compilerOptions\" : { \"module\" : \"esnext\" , \"target\" : \"es2015\" , \"jsx\" : \"react-jsx\" , \"strict\" : true }, \"include\" : [ \"./**/*\" ] } // ./src/tsconfig.dev.json - for development - extending the production config { \"extends\" : \"./tsconfig.json\" , \"compilerOptions\" : { \"jsx\" : \"react-jsxdev\" } } Misc Key Remapping in Mapped Types Recursive Conditional Types Checked Indexed Accesses","title":"TypeScript 4.1"},{"location":"pages/react/typescript/advanced/patterns_by_version/#typescript-42","text":"[ Release Notes | Blog Post ] nothing react specific","title":"TypeScript 4.2"},{"location":"pages/react/typescript/advanced/patterns_by_version/#typescript-43","text":"[ Release Notes | Blog Post ] nothing react specific","title":"TypeScript 4.3"},{"location":"pages/react/typescript/advanced/patterns_by_version/#typescript-44","text":"[ Release Notes | Blog Post ] nothing react specific","title":"TypeScript 4.4"},{"location":"pages/react/typescript/advanced/patterns_by_version/#typescript-45","text":"[ Release Notes | Blog Post ] (minor VSCode improvement) Snippet Completions for JSX Attributes","title":"TypeScript 4.5"},{"location":"pages/react/typescript/advanced/patterns_by_version/#typescript-46","text":"[ Release Notes | Blog Post ] (extremely minor) Removed Unnecessary Arguments in react-jsx compile output","title":"TypeScript 4.6"},{"location":"pages/react/typescript/advanced/patterns_by_version/#typescript-roadmap-and-spec","text":"https://github.com/Microsoft/TypeScript/wiki/Roadmap Did you also know you can read the TypeScript spec online?? https://github.com/microsoft/TypeScript/blob/master/doc/spec-ARCHIVED.md","title":"TypeScript Roadmap and Spec"},{"location":"pages/react/typescript/advanced/types-react-ap/","text":"The @types typings export both \"public\" types meant for your use as well as \"private\" types that are for internal use. Check SaltyCrane's React TypeScript Cheatsheet for a nice autogenerated complete reference. @types/react Link to .d.ts Namespace: React Most Commonly Used Interfaces and Types ReactNode - anything that is renderable inside of JSX, this is NOT the same as what can be rendered by a component! Component - base class of all class-based components PureComponent - base class for all class-based optimized components FC , FunctionComponent - a complete interface for function components, often used to type external components instead of typing your own CSSProperties - used to type style objects all events: used to type event handlers all event handlers: used to type event handlers all consts: Children , Fragment , ... are all public and reflect the React runtime namespace Not Commonly Used but Good to know Ref - used to type innerRef ElementType - used for higher order components or operations on components, e.g. Polymorphic Components ReactElement - can be used if you want to pass it to cloneElement aka it's pretty rarely used ComponentType - used for higher order components where you don't specifically deal with the intrinsic components ReactPortal - used if you specifically need to type a prop as a portal, otherwise it is part of ReactNode ComponentClass - a complete interface for the produced constructor function of a class declaration that extends Component , often used to type external components instead of typing your own JSXElementConstructor - anything that TypeScript considers to be a valid thing that can go into the opening tag of a JSX expression ComponentProps - props of a component - most useful for Wrapping/Mirroring a HTML Element ComponentPropsWithRef - props of a component where if it is a class-based component it will replace the ref prop with its own instance type ComponentPropsWithoutRef - props of a component without its ref prop HTMLProps and HTMLAttributes - these are the most generic versions, for global attributes (see a list of attributes marked as \"global attribute\" on MDN ). In general, prefer React.ComponentProps , JSX.IntrinsicElements , or specialized HTMLAttributes interfaces : List of specialized HTMLAttributes Note that there are about 50 of these, which means there are some HTML elements which are not covered. - `AnchorHTMLAttributes` - `AudioHTMLAttributes` - `AreaHTMLAttributes` - `BaseHTMLAttributes` - `BlockquoteHTMLAttributes` - `ButtonHTMLAttributes` - `CanvasHTMLAttributes` - `ColHTMLAttributes` - `ColgroupHTMLAttributes` - `DataHTMLAttributes` - `DetailsHTMLAttributes` - `DelHTMLAttributes` - `DialogHTMLAttributes` - `EmbedHTMLAttributes` - `FieldsetHTMLAttributes` - `FormHTMLAttributes` - `HtmlHTMLAttributes` - `IframeHTMLAttributes` - `ImgHTMLAttributes` - `InsHTMLAttributes` - `InputHTMLAttributes` - `KeygenHTMLAttributes` - `LabelHTMLAttributes` - `LiHTMLAttributes` - `LinkHTMLAttributes` - `MapHTMLAttributes` - `MenuHTMLAttributes` - `MediaHTMLAttributes` - `MetaHTMLAttributes` - `MeterHTMLAttributes` - `QuoteHTMLAttributes` - `ObjectHTMLAttributes` - `OlHTMLAttributes` - `OptgroupHTMLAttributes` - `OptionHTMLAttributes` - `OutputHTMLAttributes` - `ParamHTMLAttributes` - `ProgressHTMLAttributes` - `SlotHTMLAttributes` - `ScriptHTMLAttributes` - `SelectHTMLAttributes` - `SourceHTMLAttributes` - `StyleHTMLAttributes` - `TableHTMLAttributes` - `TextareaHTMLAttributes` - `TdHTMLAttributes` - `ThHTMLAttributes` - `TimeHTMLAttributes` - `TrackHTMLAttributes` - `VideoHTMLAttributes` - `WebViewHTMLAttributes` all methods: createElement , cloneElement , ... are all public and reflect the React runtime API @Ferdaber's note : I discourage the use of most ...Element types because of how black-boxy JSX.Element is. You should almost always assume that anything produced by React.createElement is the base type React.ReactElement . Namespace: JSX Element - the type of any JSX expression. You should ideally never need to see or use this, but you do because of a limitation of TypeScript . LibraryManagedAttributes - It specifies other places where JSX elements can declare and initialize property types. Used to resolve static defaultProps and propTypes with the internal props type of a component. IntrinsicElements - every possible built-in component that can be typed in as a lowercase tag name in JSX. If you're using this to get the attributes for a HTML element, React.ComponentProps<element> may be more readable as it doesn't require knowing what \"Intrinsic\" means. Not commonly used but good to know IntrinsicAttributes set of attributes that all IntrinsicElements support... basically just key . ElementChildrenAttribute name of property that TS looks at to figure out what types of children a component supports. Basically the children property ElementAttributesProperty name of property that TS looks at to figure out what attributes a component supports. Basically the props property (for a class instance) Don't use/Internal/Deprecated Anything not listed above is considered an internal type and not public. If you're not sure you can check out the source of @types/react . The types are annotated accordingly. SFCElement SFC ComponentState LegacyRef StatelessComponent ReactType Adding non-standard attributes The attributes allowed on host components such as button or img follow the HTML living standard . New features that are not yet part of the living standard or are only implemented by certain browsers will therefore cause a type error. If you specifically write code for these browsers or polyfill these attributes you can use module augmentation to still get those components type checked without having to use any or @ts-ignore . In this example we'll add the loading attribute which adds support for lazy-loading images on Chrome: // react-unstable-attributes.d.ts import \"react\" ; declare module \"react\" { interface ImgHTMLAttributes < T > extends HTMLAttributes < T > { loading ?: \"auto\" | \"eager\" | \"lazy\" ; } } @types/react-dom To be written","title":"@types"},{"location":"pages/react/typescript/advanced/types-react-ap/#typesreact","text":"Link to .d.ts Namespace: React Most Commonly Used Interfaces and Types ReactNode - anything that is renderable inside of JSX, this is NOT the same as what can be rendered by a component! Component - base class of all class-based components PureComponent - base class for all class-based optimized components FC , FunctionComponent - a complete interface for function components, often used to type external components instead of typing your own CSSProperties - used to type style objects all events: used to type event handlers all event handlers: used to type event handlers all consts: Children , Fragment , ... are all public and reflect the React runtime namespace Not Commonly Used but Good to know Ref - used to type innerRef ElementType - used for higher order components or operations on components, e.g. Polymorphic Components ReactElement - can be used if you want to pass it to cloneElement aka it's pretty rarely used ComponentType - used for higher order components where you don't specifically deal with the intrinsic components ReactPortal - used if you specifically need to type a prop as a portal, otherwise it is part of ReactNode ComponentClass - a complete interface for the produced constructor function of a class declaration that extends Component , often used to type external components instead of typing your own JSXElementConstructor - anything that TypeScript considers to be a valid thing that can go into the opening tag of a JSX expression ComponentProps - props of a component - most useful for Wrapping/Mirroring a HTML Element ComponentPropsWithRef - props of a component where if it is a class-based component it will replace the ref prop with its own instance type ComponentPropsWithoutRef - props of a component without its ref prop HTMLProps and HTMLAttributes - these are the most generic versions, for global attributes (see a list of attributes marked as \"global attribute\" on MDN ). In general, prefer React.ComponentProps , JSX.IntrinsicElements , or specialized HTMLAttributes interfaces : List of specialized HTMLAttributes Note that there are about 50 of these, which means there are some HTML elements which are not covered. - `AnchorHTMLAttributes` - `AudioHTMLAttributes` - `AreaHTMLAttributes` - `BaseHTMLAttributes` - `BlockquoteHTMLAttributes` - `ButtonHTMLAttributes` - `CanvasHTMLAttributes` - `ColHTMLAttributes` - `ColgroupHTMLAttributes` - `DataHTMLAttributes` - `DetailsHTMLAttributes` - `DelHTMLAttributes` - `DialogHTMLAttributes` - `EmbedHTMLAttributes` - `FieldsetHTMLAttributes` - `FormHTMLAttributes` - `HtmlHTMLAttributes` - `IframeHTMLAttributes` - `ImgHTMLAttributes` - `InsHTMLAttributes` - `InputHTMLAttributes` - `KeygenHTMLAttributes` - `LabelHTMLAttributes` - `LiHTMLAttributes` - `LinkHTMLAttributes` - `MapHTMLAttributes` - `MenuHTMLAttributes` - `MediaHTMLAttributes` - `MetaHTMLAttributes` - `MeterHTMLAttributes` - `QuoteHTMLAttributes` - `ObjectHTMLAttributes` - `OlHTMLAttributes` - `OptgroupHTMLAttributes` - `OptionHTMLAttributes` - `OutputHTMLAttributes` - `ParamHTMLAttributes` - `ProgressHTMLAttributes` - `SlotHTMLAttributes` - `ScriptHTMLAttributes` - `SelectHTMLAttributes` - `SourceHTMLAttributes` - `StyleHTMLAttributes` - `TableHTMLAttributes` - `TextareaHTMLAttributes` - `TdHTMLAttributes` - `ThHTMLAttributes` - `TimeHTMLAttributes` - `TrackHTMLAttributes` - `VideoHTMLAttributes` - `WebViewHTMLAttributes` all methods: createElement , cloneElement , ... are all public and reflect the React runtime API @Ferdaber's note : I discourage the use of most ...Element types because of how black-boxy JSX.Element is. You should almost always assume that anything produced by React.createElement is the base type React.ReactElement . Namespace: JSX Element - the type of any JSX expression. You should ideally never need to see or use this, but you do because of a limitation of TypeScript . LibraryManagedAttributes - It specifies other places where JSX elements can declare and initialize property types. Used to resolve static defaultProps and propTypes with the internal props type of a component. IntrinsicElements - every possible built-in component that can be typed in as a lowercase tag name in JSX. If you're using this to get the attributes for a HTML element, React.ComponentProps<element> may be more readable as it doesn't require knowing what \"Intrinsic\" means. Not commonly used but good to know IntrinsicAttributes set of attributes that all IntrinsicElements support... basically just key . ElementChildrenAttribute name of property that TS looks at to figure out what types of children a component supports. Basically the children property ElementAttributesProperty name of property that TS looks at to figure out what attributes a component supports. Basically the props property (for a class instance) Don't use/Internal/Deprecated Anything not listed above is considered an internal type and not public. If you're not sure you can check out the source of @types/react . The types are annotated accordingly. SFCElement SFC ComponentState LegacyRef StatelessComponent ReactType","title":"@types/react"},{"location":"pages/react/typescript/advanced/types-react-ap/#adding-non-standard-attributes","text":"The attributes allowed on host components such as button or img follow the HTML living standard . New features that are not yet part of the living standard or are only implemented by certain browsers will therefore cause a type error. If you specifically write code for these browsers or polyfill these attributes you can use module augmentation to still get those components type checked without having to use any or @ts-ignore . In this example we'll add the loading attribute which adds support for lazy-loading images on Chrome: // react-unstable-attributes.d.ts import \"react\" ; declare module \"react\" { interface ImgHTMLAttributes < T > extends HTMLAttributes < T > { loading ?: \"auto\" | \"eager\" | \"lazy\" ; } }","title":"Adding non-standard attributes"},{"location":"pages/react/typescript/advanced/types-react-ap/#typesreact-dom","text":"To be written","title":"@types/react-dom"},{"location":"pages/react/typescript/advanced/utility-types/","text":"We will assume knowledge of utility types covered in the sister project typescript-cheatsheets/utilities . Look up libraries included there as well for your typing needs. If you intend to maintain a large TS codebase/a nontrivial React+TS library, we strongly recommend exploring these utilities so that you don't reinvent the wheel and/or lose sanity trying to do so. Studying their code can also teach you a lot of advanced TS that is not covered here. I also recommend have a good working knowledge of how to construct the inbuilt utility types from scratch. See Dr. Rauschmayer's guide for a concise introduction. A level of comfort with generic types is therefore required. Here are some helpful resources: https://ts.chibicode.com/generics/","title":"Utility Types"},{"location":"pages/react/typescript/basic/editor-integration/","text":"VSCode swyx's VSCode Extension: https://github.com/sw-yx/swyx-react-typescript-snippets amVim: https://marketplace.visualstudio.com/items?itemName=auiworks.amvim VIM https://github.com/Quramy/tsuquyomi nvim-typescript? https://github.com/leafgarland/typescript-vim peitalin/vim-jsx-typescript NeoVim: https://github.com/neoclide/coc.nvim other discussion: https://mobile.twitter.com/ryanflorence/status/1085715595994095620 You are free to use this repo's TSX logo if you wish: You may also wish to use alternative logos - jsx-tsx-logos","title":"Editor Tooling"},{"location":"pages/react/typescript/basic/examples/","text":"Create React App TypeScript Todo Example 2021 Ben Awad's 14 hour Fullstack React/GraphQL/TypeScript Tutorial Cypress Realworld App","title":"Example App"},{"location":"pages/react/typescript/basic/linting/","text":"\u26a0\ufe0fNote that TSLint is now in maintenance and you should try to use ESLint instead . If you are interested in TSLint tips, please check this PR from @azdanov . The rest of this section just focuses on ESLint. You can convert TSlint to ESlint with this tool . \u26a0\ufe0fThis is an evolving topic. typescript-eslint-parser is no longer maintained and work has recently begun on typescript-eslint in the ESLint community to bring ESLint up to full parity and interop with TSLint. Follow the TypeScript + ESLint docs at https://github.com/typescript-eslint/typescript-eslint: yarn add -D @typescript-eslint/eslint-plugin @typescript-eslint/parser eslint add a lint script to your package.json : \"scripts\" : { \"lint\" : \"eslint 'src/**/*.ts'\" }, and a suitable .eslintrc.js (using .js over .json here so we can add comments): module . exports = { env : { es6 : true , node : true , jest : true , }, extends : \"eslint:recommended\" , parser : \"@typescript-eslint/parser\" , plugins : [ \"@typescript-eslint\" ], parserOptions : { ecmaVersion : 2017 , sourceType : \"module\" , }, rules : { indent : [ \"error\" , 2 ], \"linebreak-style\" : [ \"error\" , \"unix\" ], quotes : [ \"error\" , \"single\" ], \"no-console\" : \"warn\" , \"no-unused-vars\" : \"off\" , \"@typescript-eslint/no-unused-vars\" : [ \"error\" , { vars : \"all\" , args : \"after-used\" , ignoreRestSiblings : false }, ], \"@typescript-eslint/explicit-function-return-type\" : \"warn\" , // Consider using explicit annotations for object literals and function return types even when they can be inferred. \"no-empty\" : \"warn\" , }, }; Most of this is taken from the tsdx PR which is for libraries . More .eslintrc.json options to consider with more options you may want for apps : { \"extends\" : [ \"airbnb\" , \"prettier\" , \"prettier/react\" , \"plugin:prettier/recommended\" , \"plugin:jest/recommended\" , \"plugin:unicorn/recommended\" ], \"plugins\" : [ \"prettier\" , \"jest\" , \"unicorn\" ], \"parserOptions\" : { \"sourceType\" : \"module\" , \"ecmaFeatures\" : { \"jsx\" : true } }, \"env\" : { \"es6\" : true , \"browser\" : true , \"jest\" : true }, \"settings\" : { \"import/resolver\" : { \"node\" : { \"extensions\" : [ \".js\" , \".jsx\" , \".ts\" , \".tsx\" ] } } }, \"overrides\" : [ { \"files\" : [ \"**/*.ts\" , \"**/*.tsx\" ], \"parser\" : \"typescript-eslint-parser\" , \"rules\" : { \"no-undef\" : \"off\" } } ] } You can read a fuller TypeScript + ESLint setup guide here from Matterhorn, in particular check https://github.com/MatterhornDev/learn-typescript-linting. Another great resource is \"Using ESLint and Prettier in a TypeScript Project\" by @robertcoopercode. Wes Bos is also working on TypeScript support for his eslint+prettier config. If you're looking for information on Prettier, check out the Prettier guide.","title":"Linting"},{"location":"pages/react/typescript/basic/setup/","text":"Prerequisites good understanding of React familiarity with TypeScript Types ( 2ality's guide is helpful. If you\u2019re an absolute beginner in TypeScript, check out chibicode\u2019s tutorial .) having read the TypeScript section in the official React docs . having read the React section of the new TypeScript playground (optional: also step through the 40+ examples under the playground's Examples section) This guide will always assume you are starting with the latest TypeScript and React versions. Notes for older versions will be in expandable <details> tags. VS Code Extensions refactoring help https://marketplace.visualstudio.com/items?itemName=paulshen.paul-typescript-toolkit R+TS Code Snippets (there are a few...) https://marketplace.visualstudio.com/items?itemName=infeng.vscode-react-typescript https://www.digitalocean.com/community/tutorials/the-best-react-extension-for-vs-code TypeScript official extension https://code.visualstudio.com/docs/languages/typescript React + TypeScript Starter Kits Cloud setups: TypeScript Playground with React just if you are debugging types (and reporting issues), not for running code CodeSandbox - cloud IDE, boots up super fast Stackblitz - cloud IDE, boots up super fast Local dev setups: Next.js : npx create-next-app -e with-typescript will create in your current folder Create React App : npx create-react-app name-of-app --template typescript will create in new folder Vite : npm create vite@latest my-react-ts-app -- --template react-ts Meteor : meteor create --typescript name-of-my-new-typescript-app Ignite for React Native: ignite new myapp TSDX : npx tsdx create mylib for Creating React+TS libraries . (in future: TurboRepo ) Other tools Less mature tools still worth checking out: - [Snowpack]( ): `npx create-snowpack-app my-app --template app-template-react-typescript` - [Docusaurus v2](https://v2.docusaurus.io/docs/installation) with [TypeScript Support](https://v2.docusaurus.io/docs/typescript-support) - [Parcel](https://v2.parceljs.org/languages/typescript/) - [JP Morgan's `modular`](https://github.com/jpmorganchase/modular): CRA + TS + Yarn Workspaces toolkit. `yarn create modular-react-app ` Manual setup: - [Basarat's guide](https://github.com/basarat/typescript-react/tree/master/01%20bootstrap) for **manual setup** of React + TypeScript + Webpack + Babel - In particular, make sure that you have `@types/react` and `@types/react-dom` installed ([Read more about the DefinitelyTyped project if you are unfamiliar](https://definitelytyped.org/)) - There are also many React + TypeScript boilerplates, please see [our Other Resources list](https://react-typescript-cheatsheet.netlify.app/docs/basic/recommended/resources/). Video Tutorial Have a look at the 7-part \"React Typescript Course\" video series below for an introduction to TypeScript with React.","title":"Setup in React"},{"location":"pages/react/typescript/basic/setup/#prerequisites","text":"good understanding of React familiarity with TypeScript Types ( 2ality's guide is helpful. If you\u2019re an absolute beginner in TypeScript, check out chibicode\u2019s tutorial .) having read the TypeScript section in the official React docs . having read the React section of the new TypeScript playground (optional: also step through the 40+ examples under the playground's Examples section) This guide will always assume you are starting with the latest TypeScript and React versions. Notes for older versions will be in expandable <details> tags.","title":"Prerequisites"},{"location":"pages/react/typescript/basic/setup/#vs-code-extensions","text":"refactoring help https://marketplace.visualstudio.com/items?itemName=paulshen.paul-typescript-toolkit R+TS Code Snippets (there are a few...) https://marketplace.visualstudio.com/items?itemName=infeng.vscode-react-typescript https://www.digitalocean.com/community/tutorials/the-best-react-extension-for-vs-code TypeScript official extension https://code.visualstudio.com/docs/languages/typescript","title":"VS Code Extensions"},{"location":"pages/react/typescript/basic/setup/#react-typescript-starter-kits","text":"Cloud setups: TypeScript Playground with React just if you are debugging types (and reporting issues), not for running code CodeSandbox - cloud IDE, boots up super fast Stackblitz - cloud IDE, boots up super fast Local dev setups: Next.js : npx create-next-app -e with-typescript will create in your current folder Create React App : npx create-react-app name-of-app --template typescript will create in new folder Vite : npm create vite@latest my-react-ts-app -- --template react-ts Meteor : meteor create --typescript name-of-my-new-typescript-app Ignite for React Native: ignite new myapp TSDX : npx tsdx create mylib for Creating React+TS libraries . (in future: TurboRepo ) Other tools Less mature tools still worth checking out: - [Snowpack]( ): `npx create-snowpack-app my-app --template app-template-react-typescript` - [Docusaurus v2](https://v2.docusaurus.io/docs/installation) with [TypeScript Support](https://v2.docusaurus.io/docs/typescript-support) - [Parcel](https://v2.parceljs.org/languages/typescript/) - [JP Morgan's `modular`](https://github.com/jpmorganchase/modular): CRA + TS + Yarn Workspaces toolkit. `yarn create modular-react-app ` Manual setup: - [Basarat's guide](https://github.com/basarat/typescript-react/tree/master/01%20bootstrap) for **manual setup** of React + TypeScript + Webpack + Babel - In particular, make sure that you have `@types/react` and `@types/react-dom` installed ([Read more about the DefinitelyTyped project if you are unfamiliar](https://definitelytyped.org/)) - There are also many React + TypeScript boilerplates, please see [our Other Resources list](https://react-typescript-cheatsheet.netlify.app/docs/basic/recommended/resources/).","title":"React + TypeScript Starter Kits"},{"location":"pages/react/typescript/basic/setup/#video-tutorial","text":"Have a look at the 7-part \"React Typescript Course\" video series below for an introduction to TypeScript with React.","title":"Video Tutorial"},{"location":"pages/react/typescript/basic/useful-hooks/","text":"Useful hooks to have with their TypeScript types :) \u26a0\ufe0f This is a VERY new document - contributions are welcome! Other useful resources: https://usehooks.com/ https://usehooks-typescript.com/ useLocalStorage Persist useState in localstorage. import { useState } from \"react\" ; // Usage function App () { // Similar to useState but first arg is key to the value in local storage. const [ name , setName ] = useLocalStorage < string > ( \"name\" , \"Bob\" ); return ( < div > < input type = \"text\" placeholder = \"Enter your name\" value = { name } onChange = {( e ) => setName ( e . target . value )} /> < /div> ); } // Hook function useLocalStorage < T > ( key : string , initialValue : T ) : [ T , ( value : T | (( val : T ) => T )) => void ] { // State to store our value // Pass initial state function to useState so logic is only executed once const [ storedValue , setStoredValue ] = useState < T > (() => { try { // Get from local storage by key const item = window . localStorage . getItem ( key ); // Parse stored json or if none return initialValue return item ? JSON . parse ( item ) : initialValue ; } catch ( error ) { // If error also return initialValue console . log ( error ); return initialValue ; } }); // Return a wrapped version of useState's setter function that ... // ... persists the new value to localStorage. const setValue = ( value : T | (( val : T ) => T )) => { try { // Allow value to be a function so we have same API as useState const valueToStore = value instanceof Function ? value ( storedValue ) : value ; // Save state setStoredValue ( valueToStore ); // Save to local storage window . localStorage . setItem ( key , JSON . stringify ( valueToStore )); } catch ( error ) { // A more advanced implementation would handle the error case console . log ( error ); } }; return [ storedValue , setValue ]; } useMedia Media queries in JS import { useState , useEffect } from 'react' ; function App () { const columnCount = useMedia < number > ( // Media queries [ '(min-width: 1500px)' , '(min-width: 1000px)' , '(min-width: 600px)' ], // Column counts (relates to above media queries by array index) [ 5 , 4 , 3 ], // Default column count 2 ); // Create array of column heights (start at 0) let columnHeights = new Array ( columnCount ). fill ( 0 ); // Create array of arrays that will hold each column's items let columns = new Array ( columnCount ). fill (). map (() => []) as Array < DataProps [] > ; ( data as DataProps []). forEach ( item => { // Get index of shortest column const shortColumnIndex = columnHeights . indexOf ( Math . min (... columnHeights )); // Add item columns [ shortColumnIndex ]. push ( item ); // Update height columnHeights [ shortColumnIndex ] += item . height ; }); // Render columns and items return ( < div className = \"App\" > < div className = \"columns is-mobile\" > { columns . map ( column => ( < div className = \"column\" > { column . map ( item => ( < div className = \"image-container\" style = {{ // Size image container to aspect ratio of image paddingTop : ( item . height / item . width ) * 100 + '%' }} > < img src = { item . image } alt = \"\" /> < /div> ))} < /div> ))} < /div> < /div> ); } // Hook const useMedia = < T > ( queries : string [], values : T [], defaultValue : T ) => { // Array containing a media query list for each query const mediaQueryLists = queries . map ( q => window . matchMedia ( q )); // Function that gets value based on matching media query const getValue = () => { // Get index of first media query that matches const index = mediaQueryLists . findIndex ( mql => mql . matches ); // Return related value or defaultValue if none return values ? .[ index ] || defaultValue ; }; // State and setter for matched value const [ value , setValue ] = useState < T > ( getValue ); useEffect ( () => { // Event listener callback // Note: By defining getValue outside of useEffect we ensure that it has ... // ... current values of hook args (as this hook callback is created once on mount). const handler = () => setValue ( getValue ); // Set a listener for each media query with above handler as callback. mediaQueryLists . forEach ( mql => mql . addListener ( handler )); // Remove listeners on cleanup return () => mediaQueryLists . forEach ( mql => mql . removeListener ( handler )); }, [] // Empty array ensures effect is only run on mount and unmount ); return value ; } useAsyncTask This Hook is designed for users to make async calls and also know the current state of the request. thanks to Adnan S Husain for contributing ! Example implementation // Usage const task = useAsyncTask ( async ( data : any ) => await myApiRequest ( data )); task . run ( data ); useEffect (() => { console . log ( task . status ); // 'IDLE' | 'PROCESSING' | 'ERROR' | 'SUCCESS'; }, [ task . status ]); // Implementation import { useCallback , useState } from \"react\" ; type TStatus = \"IDLE\" | \"PROCESSING\" | \"ERROR\" | \"SUCCESS\" ; function useAsyncTask < T extends any [], R = any > ( task : ( ...args : T ) => Promise < R > ) { const [ status , setStatus ] = useState < TStatus > ( \"IDLE\" ); const [ message , setMessage ] = useState ( \"\" ); const run = useCallback ( async ( ...arg : T ) => { setStatus ( \"PROCESSING\" ); try { const resp : R = await task (... arg ); setStatus ( \"SUCCESS\" ); return resp ; } catch ( error ) { let message = error ? . response ? . data ? . error ? . message || error . message ; setMessage ( message ); setStatus ( \"ERROR\" ); throw error ; } }, []); const reset = useCallback (() => { setMessage ( \"\" ); setStatus ( \"IDLE\" ); }, []); return { run , status , message , reset , }; } export default useAsyncTask ; See also: useAsync . useFetch This Hook is useful to make fetch requests using AbortController Example implementation export function useFetch ( request : RequestInfo , init? : RequestInit ) { const [ response , setResponse ] = useState < null | Response > ( null ); const [ error , setError ] = useState < Error | null > (); const [ isLoading , setIsLoading ] = useState ( true ); useEffect (() => { const abortController = new AbortController (); setIsLoading ( true ); ( async () => { try { const response = await fetch ( request , { ... init , signal : abortController.signal , }); setResponse ( await response ? . json ()); setIsLoading ( false ); } catch ( error ) { if ( isAbortError ( error )) { return ; } setError ( error as any ); setIsLoading ( false ); } })(); return () => { abortController . abort (); }; }, [ init , request ]); return { response , error , isLoading }; } // type guards function isAbortError ( error : any ) : error is DOMException { if ( error && error . name === \"AbortError\" ) { return true ; } return false ; } [See this in TS Playground](https://www.typescriptlang.org/play?&q=400#code/PTAECUFMEMGMBdQEsDOpqgA4HtMFcAbaAJ1AKQCNiSBPUAM21NmJniQDsBzUPFSUp3gD6cSCgB0AWABQIUAElEmYtgBuSACbj0oAFLQ10AMoskmRNAop41BEmwcGTUCzaceGyAHdZ82NgAtjgckBzwaHweugZGpsTmiETceNBckKCQAB7CHCgOTrDQBASQmn5gesYAGtIyFaAAKjSYkPGJoCh4mDjEEfo1ADToHJpYqhraaBgJsAAWnZCI2PQN8C0Z8NjYBGhboLNzBHSB2NoEoHPY3q5BIWH9ARyhCHUNjdi8owI20KOX1yaG3aFlA3iYAGs0N4kPAFlA4IgAsFHA8UA0aNg8KBAtA6N4-pZxkhAgJQI5QOlQrMUAAuCoNAC0mSy0GCpVpVIESFgjPoeA49kc6LkYGZ2TZmA5XNmjNgRBQ-BFDQAYkhiDYwZAAOQlMjbCHoRBXG4ynnIcIiMTTVi8fhjfa4zANBEIW4o0LhSRNOaoZDTBjQPBZRmuxD8wXsRzFd33cL0+oydatUAqoOshAqgVCjgAYTuqPCAB4AAqqTBobK5TRoADeAF8AHygAC8oAAFLJQONcHTQGXe4Mu7dLTkAPy0kY0WQASlbzbTwcRWcjBXzHoeRb+NGbAB9QBxCBd91VagBRUqk8IAblkLqxXCONATIFV6eX2ajeYLnsQfowZqwAwn4FGCvrzAckDkDojgNH82BwmSyaQMMA4VhI-blmgczQHsnwUBkfzkhQABWkBuu2jrQBCGRdKwGJYqAmiONqyi4QGKgkrCSBqJAc5-A6cwZGhewbGCSB6gRDSsIyfBlOgexCQw6qaiQXB4Fef5OIhwGro4byik0nxycg8DDJi2KhPJGAqL2oDIQmshCFasAZAAItAwgiaAtbDqg2AABwAGwAAwAIwecIk42Ak3C3jI3akoqaSQNFtgePF9Z3oZADqGRFNpQmFKwnmEaAkWQOucaIN44ELHJimQA0FXec5xCiK5wwCZB3wavZSmaKVBlPJqFVVYW8CTouGbwCuObjb+RYtVhzZtrZFbzh2w5FuwpJMaVjQkpALa1utkj+cF4UVU2p1YRISUoCl9ZFsAu2QI2s7xe8vpoG4pUBhGOZgTyCx+oB4lwroIkNEYCRWKUwMQTheGgARIzEWRrw+vlP4PLpObSUseDEHkmSwkJpDwYhzC4+E+NfuSpCHiUBnyI0SkIRTsYTaAACCJYKP6ujyuxjIULh8mohhAASAg6tMDT5OySD0Eg8m8RqoErP1nl8wLjkyG1HUZNNiK5gqKALZu3lVmENY+fWwzGPApWtg7za+QlPYVpOInxd2vxRaAzulV9Xv8PAIdB+2KiQGoUepcHLvCMMZ2+1hc4ts2fvDkUJTi7AEITh2mfNmo2BaP7PXaMQ7YzlN74IOb7FW8W257geR6Zdl8gAELkUG-D9X6IuKq4RE4bxqOc5hdndQnoDMrCly4Ws4KUmE3JAWpGloojCwkBkcmCaoeCPliiA6aPkg92A7MZGGZCUNQxB0MiOgwpDsJoNc2lidoqsODcWFA0cgNF+riAyBQPAlhbSBDwBBU4tpkSxyKvkXiGEAAySxtRoCoB4NYVwh5CE+FiUgUo8RcFPv8bq2QpRMDKvQHw3Nfw30TCSXoiAwzDFrHaNoycUJ8LPPQJhbp6wMFUIEUAAAiEqCBpFhzoUwcMIEKRyRVEseY7ZWAAEc8DiEmhASAeiDEKA4IwYYnBYTFygCYmwZjYRzk9t2EaiAADarAUAhH4MMCOUAvHCkgAAXTdnJBORZmbHiMQEvI712yRJnFXVxoA3ECFUMQXxSwzzEHSSEtsYSBFFmyek0A+5ImNjrkk4U7jUCYOwNATQHhMnwAUCgOpDSPB5L4QnSixB9GJOyt2OSwjRHwHbHXTazjuwjlUhQZR+ZwiqBKGSNsoQbi8zmX0BZtgdilFrgMr2AclitPaY07gvT+lV27O2XCNBBQl0mcOaZ9lX4+Sec8mZiBPHeIyG2aABJl5MPgFo3R+ibA8PeR80AEgYVWLMpCj5+QuAcGKJOKw8zHA7OWcQCQSKUUECHIcj59YDlQqOfAfxPybkAq+eIH5Y4JAkRQI4OupKyURxOfUs5XB2yiF2HxK50zxFFGBQsdsaSmCTgFBCDgv8nEIu7CrDsqANnKOKUwcVOSmAznlUSqFrB4DEw4IK55WU9XTIjuq2uErKbTA4DQNlUKOVtK5R4XlxR+COqFe8kllT3kGqNQ8rObzzXoq2ZipZeyJBhrGV6+sVdHYpLhcMUFBigkHOHAGkmPlIIxJ8ZkLVGT-SnOiPG2QZq1hiXUiQGsshAYMxVZs+AVrNXpLRfa+uBaSl+jcgAeQALJniyK5CwoEplKtbS4AAZFOrtTAJAor2i2ZdMjVV9CtdI3Vzys3aT6ZABNmaibZr5fwTKQA)","title":"Useful Hooks"},{"location":"pages/react/typescript/basic/useful-hooks/#uselocalstorage","text":"Persist useState in localstorage. import { useState } from \"react\" ; // Usage function App () { // Similar to useState but first arg is key to the value in local storage. const [ name , setName ] = useLocalStorage < string > ( \"name\" , \"Bob\" ); return ( < div > < input type = \"text\" placeholder = \"Enter your name\" value = { name } onChange = {( e ) => setName ( e . target . value )} /> < /div> ); } // Hook function useLocalStorage < T > ( key : string , initialValue : T ) : [ T , ( value : T | (( val : T ) => T )) => void ] { // State to store our value // Pass initial state function to useState so logic is only executed once const [ storedValue , setStoredValue ] = useState < T > (() => { try { // Get from local storage by key const item = window . localStorage . getItem ( key ); // Parse stored json or if none return initialValue return item ? JSON . parse ( item ) : initialValue ; } catch ( error ) { // If error also return initialValue console . log ( error ); return initialValue ; } }); // Return a wrapped version of useState's setter function that ... // ... persists the new value to localStorage. const setValue = ( value : T | (( val : T ) => T )) => { try { // Allow value to be a function so we have same API as useState const valueToStore = value instanceof Function ? value ( storedValue ) : value ; // Save state setStoredValue ( valueToStore ); // Save to local storage window . localStorage . setItem ( key , JSON . stringify ( valueToStore )); } catch ( error ) { // A more advanced implementation would handle the error case console . log ( error ); } }; return [ storedValue , setValue ]; }","title":"useLocalStorage"},{"location":"pages/react/typescript/basic/useful-hooks/#usemedia","text":"Media queries in JS import { useState , useEffect } from 'react' ; function App () { const columnCount = useMedia < number > ( // Media queries [ '(min-width: 1500px)' , '(min-width: 1000px)' , '(min-width: 600px)' ], // Column counts (relates to above media queries by array index) [ 5 , 4 , 3 ], // Default column count 2 ); // Create array of column heights (start at 0) let columnHeights = new Array ( columnCount ). fill ( 0 ); // Create array of arrays that will hold each column's items let columns = new Array ( columnCount ). fill (). map (() => []) as Array < DataProps [] > ; ( data as DataProps []). forEach ( item => { // Get index of shortest column const shortColumnIndex = columnHeights . indexOf ( Math . min (... columnHeights )); // Add item columns [ shortColumnIndex ]. push ( item ); // Update height columnHeights [ shortColumnIndex ] += item . height ; }); // Render columns and items return ( < div className = \"App\" > < div className = \"columns is-mobile\" > { columns . map ( column => ( < div className = \"column\" > { column . map ( item => ( < div className = \"image-container\" style = {{ // Size image container to aspect ratio of image paddingTop : ( item . height / item . width ) * 100 + '%' }} > < img src = { item . image } alt = \"\" /> < /div> ))} < /div> ))} < /div> < /div> ); } // Hook const useMedia = < T > ( queries : string [], values : T [], defaultValue : T ) => { // Array containing a media query list for each query const mediaQueryLists = queries . map ( q => window . matchMedia ( q )); // Function that gets value based on matching media query const getValue = () => { // Get index of first media query that matches const index = mediaQueryLists . findIndex ( mql => mql . matches ); // Return related value or defaultValue if none return values ? .[ index ] || defaultValue ; }; // State and setter for matched value const [ value , setValue ] = useState < T > ( getValue ); useEffect ( () => { // Event listener callback // Note: By defining getValue outside of useEffect we ensure that it has ... // ... current values of hook args (as this hook callback is created once on mount). const handler = () => setValue ( getValue ); // Set a listener for each media query with above handler as callback. mediaQueryLists . forEach ( mql => mql . addListener ( handler )); // Remove listeners on cleanup return () => mediaQueryLists . forEach ( mql => mql . removeListener ( handler )); }, [] // Empty array ensures effect is only run on mount and unmount ); return value ; }","title":"useMedia"},{"location":"pages/react/typescript/basic/useful-hooks/#useasynctask","text":"This Hook is designed for users to make async calls and also know the current state of the request. thanks to Adnan S Husain for contributing ! Example implementation // Usage const task = useAsyncTask ( async ( data : any ) => await myApiRequest ( data )); task . run ( data ); useEffect (() => { console . log ( task . status ); // 'IDLE' | 'PROCESSING' | 'ERROR' | 'SUCCESS'; }, [ task . status ]); // Implementation import { useCallback , useState } from \"react\" ; type TStatus = \"IDLE\" | \"PROCESSING\" | \"ERROR\" | \"SUCCESS\" ; function useAsyncTask < T extends any [], R = any > ( task : ( ...args : T ) => Promise < R > ) { const [ status , setStatus ] = useState < TStatus > ( \"IDLE\" ); const [ message , setMessage ] = useState ( \"\" ); const run = useCallback ( async ( ...arg : T ) => { setStatus ( \"PROCESSING\" ); try { const resp : R = await task (... arg ); setStatus ( \"SUCCESS\" ); return resp ; } catch ( error ) { let message = error ? . response ? . data ? . error ? . message || error . message ; setMessage ( message ); setStatus ( \"ERROR\" ); throw error ; } }, []); const reset = useCallback (() => { setMessage ( \"\" ); setStatus ( \"IDLE\" ); }, []); return { run , status , message , reset , }; } export default useAsyncTask ; See also: useAsync .","title":"useAsyncTask"},{"location":"pages/react/typescript/basic/useful-hooks/#usefetch","text":"This Hook is useful to make fetch requests using AbortController Example implementation export function useFetch ( request : RequestInfo , init? : RequestInit ) { const [ response , setResponse ] = useState < null | Response > ( null ); const [ error , setError ] = useState < Error | null > (); const [ isLoading , setIsLoading ] = useState ( true ); useEffect (() => { const abortController = new AbortController (); setIsLoading ( true ); ( async () => { try { const response = await fetch ( request , { ... init , signal : abortController.signal , }); setResponse ( await response ? . json ()); setIsLoading ( false ); } catch ( error ) { if ( isAbortError ( error )) { return ; } setError ( error as any ); setIsLoading ( false ); } })(); return () => { abortController . abort (); }; }, [ init , request ]); return { response , error , isLoading }; } // type guards function isAbortError ( error : any ) : error is DOMException { if ( error && error . name === \"AbortError\" ) { return true ; } return false ; } [See this in TS Playground](https://www.typescriptlang.org/play?&q=400#code/PTAECUFMEMGMBdQEsDOpqgA4HtMFcAbaAJ1AKQCNiSBPUAM21NmJniQDsBzUPFSUp3gD6cSCgB0AWABQIUAElEmYtgBuSACbj0oAFLQ10AMoskmRNAop41BEmwcGTUCzaceGyAHdZ82NgAtjgckBzwaHweugZGpsTmiETceNBckKCQAB7CHCgOTrDQBASQmn5gesYAGtIyFaAAKjSYkPGJoCh4mDjEEfo1ADToHJpYqhraaBgJsAAWnZCI2PQN8C0Z8NjYBGhboLNzBHSB2NoEoHPY3q5BIWH9ARyhCHUNjdi8owI20KOX1yaG3aFlA3iYAGs0N4kPAFlA4IgAsFHA8UA0aNg8KBAtA6N4-pZxkhAgJQI5QOlQrMUAAuCoNAC0mSy0GCpVpVIESFgjPoeA49kc6LkYGZ2TZmA5XNmjNgRBQ-BFDQAYkhiDYwZAAOQlMjbCHoRBXG4ynnIcIiMTTVi8fhjfa4zANBEIW4o0LhSRNOaoZDTBjQPBZRmuxD8wXsRzFd33cL0+oydatUAqoOshAqgVCjgAYTuqPCAB4AAqqTBobK5TRoADeAF8AHygAC8oAAFLJQONcHTQGXe4Mu7dLTkAPy0kY0WQASlbzbTwcRWcjBXzHoeRb+NGbAB9QBxCBd91VagBRUqk8IAblkLqxXCONATIFV6eX2ajeYLnsQfowZqwAwn4FGCvrzAckDkDojgNH82BwmSyaQMMA4VhI-blmgczQHsnwUBkfzkhQABWkBuu2jrQBCGRdKwGJYqAmiONqyi4QGKgkrCSBqJAc5-A6cwZGhewbGCSB6gRDSsIyfBlOgexCQw6qaiQXB4Fef5OIhwGro4byik0nxycg8DDJi2KhPJGAqL2oDIQmshCFasAZAAItAwgiaAtbDqg2AABwAGwAAwAIwecIk42Ak3C3jI3akoqaSQNFtgePF9Z3oZADqGRFNpQmFKwnmEaAkWQOucaIN44ELHJimQA0FXec5xCiK5wwCZB3wavZSmaKVBlPJqFVVYW8CTouGbwCuObjb+RYtVhzZtrZFbzh2w5FuwpJMaVjQkpALa1utkj+cF4UVU2p1YRISUoCl9ZFsAu2QI2s7xe8vpoG4pUBhGOZgTyCx+oB4lwroIkNEYCRWKUwMQTheGgARIzEWRrw+vlP4PLpObSUseDEHkmSwkJpDwYhzC4+E+NfuSpCHiUBnyI0SkIRTsYTaAACCJYKP6ujyuxjIULh8mohhAASAg6tMDT5OySD0Eg8m8RqoErP1nl8wLjkyG1HUZNNiK5gqKALZu3lVmENY+fWwzGPApWtg7za+QlPYVpOInxd2vxRaAzulV9Xv8PAIdB+2KiQGoUepcHLvCMMZ2+1hc4ts2fvDkUJTi7AEITh2mfNmo2BaP7PXaMQ7YzlN74IOb7FW8W257geR6Zdl8gAELkUG-D9X6IuKq4RE4bxqOc5hdndQnoDMrCly4Ws4KUmE3JAWpGloojCwkBkcmCaoeCPliiA6aPkg92A7MZGGZCUNQxB0MiOgwpDsJoNc2lidoqsODcWFA0cgNF+riAyBQPAlhbSBDwBBU4tpkSxyKvkXiGEAAySxtRoCoB4NYVwh5CE+FiUgUo8RcFPv8bq2QpRMDKvQHw3Nfw30TCSXoiAwzDFrHaNoycUJ8LPPQJhbp6wMFUIEUAAAiEqCBpFhzoUwcMIEKRyRVEseY7ZWAAEc8DiEmhASAeiDEKA4IwYYnBYTFygCYmwZjYRzk9t2EaiAADarAUAhH4MMCOUAvHCkgAAXTdnJBORZmbHiMQEvI712yRJnFXVxoA3ECFUMQXxSwzzEHSSEtsYSBFFmyek0A+5ImNjrkk4U7jUCYOwNATQHhMnwAUCgOpDSPB5L4QnSixB9GJOyt2OSwjRHwHbHXTazjuwjlUhQZR+ZwiqBKGSNsoQbi8zmX0BZtgdilFrgMr2AclitPaY07gvT+lV27O2XCNBBQl0mcOaZ9lX4+Sec8mZiBPHeIyG2aABJl5MPgFo3R+ibA8PeR80AEgYVWLMpCj5+QuAcGKJOKw8zHA7OWcQCQSKUUECHIcj59YDlQqOfAfxPybkAq+eIH5Y4JAkRQI4OupKyURxOfUs5XB2yiF2HxK50zxFFGBQsdsaSmCTgFBCDgv8nEIu7CrDsqANnKOKUwcVOSmAznlUSqFrB4DEw4IK55WU9XTIjuq2uErKbTA4DQNlUKOVtK5R4XlxR+COqFe8kllT3kGqNQ8rObzzXoq2ZipZeyJBhrGV6+sVdHYpLhcMUFBigkHOHAGkmPlIIxJ8ZkLVGT-SnOiPG2QZq1hiXUiQGsshAYMxVZs+AVrNXpLRfa+uBaSl+jcgAeQALJniyK5CwoEplKtbS4AAZFOrtTAJAor2i2ZdMjVV9CtdI3Vzys3aT6ZABNmaibZr5fwTKQA)","title":"useFetch"},{"location":"pages/react/typescript/basic/getting-started/basic-type-examples/","text":"This is intended as a basic orientation and reference for React developers familiarizing with TypeScript. Basic Prop Types Examples A list of TypeScript types you will likely use in a React+TypeScript app: type AppProps = { message : string ; count : number ; disabled : boolean ; /** array of a type! */ names : string []; /** string literals to specify exact string values, with a union type to join them together */ status : \"waiting\" | \"success\" ; /** any object as long as you dont use its properties (NOT COMMON but useful as placeholder) */ obj : object ; obj2 : {}; // almost the same as `object`, exactly the same as `Object` /** an object with any number of properties (PREFERRED) */ obj3 : { id : string ; title : string ; }; /** array of objects! (common) */ objArr : { id : string ; title : string ; }[]; /** a dict object with any number of properties of the same type */ dict1 : { [ key : string ] : MyTypeHere ; }; dict2 : Record < string , MyTypeHere > ; // equivalent to dict1 /** any function as long as you don't invoke it (not recommended) */ onSomething : Function ; /** function that doesn't take or return anything (VERY COMMON) */ onClick : () => void ; /** function with named prop (VERY COMMON) */ onChange : ( id : number ) => void ; /** function type syntax that takes an event (VERY COMMON) */ onChange : ( event : React.ChangeEvent < HTMLInputElement > ) => void ; /** alternative function type syntax that takes an event (VERY COMMON) */ onClick ( event : React.MouseEvent < HTMLButtonElement > ) : void ; /** an optional prop (VERY COMMON!) */ optional? : OptionalType ; }; Notice we have used the TSDoc /** comment */ style here on each prop. You can and are encouraged to leave descriptive comments on reusable components. For a fuller example and discussion, see our Commenting Components section in the Advanced Cheatsheet. Useful React Prop Type Examples Relevant for components that accept other React components as props. export declare interface AppProps { children? : React.ReactNode ; // best, accepts everything React can render childrenElement : JSX.Element ; // A single React element style? : React.CSSProperties ; // to pass through style props onChange? : React.FormEventHandler < HTMLInputElement > ; // form events! the generic parameter is the type of event.target // more info: https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase/#wrappingmirroring props : Props & React . ComponentPropsWithoutRef < \"button\" > ; // to impersonate all the props of a button element and explicitly not forwarding its ref props2 : Props & React . ComponentPropsWithRef < MyButtonWithForwardRef > ; // to impersonate all the props of MyButtonForwardedRef and explicitly forwarding its ref } Small React.ReactNode edge case before React 18 Before the [React 18 type updates](https://github.com/DefinitelyTyped/DefinitelyTyped/pull/56210), this code typechecked but had a runtime error: type Props = { children? : React.ReactNode ; }; function Comp ({ children } : Props ) { return < div > { children } < /div>; } function App () { // Before React 18: Runtime error \"Objects are not valid as a React child\" // After React 18: Typecheck error \"Type '{}' is not assignable to type 'ReactNode'\" return < Comp > {{}} < /Comp>; } This is because `ReactNode` includes `ReactFragment` which allowed type `{}` before React 18. [Thanks @pomle for raising this.](https://github.com/typescript-cheatsheets/react/issues/357) JSX.Element vs React.ReactNode? Quote [@ferdaber](https://github.com/typescript-cheatsheets/react/issues/57): A more technical explanation is that a valid React node is not the same thing as what is returned by `React.createElement`. Regardless of what a component ends up rendering, `React.createElement` always returns an object, which is the `JSX.Element` interface, but `React.ReactNode` is the set of all possible return values of a component. - `JSX.Element` -> Return value of `React.createElement` - `React.ReactNode` -> Return value of a component More discussion: Where ReactNode does not overlap with JSX.Element Something to add? File an issue . Types or Interfaces? You can use either Types or Interfaces to type Props and State, so naturally the question arises - which do you use? TL;DR Use Interface until You Need Type - orta . More Advice Here's a helpful rule of thumb: always use interface for public API's definition when authoring a library or 3rd party ambient type definitions, as this allows a consumer to extend them via declaration merging if some definitions are missing. consider using type for your React Component Props and State, for consistency and because it is more constrained. You can read more about the reasoning behind this rule of thumb in Interface vs Type alias in TypeScript 2.7 . The TypeScript Handbook now also includes guidance on Differences Between Type Aliases and Interfaces . Note: At scale, there are performance reasons to prefer interfaces ( see official Microsoft notes on this ) but take this with a grain of salt Types are useful for union types (e.g. type MyType = TypeA | TypeB ) whereas Interfaces are better for declaring dictionary shapes and then implementing or extending them. Useful table for Types vs Interfaces It's a nuanced topic, don't get too hung up on it. Here's a handy table: Aspect Type Interface Can describe functions \u2705 \u2705 Can describe constructors \u2705 \u2705 Can describe tuples \u2705 \u2705 Interfaces can extend it \u26a0\ufe0f \u2705 Classes can extend it \ud83d\udeab \u2705 Classes can implement it ( implements ) \u26a0\ufe0f \u2705 Can intersect another one of its kind \u2705 \u26a0\ufe0f Can create a union with another one of its kind \u2705 \ud83d\udeab Can be used to create mapped types \u2705 \ud83d\udeab Can be mapped over with mapped types \u2705 \u2705 Expands in error messages and logs \u2705 \ud83d\udeab Can be augmented \ud83d\udeab \u2705 Can be recursive \u26a0\ufe0f \u2705 \u26a0\ufe0f In some cases (source: Karol Majewski ) Something to add? File an issue .","title":"Typing with Props"},{"location":"pages/react/typescript/basic/getting-started/basic-type-examples/#basic-prop-types-examples","text":"A list of TypeScript types you will likely use in a React+TypeScript app: type AppProps = { message : string ; count : number ; disabled : boolean ; /** array of a type! */ names : string []; /** string literals to specify exact string values, with a union type to join them together */ status : \"waiting\" | \"success\" ; /** any object as long as you dont use its properties (NOT COMMON but useful as placeholder) */ obj : object ; obj2 : {}; // almost the same as `object`, exactly the same as `Object` /** an object with any number of properties (PREFERRED) */ obj3 : { id : string ; title : string ; }; /** array of objects! (common) */ objArr : { id : string ; title : string ; }[]; /** a dict object with any number of properties of the same type */ dict1 : { [ key : string ] : MyTypeHere ; }; dict2 : Record < string , MyTypeHere > ; // equivalent to dict1 /** any function as long as you don't invoke it (not recommended) */ onSomething : Function ; /** function that doesn't take or return anything (VERY COMMON) */ onClick : () => void ; /** function with named prop (VERY COMMON) */ onChange : ( id : number ) => void ; /** function type syntax that takes an event (VERY COMMON) */ onChange : ( event : React.ChangeEvent < HTMLInputElement > ) => void ; /** alternative function type syntax that takes an event (VERY COMMON) */ onClick ( event : React.MouseEvent < HTMLButtonElement > ) : void ; /** an optional prop (VERY COMMON!) */ optional? : OptionalType ; }; Notice we have used the TSDoc /** comment */ style here on each prop. You can and are encouraged to leave descriptive comments on reusable components. For a fuller example and discussion, see our Commenting Components section in the Advanced Cheatsheet.","title":"Basic Prop Types Examples"},{"location":"pages/react/typescript/basic/getting-started/basic-type-examples/#useful-react-prop-type-examples","text":"Relevant for components that accept other React components as props. export declare interface AppProps { children? : React.ReactNode ; // best, accepts everything React can render childrenElement : JSX.Element ; // A single React element style? : React.CSSProperties ; // to pass through style props onChange? : React.FormEventHandler < HTMLInputElement > ; // form events! the generic parameter is the type of event.target // more info: https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase/#wrappingmirroring props : Props & React . ComponentPropsWithoutRef < \"button\" > ; // to impersonate all the props of a button element and explicitly not forwarding its ref props2 : Props & React . ComponentPropsWithRef < MyButtonWithForwardRef > ; // to impersonate all the props of MyButtonForwardedRef and explicitly forwarding its ref } Small React.ReactNode edge case before React 18 Before the [React 18 type updates](https://github.com/DefinitelyTyped/DefinitelyTyped/pull/56210), this code typechecked but had a runtime error: type Props = { children? : React.ReactNode ; }; function Comp ({ children } : Props ) { return < div > { children } < /div>; } function App () { // Before React 18: Runtime error \"Objects are not valid as a React child\" // After React 18: Typecheck error \"Type '{}' is not assignable to type 'ReactNode'\" return < Comp > {{}} < /Comp>; } This is because `ReactNode` includes `ReactFragment` which allowed type `{}` before React 18. [Thanks @pomle for raising this.](https://github.com/typescript-cheatsheets/react/issues/357) JSX.Element vs React.ReactNode? Quote [@ferdaber](https://github.com/typescript-cheatsheets/react/issues/57): A more technical explanation is that a valid React node is not the same thing as what is returned by `React.createElement`. Regardless of what a component ends up rendering, `React.createElement` always returns an object, which is the `JSX.Element` interface, but `React.ReactNode` is the set of all possible return values of a component. - `JSX.Element` -> Return value of `React.createElement` - `React.ReactNode` -> Return value of a component More discussion: Where ReactNode does not overlap with JSX.Element Something to add? File an issue .","title":"Useful React Prop Type Examples"},{"location":"pages/react/typescript/basic/getting-started/basic-type-examples/#types-or-interfaces","text":"You can use either Types or Interfaces to type Props and State, so naturally the question arises - which do you use?","title":"Types or Interfaces?"},{"location":"pages/react/typescript/basic/getting-started/basic-type-examples/#tldr","text":"Use Interface until You Need Type - orta .","title":"TL;DR"},{"location":"pages/react/typescript/basic/getting-started/basic-type-examples/#more-advice","text":"Here's a helpful rule of thumb: always use interface for public API's definition when authoring a library or 3rd party ambient type definitions, as this allows a consumer to extend them via declaration merging if some definitions are missing. consider using type for your React Component Props and State, for consistency and because it is more constrained. You can read more about the reasoning behind this rule of thumb in Interface vs Type alias in TypeScript 2.7 . The TypeScript Handbook now also includes guidance on Differences Between Type Aliases and Interfaces . Note: At scale, there are performance reasons to prefer interfaces ( see official Microsoft notes on this ) but take this with a grain of salt Types are useful for union types (e.g. type MyType = TypeA | TypeB ) whereas Interfaces are better for declaring dictionary shapes and then implementing or extending them.","title":"More Advice"},{"location":"pages/react/typescript/basic/getting-started/basic-type-examples/#useful-table-for-types-vs-interfaces","text":"It's a nuanced topic, don't get too hung up on it. Here's a handy table: Aspect Type Interface Can describe functions \u2705 \u2705 Can describe constructors \u2705 \u2705 Can describe tuples \u2705 \u2705 Interfaces can extend it \u26a0\ufe0f \u2705 Classes can extend it \ud83d\udeab \u2705 Classes can implement it ( implements ) \u26a0\ufe0f \u2705 Can intersect another one of its kind \u2705 \u26a0\ufe0f Can create a union with another one of its kind \u2705 \ud83d\udeab Can be used to create mapped types \u2705 \ud83d\udeab Can be mapped over with mapped types \u2705 \u2705 Expands in error messages and logs \u2705 \ud83d\udeab Can be augmented \ud83d\udeab \u2705 Can be recursive \u26a0\ufe0f \u2705 \u26a0\ufe0f In some cases (source: Karol Majewski ) Something to add? File an issue .","title":"Useful table for Types vs Interfaces"},{"location":"pages/react/typescript/basic/getting-started/class-components/","text":"Within TypeScript, React.Component is a generic type (aka React.Component<PropType, StateType> ), so you want to provide it with (optional) prop and state type parameters: type MyProps = { // using `interface` is also ok message : string ; }; type MyState = { count : number ; // like this }; class App extends React . Component < MyProps , MyState > { state : MyState = { // optional second annotation for better type inference count : 0 , }; render () { return ( < div > { this . props . message } { this . state . count } < /div> ); } } View in the TypeScript Playground Don't forget that you can export/import/extend these types/interfaces for reuse. Why annotate state twice? It isn't strictly necessary to annotate the `state` class property, but it allows better type inference when accessing `this.state` and also initializing the state. This is because they work in two different ways, the 2nd generic type parameter will allow `this.setState()` to work correctly, because that method comes from the base class, but initializing `state` inside the component overrides the base implementation so you have to make sure that you tell the compiler that you're not actually doing anything different. [See commentary by @ferdaber here](https://github.com/typescript-cheatsheets/react/issues/57). No need for readonly You often see sample code include `readonly` to mark props and state immutable: type MyProps = { readonly message : string ; }; type MyState = { readonly count : number ; }; This is not necessary as `React.Component ` already marks them as immutable. ([See PR and discussion!](https://github.com/DefinitelyTyped/DefinitelyTyped/pull/26813)) Class Methods : Do it like normal, but just remember any arguments for your functions also need to be typed: class App extends React . Component < { message : string }, { count : number } > { state = { count : 0 }; render () { return ( < div onClick = {() => this . increment ( 1 )} > { this . props . message } { this . state . count } < /div> ); } increment = ( amt : number ) => { // like this this . setState (( state ) => ({ count : state.count + amt , })); }; } View in the TypeScript Playground Class Properties : If you need to declare class properties for later use, just declare it like state , but without assignment: class App extends React . Component < { message : string ; } > { pointer : number ; // like this componentDidMount () { this . pointer = 3 ; } render () { return ( < div > { this . props . message } and { this . pointer } < /div> ); } } View in the TypeScript Playground Something to add? File an issue . Typing getDerivedStateFromProps Before you start using getDerivedStateFromProps , please go through the documentation and You Probably Don't Need Derived State . Derived State can be implemented using hooks which can also help set up memoization. Here are a few ways in which you can annotate getDerivedStateFromProps If you have explicitly typed your derived state and want to make sure that the return value from getDerivedStateFromProps conforms to it. class Comp extends React . Component < Props , State > { static getDerivedStateFromProps ( props : Props , state : State ) : Partial < State > | null { // } } When you want the function's return value to determine your state. class Comp extends React . Component < Props , ReturnType < typeof Comp [ \"getDerivedStateFromProps\" ] > > { static getDerivedStateFromProps ( props : Props ) {} } When you want derived state with other state fields and memoization type CustomValue = any ; interface Props { propA : CustomValue ; } interface DefinedState { otherStateField : string ; } type State = DefinedState & ReturnType < typeof transformPropsToState > ; function transformPropsToState ( props : Props ) { return { savedPropA : props.propA , // save for memoization derivedState : props.propA , }; } class Comp extends React . PureComponent < Props , State > { constructor ( props : Props ) { super ( props ); this . state = { otherStateField : \"123\" , ... transformPropsToState ( props ), }; } static getDerivedStateFromProps ( props : Props , state : State ) { if ( isEqual ( props . propA , state . savedPropA )) return null ; return transformPropsToState ( props ); } } View in the TypeScript Playground","title":"Class Components"},{"location":"pages/react/typescript/basic/getting-started/class-components/#typing-getderivedstatefromprops","text":"Before you start using getDerivedStateFromProps , please go through the documentation and You Probably Don't Need Derived State . Derived State can be implemented using hooks which can also help set up memoization. Here are a few ways in which you can annotate getDerivedStateFromProps If you have explicitly typed your derived state and want to make sure that the return value from getDerivedStateFromProps conforms to it. class Comp extends React . Component < Props , State > { static getDerivedStateFromProps ( props : Props , state : State ) : Partial < State > | null { // } } When you want the function's return value to determine your state. class Comp extends React . Component < Props , ReturnType < typeof Comp [ \"getDerivedStateFromProps\" ] > > { static getDerivedStateFromProps ( props : Props ) {} } When you want derived state with other state fields and memoization type CustomValue = any ; interface Props { propA : CustomValue ; } interface DefinedState { otherStateField : string ; } type State = DefinedState & ReturnType < typeof transformPropsToState > ; function transformPropsToState ( props : Props ) { return { savedPropA : props.propA , // save for memoization derivedState : props.propA , }; } class Comp extends React . PureComponent < Props , State > { constructor ( props : Props ) { super ( props ); this . state = { otherStateField : \"123\" , ... transformPropsToState ( props ), }; } static getDerivedStateFromProps ( props : Props , state : State ) { if ( isEqual ( props . propA , state . savedPropA )) return null ; return transformPropsToState ( props ); } } View in the TypeScript Playground","title":"Typing getDerivedStateFromProps"},{"location":"pages/react/typescript/basic/getting-started/concurrent/","text":"Not written yet. watch https://github.com/sw-yx/fresh-async-react for more on React Suspense and Time Slicing. Something to add? File an issue .","title":"Concurrent/Suspense"},{"location":"pages/react/typescript/basic/getting-started/context/","text":"Basic Example import { createContext } from \"react\" ; interface AppContextInterface { name : string ; author : string ; url : string ; } const AppCtx = createContext < AppContextInterface | null > ( null ); // Provider in your app const sampleAppContext : AppContextInterface = { name : \"Using React Context in a Typescript App\" , author : \"thehappybug\" , url : \"http://www.example.com\" , }; export const App = () => ( < AppCtx . Provider value = { sampleAppContext } > ... < /AppCtx.Provider> ); // Consume in your app import { useContext } from \"react\" ; export const PostInfo = () => { const appContext = useContext ( AppCtx ); return ( < div > Name : { appContext . name }, Author : { appContext . author }, Url : { \" \" } { appContext . url } < /div> ); }; You can also use the Class.contextType or Context.Consumer API, let us know if you have trouble with that. Thanks to @AlvSovereign Extended Example Using createContext with an empty object as default value. interface ContextState { // set the type of state you want to handle with context e.g. name : string | null ; } //set an empty object as default state const Context = createContext ({} as ContextState ); // set up context provider as you normally would in JavaScript [React Context API](https://reactjs.org/docs/context.html#api) Using createContext and context getters to make a createCtx with no defaultValue , yet no need to check for undefined : import { createContext , useContext } from \"react\" ; const currentUserContext = createContext < string | undefined > ( undefined ); function EnthusasticGreeting () { const currentUser = useContext ( currentUserContext ); return < div > HELLO { currentUser ! . toUpperCase ()} !< /div>; } function App () { return ( < currentUserContext . Provider value = \"Anders\" > < EnthusasticGreeting /> < /currentUserContext.Provider> ); } Notice the explicit type arguments which we need because we don't have a default string value: const currentUserContext = createContext < string | undefined > ( undefined ); // ^^^^^^^^^^^^^^^^^^ along with the non-null assertion to tell TypeScript that currentUser is definitely going to be there: return < div > HELLO { currentUser ! . toUpperCase ()} !< /div>; // ^ This is unfortunate because we know that later in our app, a Provider is going to fill in the context. There are a few solutions for this: You can get around this by asserting non null: const currentUserContext = createContext < string > ( undefined ! ); ( Playground here ) This is a quick and easy fix, but this loses type-safety, and if you forget to supply a value to the Provider, you will get an error. We can write a helper function called createCtx that guards against accessing a Context whose value wasn't provided. By doing this, API instead, we never have to provide a default and never have to check for undefined : import { createContext , useContext } from \"react\" ; /** * A helper to create a Context and Provider with no upfront default value, and * without having to check for undefined all the time. */ function createCtx < A extends {} | null > () { const ctx = createContext < A | undefined > ( undefined ); function useCtx () { const c = useContext ( ctx ); if ( c === undefined ) throw new Error ( \"useCtx must be inside a Provider with a value\" ); return c ; } return [ useCtx , ctx . Provider ] as const ; // 'as const' makes TypeScript infer a tuple } // Usage: // We still have to specify a type, but no default! export const [ useCurrentUserName , CurrentUserProvider ] = createCtx < string > (); function EnthusasticGreeting () { const currentUser = useCurrentUserName (); return < div > HELLO { currentUser . toUpperCase ()} !< /div>; } function App () { return ( < CurrentUserProvider value = \"Anders\" > < EnthusasticGreeting /> < /CurrentUserProvider> ); } View in the TypeScript Playground You can go even further and combine this idea using createContext and context getters . import { createContext , useContext } from \"react\" ; /** * A helper to create a Context and Provider with no upfront default value, and * without having to check for undefined all the time. */ function createCtx < A extends {} | null > () { const ctx = createContext < A | undefined > ( undefined ); function useCtx () { const c = useContext ( ctx ); if ( c === undefined ) throw new Error ( \"useCtx must be inside a Provider with a value\" ); return c ; } return [ useCtx , ctx . Provider ] as const ; // 'as const' makes TypeScript infer a tuple } // usage export const [ useCtx , SettingProvider ] = createCtx < string > (); // specify type, but no need to specify value upfront! export function App () { const key = useCustomHook ( \"key\" ); // get a value from a hook, must be in a component return ( < SettingProvider value = { key } > < Component /> < /SettingProvider> ); } export function Component () { const key = useCtx (); // can still use without null check! return < div > { key } < /div>; } View in the TypeScript Playground Using createContext and useContext to make a createCtx with unstated -like context setters: import { createContext , Dispatch , PropsWithChildren , SetStateAction , useState , } from \"react\" ; export function createCtx < A > ( defaultValue : A ) { type UpdateType = Dispatch < SetStateAction < typeof defaultValue >> ; const defaultUpdate : UpdateType = () => defaultValue ; const ctx = createContext ({ state : defaultValue , update : defaultUpdate , }); function Provider ( props : PropsWithChildren < {} > ) { const [ state , update ] = useState ( defaultValue ); return < ctx . Provider value = {{ state , update }} {... props } /> ; } return [ ctx , Provider ] as const ; // alternatively, [typeof ctx, typeof Provider] } // usage import { useContext } from \"react\" ; const [ ctx , TextProvider ] = createCtx ( \"someText\" ); export const TextContext = ctx ; export function App () { return ( < TextProvider > < Component /> < /TextProvider> ); } export function Component () { const { state , update } = useContext ( TextContext ); return ( < label > { state } < input type = \"text\" onChange = {( e ) => update ( e . target . value )} /> < /label> ); } View in the TypeScript Playground A useReducer-based version may also be helpful. Mutable Context Using a Class component wrapper _Contributed by: [@jpavon](https://github.com/typescript-cheatsheets/react/pull/13)_ interface ProviderState { themeColor : string ; } interface UpdateStateArg { key : keyof ProviderState ; value : string ; } interface ProviderStore { state : ProviderState ; update : ( arg : UpdateStateArg ) => void ; } const Context = createContext ({} as ProviderStore ); // type assertion on empty object class Provider extends React . Component < { children? : ReactNode }, ProviderState > { public readonly state = { themeColor : \"red\" , }; private update = ({ key , value } : UpdateStateArg ) => { this . setState ({ [ key ] : value }); }; public render () { const store : ProviderStore = { state : this.state , update : this.update , }; return ( < Context . Provider value = { store } > { this . props . children } < /Context.Provider> ); } } const Consumer = Context . Consumer ; Something to add? File an issue .","title":"Context"},{"location":"pages/react/typescript/basic/getting-started/context/#basic-example","text":"import { createContext } from \"react\" ; interface AppContextInterface { name : string ; author : string ; url : string ; } const AppCtx = createContext < AppContextInterface | null > ( null ); // Provider in your app const sampleAppContext : AppContextInterface = { name : \"Using React Context in a Typescript App\" , author : \"thehappybug\" , url : \"http://www.example.com\" , }; export const App = () => ( < AppCtx . Provider value = { sampleAppContext } > ... < /AppCtx.Provider> ); // Consume in your app import { useContext } from \"react\" ; export const PostInfo = () => { const appContext = useContext ( AppCtx ); return ( < div > Name : { appContext . name }, Author : { appContext . author }, Url : { \" \" } { appContext . url } < /div> ); }; You can also use the Class.contextType or Context.Consumer API, let us know if you have trouble with that. Thanks to @AlvSovereign","title":"Basic Example"},{"location":"pages/react/typescript/basic/getting-started/context/#extended-example","text":"Using createContext with an empty object as default value. interface ContextState { // set the type of state you want to handle with context e.g. name : string | null ; } //set an empty object as default state const Context = createContext ({} as ContextState ); // set up context provider as you normally would in JavaScript [React Context API](https://reactjs.org/docs/context.html#api) Using createContext and context getters to make a createCtx with no defaultValue , yet no need to check for undefined : import { createContext , useContext } from \"react\" ; const currentUserContext = createContext < string | undefined > ( undefined ); function EnthusasticGreeting () { const currentUser = useContext ( currentUserContext ); return < div > HELLO { currentUser ! . toUpperCase ()} !< /div>; } function App () { return ( < currentUserContext . Provider value = \"Anders\" > < EnthusasticGreeting /> < /currentUserContext.Provider> ); } Notice the explicit type arguments which we need because we don't have a default string value: const currentUserContext = createContext < string | undefined > ( undefined ); // ^^^^^^^^^^^^^^^^^^ along with the non-null assertion to tell TypeScript that currentUser is definitely going to be there: return < div > HELLO { currentUser ! . toUpperCase ()} !< /div>; // ^ This is unfortunate because we know that later in our app, a Provider is going to fill in the context. There are a few solutions for this: You can get around this by asserting non null: const currentUserContext = createContext < string > ( undefined ! ); ( Playground here ) This is a quick and easy fix, but this loses type-safety, and if you forget to supply a value to the Provider, you will get an error. We can write a helper function called createCtx that guards against accessing a Context whose value wasn't provided. By doing this, API instead, we never have to provide a default and never have to check for undefined : import { createContext , useContext } from \"react\" ; /** * A helper to create a Context and Provider with no upfront default value, and * without having to check for undefined all the time. */ function createCtx < A extends {} | null > () { const ctx = createContext < A | undefined > ( undefined ); function useCtx () { const c = useContext ( ctx ); if ( c === undefined ) throw new Error ( \"useCtx must be inside a Provider with a value\" ); return c ; } return [ useCtx , ctx . Provider ] as const ; // 'as const' makes TypeScript infer a tuple } // Usage: // We still have to specify a type, but no default! export const [ useCurrentUserName , CurrentUserProvider ] = createCtx < string > (); function EnthusasticGreeting () { const currentUser = useCurrentUserName (); return < div > HELLO { currentUser . toUpperCase ()} !< /div>; } function App () { return ( < CurrentUserProvider value = \"Anders\" > < EnthusasticGreeting /> < /CurrentUserProvider> ); } View in the TypeScript Playground You can go even further and combine this idea using createContext and context getters . import { createContext , useContext } from \"react\" ; /** * A helper to create a Context and Provider with no upfront default value, and * without having to check for undefined all the time. */ function createCtx < A extends {} | null > () { const ctx = createContext < A | undefined > ( undefined ); function useCtx () { const c = useContext ( ctx ); if ( c === undefined ) throw new Error ( \"useCtx must be inside a Provider with a value\" ); return c ; } return [ useCtx , ctx . Provider ] as const ; // 'as const' makes TypeScript infer a tuple } // usage export const [ useCtx , SettingProvider ] = createCtx < string > (); // specify type, but no need to specify value upfront! export function App () { const key = useCustomHook ( \"key\" ); // get a value from a hook, must be in a component return ( < SettingProvider value = { key } > < Component /> < /SettingProvider> ); } export function Component () { const key = useCtx (); // can still use without null check! return < div > { key } < /div>; } View in the TypeScript Playground Using createContext and useContext to make a createCtx with unstated -like context setters: import { createContext , Dispatch , PropsWithChildren , SetStateAction , useState , } from \"react\" ; export function createCtx < A > ( defaultValue : A ) { type UpdateType = Dispatch < SetStateAction < typeof defaultValue >> ; const defaultUpdate : UpdateType = () => defaultValue ; const ctx = createContext ({ state : defaultValue , update : defaultUpdate , }); function Provider ( props : PropsWithChildren < {} > ) { const [ state , update ] = useState ( defaultValue ); return < ctx . Provider value = {{ state , update }} {... props } /> ; } return [ ctx , Provider ] as const ; // alternatively, [typeof ctx, typeof Provider] } // usage import { useContext } from \"react\" ; const [ ctx , TextProvider ] = createCtx ( \"someText\" ); export const TextContext = ctx ; export function App () { return ( < TextProvider > < Component /> < /TextProvider> ); } export function Component () { const { state , update } = useContext ( TextContext ); return ( < label > { state } < input type = \"text\" onChange = {( e ) => update ( e . target . value )} /> < /label> ); } View in the TypeScript Playground A useReducer-based version may also be helpful. Mutable Context Using a Class component wrapper _Contributed by: [@jpavon](https://github.com/typescript-cheatsheets/react/pull/13)_ interface ProviderState { themeColor : string ; } interface UpdateStateArg { key : keyof ProviderState ; value : string ; } interface ProviderStore { state : ProviderState ; update : ( arg : UpdateStateArg ) => void ; } const Context = createContext ({} as ProviderStore ); // type assertion on empty object class Provider extends React . Component < { children? : ReactNode }, ProviderState > { public readonly state = { themeColor : \"red\" , }; private update = ({ key , value } : UpdateStateArg ) => { this . setState ({ [ key ] : value }); }; public render () { const store : ProviderStore = { state : this.state , update : this.update , }; return ( < Context . Provider value = { store } > { this . props . children } < /Context.Provider> ); } } const Consumer = Context . Consumer ; Something to add? File an issue .","title":"Extended Example"},{"location":"pages/react/typescript/basic/getting-started/default-props/","text":"You May Not Need defaultProps As per this tweet , defaultProps will eventually be deprecated. You can check the discussions here: Original tweet More info can also be found in this article The consensus is to use object default values. Function Components: type GreetProps = { age? : number }; const Greet = ({ age = 21 } : GreetProps ) => // etc Class Components: type GreetProps = { age? : number ; }; class Greet extends React . Component < GreetProps > { render () { const { age = 21 } = this . props ; /*...*/ } } let el = < Greet age = { 3 } /> ; Typing defaultProps Type inference improved greatly for defaultProps in TypeScript 3.0+ , although some edge cases are still problematic . Function Components // using typeof as a shortcut; note that it hoists! // you can also declare the type of DefaultProps if you choose // e.g. https://github.com/typescript-cheatsheets/react/issues/415#issuecomment-841223219 type GreetProps = { age : number } & typeof defaultProps ; const defaultProps = { age : 21 , }; const Greet = ( props : GreetProps ) => { // etc }; Greet . defaultProps = defaultProps ; See this in TS Playground For Class components , there are a couple ways to do it (including using the Pick utility type) but the recommendation is to \"reverse\" the props definition: type GreetProps = typeof Greet . defaultProps & { age : number ; }; class Greet extends React . Component < GreetProps > { static defaultProps = { age : 21 , }; /*...*/ } // Type-checks! No type assertions needed! let el = < Greet age = { 3 } /> ; JSX.LibraryManagedAttributes nuance for library authors The above implementations work fine for App creators, but sometimes you want to be able to export `GreetProps` so that others can consume it. The problem here is that the way `GreetProps` is defined, `age` is a required prop when it isn't because of `defaultProps`. The insight to have here is that [`GreetProps` is the _internal_ contract for your component, not the _external_, consumer facing contract](https://github.com/typescript-cheatsheets/react/issues/66#issuecomment-453878710). You could create a separate type specifically for export, or you could make use of the `JSX.LibraryManagedAttributes` utility: // internal contract, should not be exported out type GreetProps = { age : number ; }; class Greet extends Component < GreetProps > { static defaultProps = { age : 21 }; } // external contract export type ApparentGreetProps = JSX . LibraryManagedAttributes < typeof Greet , GreetProps > ; This will work properly, although hovering over`ApparentGreetProps`may be a little intimidating. You can reduce this boilerplate with the`ComponentProps` utility detailed below. Consuming Props of a Component with defaultProps A component with defaultProps may seem to have some required props that actually aren't. Problem Statement Here's what you want to do: interface IProps { name : string ; } const defaultProps = { age : 25 , }; const GreetComponent = ({ name , age } : IProps & typeof defaultProps ) => ( < div > { `Hello, my name is ${ name } , ${ age } ` } < /div> ); GreetComponent . defaultProps = defaultProps ; const TestComponent = ( props : React.ComponentProps < typeof GreetComponent > ) => { return < h1 /> ; }; // Property 'age' is missing in type '{ name: string; }' but required in type '{ age: number; }' const el = < TestComponent name = \"foo\" /> ; Solution Define a utility that applies JSX.LibraryManagedAttributes : type ComponentProps < T > = T extends | React . ComponentType < infer P > | React . Component < infer P > ? JSX . LibraryManagedAttributes < T , P > : never ; const TestComponent = ( props : ComponentProps < typeof GreetComponent > ) => { return < h1 /> ; }; // No error const el = < TestComponent name = \"foo\" /> ; See this in TS Playground Misc Discussions and Knowledge Why does React.FC break defaultProps ? You can check the discussions here: - https://medium.com/@martin_hotell/10-typescript-pro-tips-patterns-with-or-without-react-5799488d6680 - https://github.com/DefinitelyTyped/DefinitelyTyped/issues/30695 - https://github.com/typescript-cheatsheets/react/issues/87 This is just the current state and may be fixed in future. TypeScript 2.9 and earlier For TypeScript 2.9 and earlier, there's more than one way to do it, but this is the best advice we've yet seen: type Props = Required < typeof MyComponent . defaultProps > & { /* additional props here */ }; export class MyComponent extends React . Component < Props > { static defaultProps = { foo : \"foo\" , }; } Our former recommendation used the `Partial type` feature in TypeScript, which means that the current interface will fulfill a partial version on the wrapped interface. In that way we can extend defaultProps without any changes in the types! interface IMyComponentProps { firstProp? : string ; secondProp : IPerson []; } export class MyComponent extends React . Component < IMyComponentProps > { public static defaultProps : Partial < IMyComponentProps > = { firstProp : \"default\" , }; } The problem with this approach is it causes complex issues with the type inference working with `JSX.LibraryManagedAttributes`. Basically it causes the compiler to think that when creating a JSX expression with that component, that all of its props are optional. [See commentary by @ferdaber here](https://github.com/typescript-cheatsheets/react/issues/57) and [here](https://github.com/typescript-cheatsheets/react/issues/61). Something to add? File an issue .","title":"Typing defaultProps"},{"location":"pages/react/typescript/basic/getting-started/default-props/#you-may-not-need-defaultprops","text":"As per this tweet , defaultProps will eventually be deprecated. You can check the discussions here: Original tweet More info can also be found in this article The consensus is to use object default values. Function Components: type GreetProps = { age? : number }; const Greet = ({ age = 21 } : GreetProps ) => // etc Class Components: type GreetProps = { age? : number ; }; class Greet extends React . Component < GreetProps > { render () { const { age = 21 } = this . props ; /*...*/ } } let el = < Greet age = { 3 } /> ;","title":"You May Not Need defaultProps"},{"location":"pages/react/typescript/basic/getting-started/default-props/#typing-defaultprops","text":"Type inference improved greatly for defaultProps in TypeScript 3.0+ , although some edge cases are still problematic . Function Components // using typeof as a shortcut; note that it hoists! // you can also declare the type of DefaultProps if you choose // e.g. https://github.com/typescript-cheatsheets/react/issues/415#issuecomment-841223219 type GreetProps = { age : number } & typeof defaultProps ; const defaultProps = { age : 21 , }; const Greet = ( props : GreetProps ) => { // etc }; Greet . defaultProps = defaultProps ; See this in TS Playground For Class components , there are a couple ways to do it (including using the Pick utility type) but the recommendation is to \"reverse\" the props definition: type GreetProps = typeof Greet . defaultProps & { age : number ; }; class Greet extends React . Component < GreetProps > { static defaultProps = { age : 21 , }; /*...*/ } // Type-checks! No type assertions needed! let el = < Greet age = { 3 } /> ; JSX.LibraryManagedAttributes nuance for library authors The above implementations work fine for App creators, but sometimes you want to be able to export `GreetProps` so that others can consume it. The problem here is that the way `GreetProps` is defined, `age` is a required prop when it isn't because of `defaultProps`. The insight to have here is that [`GreetProps` is the _internal_ contract for your component, not the _external_, consumer facing contract](https://github.com/typescript-cheatsheets/react/issues/66#issuecomment-453878710). You could create a separate type specifically for export, or you could make use of the `JSX.LibraryManagedAttributes` utility: // internal contract, should not be exported out type GreetProps = { age : number ; }; class Greet extends Component < GreetProps > { static defaultProps = { age : 21 }; } // external contract export type ApparentGreetProps = JSX . LibraryManagedAttributes < typeof Greet , GreetProps > ; This will work properly, although hovering over`ApparentGreetProps`may be a little intimidating. You can reduce this boilerplate with the`ComponentProps` utility detailed below.","title":"Typing defaultProps"},{"location":"pages/react/typescript/basic/getting-started/default-props/#consuming-props-of-a-component-with-defaultprops","text":"A component with defaultProps may seem to have some required props that actually aren't.","title":"Consuming Props of a Component with defaultProps"},{"location":"pages/react/typescript/basic/getting-started/default-props/#problem-statement","text":"Here's what you want to do: interface IProps { name : string ; } const defaultProps = { age : 25 , }; const GreetComponent = ({ name , age } : IProps & typeof defaultProps ) => ( < div > { `Hello, my name is ${ name } , ${ age } ` } < /div> ); GreetComponent . defaultProps = defaultProps ; const TestComponent = ( props : React.ComponentProps < typeof GreetComponent > ) => { return < h1 /> ; }; // Property 'age' is missing in type '{ name: string; }' but required in type '{ age: number; }' const el = < TestComponent name = \"foo\" /> ;","title":"Problem Statement"},{"location":"pages/react/typescript/basic/getting-started/default-props/#solution","text":"Define a utility that applies JSX.LibraryManagedAttributes : type ComponentProps < T > = T extends | React . ComponentType < infer P > | React . Component < infer P > ? JSX . LibraryManagedAttributes < T , P > : never ; const TestComponent = ( props : ComponentProps < typeof GreetComponent > ) => { return < h1 /> ; }; // No error const el = < TestComponent name = \"foo\" /> ; See this in TS Playground","title":"Solution"},{"location":"pages/react/typescript/basic/getting-started/default-props/#misc-discussions-and-knowledge","text":"Why does React.FC break defaultProps ? You can check the discussions here: - https://medium.com/@martin_hotell/10-typescript-pro-tips-patterns-with-or-without-react-5799488d6680 - https://github.com/DefinitelyTyped/DefinitelyTyped/issues/30695 - https://github.com/typescript-cheatsheets/react/issues/87 This is just the current state and may be fixed in future. TypeScript 2.9 and earlier For TypeScript 2.9 and earlier, there's more than one way to do it, but this is the best advice we've yet seen: type Props = Required < typeof MyComponent . defaultProps > & { /* additional props here */ }; export class MyComponent extends React . Component < Props > { static defaultProps = { foo : \"foo\" , }; } Our former recommendation used the `Partial type` feature in TypeScript, which means that the current interface will fulfill a partial version on the wrapped interface. In that way we can extend defaultProps without any changes in the types! interface IMyComponentProps { firstProp? : string ; secondProp : IPerson []; } export class MyComponent extends React . Component < IMyComponentProps > { public static defaultProps : Partial < IMyComponentProps > = { firstProp : \"default\" , }; } The problem with this approach is it causes complex issues with the type inference working with `JSX.LibraryManagedAttributes`. Basically it causes the compiler to think that when creating a JSX expression with that component, that all of its props are optional. [See commentary by @ferdaber here](https://github.com/typescript-cheatsheets/react/issues/57) and [here](https://github.com/typescript-cheatsheets/react/issues/61). Something to add? File an issue .","title":"Misc Discussions and Knowledge"},{"location":"pages/react/typescript/basic/getting-started/error-boundaries/","text":"Option 1: Using react-error-boundary React-error-boundary - is a lightweight package ready to use for this scenario with TS support built-in. This approach also lets you avoid class components that are not that popular anymore. Options 2: Writing your custom error boundary component If you don't want to add a new npm package for this, you can also write your own ErrorBoundary component. import React , { Component , ErrorInfo , ReactNode } from \"react\" ; interface Props { children? : ReactNode ; } interface State { hasError : boolean ; } class ErrorBoundary extends Component < Props , State > { public state : State = { hasError : false }; public static getDerivedStateFromError ( _ : Error ) : State { // Update state so the next render will show the fallback UI. return { hasError : true }; } public componentDidCatch ( error : Error , errorInfo : ErrorInfo ) { console . error ( \"Uncaught error:\" , error , errorInfo ); } public render () { if ( this . state . hasError ) { return < h1 > Sorry .. there was an error < /h1>; } return this . props . children ; } } export default ErrorBoundary ; Something to add? File an issue .","title":"Error Boundaries"},{"location":"pages/react/typescript/basic/getting-started/error-boundaries/#option-1-using-react-error-boundary","text":"React-error-boundary - is a lightweight package ready to use for this scenario with TS support built-in. This approach also lets you avoid class components that are not that popular anymore.","title":"Option 1: Using react-error-boundary"},{"location":"pages/react/typescript/basic/getting-started/error-boundaries/#options-2-writing-your-custom-error-boundary-component","text":"If you don't want to add a new npm package for this, you can also write your own ErrorBoundary component. import React , { Component , ErrorInfo , ReactNode } from \"react\" ; interface Props { children? : ReactNode ; } interface State { hasError : boolean ; } class ErrorBoundary extends Component < Props , State > { public state : State = { hasError : false }; public static getDerivedStateFromError ( _ : Error ) : State { // Update state so the next render will show the fallback UI. return { hasError : true }; } public componentDidCatch ( error : Error , errorInfo : ErrorInfo ) { console . error ( \"Uncaught error:\" , error , errorInfo ); } public render () { if ( this . state . hasError ) { return < h1 > Sorry .. there was an error < /h1>; } return this . props . children ; } } export default ErrorBoundary ; Something to add? File an issue .","title":"Options 2: Writing your custom error boundary component"},{"location":"pages/react/typescript/basic/getting-started/forms-and-events/","text":"If performance is not an issue (and it usually isn't!), inlining handlers is easiest as you can just use type inference and contextual typing : const el = ( < button onClick = {( event ) => { /* event will be correctly typed automatically! */ }} /> ); But if you need to define your event handler separately, IDE tooling really comes in handy here, as the @type definitions come with a wealth of typing. Type what you are looking for and usually the autocomplete will help you out. Here is what it looks like for an onChange for a form event: type State = { text : string ; }; class App extends React . Component < Props , State > { state = { text : \"\" , }; // typing on RIGHT hand side of = onChange = ( e : React.FormEvent < HTMLInputElement > ) : void => { this . setState ({ text : e.currentTarget.value }); }; render () { return ( < div > < input type = \"text\" value = { this . state . text } onChange = { this . onChange } /> < /div> ); } } View in the TypeScript Playground Instead of typing the arguments and return values with React.FormEvent<> and void , you may alternatively apply types to the event handler itself ( contributed by @TomasHubelbauer ): // typing on LEFT hand side of = onChange : React.ChangeEventHandler < HTMLInputElement > = ( e ) => { this . setState ({ text : e.currentTarget.value }) } Why two ways to do the same thing? The first method uses an inferred method signature `(e: React.FormEvent ): void` and the second method enforces a type of the delegate provided by `@types/react`. So `React.ChangeEventHandler<>` is simply a \"blessed\" typing by `@types/react`, whereas you can think of the inferred method as more... _artisanally hand-rolled_. Either way it's a good pattern to know. [See our Github PR for more](https://github.com/typescript-cheatsheets/react/pull/24). Typing onSubmit, with Uncontrolled components in a Form If you don't quite care about the type of the event, you can just use React.SyntheticEvent. If your target form has custom named inputs that you'd like to access, you can use a type assertion: < form ref = { formRef } onSubmit = {( e : React.SyntheticEvent ) => { e . preventDefault (); const target = e . target as typeof e . target & { email : { value : string }; password : { value : string }; }; const email = target . email . value ; // typechecks! const password = target . password . value ; // typechecks! // etc... }} > < div > < label > Email : < input type = \"email\" name = \"email\" /> < /label> < /div> < div > < label > Password : < input type = \"password\" name = \"password\" /> < /label> < /div> < div > < input type = \"submit\" value = \"Log in\" /> < /div> < /form> View in the TypeScript Playground Of course, if you're making any sort of significant form, you should use Formik or React Hook Form , which are written in TypeScript. List of event types Event Type Description AnimationEvent CSS Animations. ChangeEvent Changing the value of <input> , <select> and <textarea> element. ClipboardEvent Using copy, paste and cut events. CompositionEvent Events that occur due to the user indirectly entering text (e.g. depending on Browser and PC setup, a popup window may appear with additional characters if you e.g. want to type Japanese on a US Keyboard) DragEvent Drag and drop interaction with a pointer device (e.g. mouse). FocusEvent Event that occurs when elements gets or loses focus. FormEvent Event that occurs whenever a form or form element gets/loses focus, a form element value is changed or the form is submitted. InvalidEvent Fired when validity restrictions of an input fails (e.g <input type=\"number\" max=\"10\"> and someone would insert number 20). KeyboardEvent User interaction with the keyboard. Each event describes a single key interaction. MouseEvent Events that occur due to the user interacting with a pointing device (e.g. mouse) PointerEvent Events that occur due to user interaction with a variety pointing of devices such as mouse, pen/stylus, a touchscreen and which also supports multi-touch. Unless you develop for older browsers (IE10 or Safari 12), pointer events are recommended. Extends UIEvent. TouchEvent Events that occur due to the user interacting with a touch device. Extends UIEvent. TransitionEvent CSS Transition. Not fully browser supported. Extends UIEvent UIEvent Base Event for Mouse, Touch and Pointer events. WheelEvent Scrolling on a mouse wheel or similar input device. (Note: wheel event should not be confused with the scroll event) SyntheticEvent The base event for all above events. Should be used when unsure about event type What about InputEvent ? You've probably noticed that there is no `InputEvent`. This is because it is not supported by Typescript as the event itself has no fully browser support and may behave differently in different browsers. You can use `KeyboardEvent` instead. Sources: - https://github.com/microsoft/TypeScript/issues/29441 - https://developer.mozilla.org/en-US/docs/Web/API/InputEvent - https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event","title":"Forms and Events"},{"location":"pages/react/typescript/basic/getting-started/forms-and-events/#list-of-event-types","text":"Event Type Description AnimationEvent CSS Animations. ChangeEvent Changing the value of <input> , <select> and <textarea> element. ClipboardEvent Using copy, paste and cut events. CompositionEvent Events that occur due to the user indirectly entering text (e.g. depending on Browser and PC setup, a popup window may appear with additional characters if you e.g. want to type Japanese on a US Keyboard) DragEvent Drag and drop interaction with a pointer device (e.g. mouse). FocusEvent Event that occurs when elements gets or loses focus. FormEvent Event that occurs whenever a form or form element gets/loses focus, a form element value is changed or the form is submitted. InvalidEvent Fired when validity restrictions of an input fails (e.g <input type=\"number\" max=\"10\"> and someone would insert number 20). KeyboardEvent User interaction with the keyboard. Each event describes a single key interaction. MouseEvent Events that occur due to the user interacting with a pointing device (e.g. mouse) PointerEvent Events that occur due to user interaction with a variety pointing of devices such as mouse, pen/stylus, a touchscreen and which also supports multi-touch. Unless you develop for older browsers (IE10 or Safari 12), pointer events are recommended. Extends UIEvent. TouchEvent Events that occur due to the user interacting with a touch device. Extends UIEvent. TransitionEvent CSS Transition. Not fully browser supported. Extends UIEvent UIEvent Base Event for Mouse, Touch and Pointer events. WheelEvent Scrolling on a mouse wheel or similar input device. (Note: wheel event should not be confused with the scroll event) SyntheticEvent The base event for all above events. Should be used when unsure about event type What about InputEvent ? You've probably noticed that there is no `InputEvent`. This is because it is not supported by Typescript as the event itself has no fully browser support and may behave differently in different browsers. You can use `KeyboardEvent` instead. Sources: - https://github.com/microsoft/TypeScript/issues/29441 - https://developer.mozilla.org/en-US/docs/Web/API/InputEvent - https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event","title":"List of event types"},{"location":"pages/react/typescript/basic/getting-started/forward-create-ref/","text":"Check the Hooks section for useRef . createRef : import { createRef , PureComponent } from \"react\" ; class CssThemeProvider extends PureComponent < Props > { private rootRef = createRef < HTMLDivElement > (); // like this render () { return < div ref = { this . rootRef } > { this . props . children } < /div>; } } forwardRef : import { forwardRef , ReactNode } from \"react\" ; interface Props { children? : ReactNode ; type : \"submit\" | \"button\" ; } export type Ref = HTMLButtonElement ; export const FancyButton = forwardRef < Ref , Props > (( props , ref ) => ( < button ref = { ref } className = \"MyClassName\" type = { props . type } > { props . children } < /button> )); Side note: the ref you get from forwardRef is mutable so you can assign to it if needed. This was done [on purpose](https://github.com/DefinitelyTyped/DefinitelyTyped/pull/43265/). You can make it immutable if you have to - assign `React.Ref` if you want to ensure nobody reassigns it: import { forwardRef , ReactNode , Ref } from \"react\" ; interface Props { children? : ReactNode ; type : \"submit\" | \"button\" ; } export const FancyButton = forwardRef ( ( props : Props , ref : Ref < HTMLButtonElement > // <-- here! ) => ( < button ref = { ref } className = \"MyClassName\" type = { props . type } > { props . children } < /button> ) ); If you are grabbing the props of a component that forwards refs, use ComponentPropsWithRef . Generic forwardRefs Read more context in https://fettblog.eu/typescript-react-generic-forward-refs/: Option 1 - Wrapper component type ClickableListProps < T > = { items : T []; onSelect : ( item : T ) => void ; mRef? : React.Ref < HTMLUListElement > | null ; }; export function ClickableList < T > ( props : ClickableListProps < T > ) { return ( < ul ref = { props . mRef } > { props . items . map (( item , i ) => ( < li key = { i } > < button onClick = {( el ) => props . onSelect ( item )} > Select < /button> { item } < /li> ))} < /ul> ); } Option 2 - Redeclare forwardRef // Redecalare forwardRef declare module \"react\" { function forwardRef < T , P = {} > ( render : ( props : P , ref : React.Ref < T > ) => React . ReactElement | null ) : ( props : P & React . RefAttributes < T > ) => React . ReactElement | null ; } // Just write your components like you're used to! import { forwardRef , ForwardedRef } from \"react\" ; interface ClickableListProps < T > { items : T []; onSelect : ( item : T ) => void ; } function ClickableListInner < T > ( props : ClickableListProps < T > , ref : ForwardedRef < HTMLUListElement > ) { return ( < ul ref = { ref } > { props . items . map (( item , i ) => ( < li key = { i } > < button onClick = {( el ) => props . onSelect ( item )} > Select < /button> { item } < /li> ))} < /ul> ); } export const ClickableList = forwardRef ( ClickableListInner ); More Info https://medium.com/@martin_hotell/react-refs-with-typescript-a32d56c4d315 You may also wish to do Conditional Rendering with forwardRef . Something to add? File an issue .","title":"forwardRef/createRef"},{"location":"pages/react/typescript/basic/getting-started/forward-create-ref/#generic-forwardrefs","text":"Read more context in https://fettblog.eu/typescript-react-generic-forward-refs/:","title":"Generic forwardRefs"},{"location":"pages/react/typescript/basic/getting-started/forward-create-ref/#option-1-wrapper-component","text":"type ClickableListProps < T > = { items : T []; onSelect : ( item : T ) => void ; mRef? : React.Ref < HTMLUListElement > | null ; }; export function ClickableList < T > ( props : ClickableListProps < T > ) { return ( < ul ref = { props . mRef } > { props . items . map (( item , i ) => ( < li key = { i } > < button onClick = {( el ) => props . onSelect ( item )} > Select < /button> { item } < /li> ))} < /ul> ); }","title":"Option 1 - Wrapper component"},{"location":"pages/react/typescript/basic/getting-started/forward-create-ref/#option-2-redeclare-forwardref","text":"// Redecalare forwardRef declare module \"react\" { function forwardRef < T , P = {} > ( render : ( props : P , ref : React.Ref < T > ) => React . ReactElement | null ) : ( props : P & React . RefAttributes < T > ) => React . ReactElement | null ; } // Just write your components like you're used to! import { forwardRef , ForwardedRef } from \"react\" ; interface ClickableListProps < T > { items : T []; onSelect : ( item : T ) => void ; } function ClickableListInner < T > ( props : ClickableListProps < T > , ref : ForwardedRef < HTMLUListElement > ) { return ( < ul ref = { ref } > { props . items . map (( item , i ) => ( < li key = { i } > < button onClick = {( el ) => props . onSelect ( item )} > Select < /button> { item } < /li> ))} < /ul> ); } export const ClickableList = forwardRef ( ClickableListInner );","title":"Option 2 - Redeclare forwardRef"},{"location":"pages/react/typescript/basic/getting-started/forward-create-ref/#more-info","text":"https://medium.com/@martin_hotell/react-refs-with-typescript-a32d56c4d315 You may also wish to do Conditional Rendering with forwardRef . Something to add? File an issue .","title":"More Info"},{"location":"pages/react/typescript/basic/getting-started/function-components/","text":"These can be written as normal functions that take a props argument and return a JSX element. // Declaring type of props - see \"Typing Component Props\" for more examples type AppProps = { message : string ; }; /* use `interface` if exporting so that consumers can extend */ // Easiest way to declare a Function Component; return type is inferred. const App = ({ message } : AppProps ) => < div > { message } < /div>; // you can choose annotate the return type so an error is raised if you accidentally return some other type const App = ({ message } : AppProps ) : JSX . Element => < div > { message } < /div>; // you can also inline the type declaration; eliminates naming the prop types, but looks repetitive const App = ({ message } : { message : string }) => < div > { message } < /div>; Tip: You might use Paul Shen's VS Code Extension to automate the type destructure declaration (incl a keyboard shortcut ). Why is React.FC discouraged? What about React.FunctionComponent / React.VoidFunctionComponent ? You may see this in many React+TypeScript codebases: const App : React.FunctionComponent < { message : string } > = ({ message }) => ( < div > { message } < /div> ); However, the general consensus today is that `React.FunctionComponent` (or the shorthand `React.FC`) is [discouraged](https://github.com/facebook/create-react-app/pull/8177). This is a nuanced opinion of course, but if you agree and want to remove `React.FC` from your codebase, you can use [this jscodeshift codemod](https://github.com/gndelia/codemod-replace-react-fc-typescript). Some differences from the \"normal function\" version: - `React.FunctionComponent` is explicit about the return type, while the normal function version is implicit (or else needs additional annotation). - It provides typechecking and autocomplete for static properties like `displayName`, `propTypes`, and `defaultProps`. - Note that there are some known issues using `defaultProps` with `React.FunctionComponent`. See [this issue for details](https://github.com/typescript-cheatsheets/react/issues/87). We maintain a separate `defaultProps` section you can also look up. - Before the [React 18 type updates](https://github.com/DefinitelyTyped/DefinitelyTyped/pull/56210), `React.FunctionComponent` provided an implicit definition of `children` (see below), which was heavily debated and is one of the reasons [`React.FC` was removed from the Create React App TypeScript template](https://github.com/facebook/create-react-app/pull/8177). // before React 18 types const Title : React.FunctionComponent < { title : string } > = ({ children , title , }) => < div title = { title } > { children } < /div>; (Deprecated) Using React.VoidFunctionComponent or React.VFC instead In [@types/react 16.9.48](https://github.com/DefinitelyTyped/DefinitelyTyped/pull/46643), the `React.VoidFunctionComponent` or `React.VFC` type was added for typing `children` explicitly. However, please be aware that `React.VFC` and `React.VoidFunctionComponent` were deprecated in React 18 (https://github.com/DefinitelyTyped/DefinitelyTyped/pull/59882), so this interim solution is no longer necessary or recommended in React 18+. Please use regular function components or `React.FC` instead. type Props = { foo : string }; // OK now, in future, error const FunctionComponent : React.FunctionComponent < Props > = ({ foo , children , } : Props ) => { return ( < div > { foo } { children } < /div> ); // OK }; // Error now, in future, deprecated const VoidFunctionComponent : React.VoidFunctionComponent < Props > = ({ foo , children , }) => { return ( < div > { foo } { children } < /div> ); }; - _In the future_, it may automatically mark props as `readonly`, though that's a moot point if the props object is destructured in the parameter list. In most cases it makes very little difference which syntax is used, but you may prefer the more explicit nature of `React.FunctionComponent`. Minor Pitfalls These patterns are not supported: **Conditional rendering** const MyConditionalComponent = ({ shouldRender = false }) => shouldRender ? < div /> : false ; // don't do this in JS either const el = < MyConditionalComponent /> ; // throws an error This is because due to limitations in the compiler, function components cannot return anything other than a JSX expression or `null`, otherwise it complains with a cryptic error message saying that the other type is not assignable to `Element`. **Array.fill** const MyArrayComponent = () => Array ( 5 ). fill ( < div /> ); const el2 = < MyArrayComponent /> ; // throws an error Unfortunately just annotating the function type will not help so if you really need to return other exotic types that React supports, you'd need to perform a type assertion: const MyArrayComponent = () => Array ( 5 ). fill ( < div /> ) as any as JSX . Element ; [See commentary by @ferdaber here](https://github.com/typescript-cheatsheets/react/issues/57).","title":"Function Components"},{"location":"pages/react/typescript/basic/getting-started/hooks/","text":"Hooks are supported in @types/react from v16.8 up . useState Type inference works very well for simple values: const [ state , setState ] = useState ( false ); // `state` is inferred to be a boolean // `setState` only takes booleans See also the Using Inferred Types section if you need to use a complex type that you've relied on inference for. However, many hooks are initialized with null-ish default values, and you may wonder how to provide types. Explicitly declare the type, and use a union type: const [ user , setUser ] = useState < User | null > ( null ); // later... setUser ( newUser ); You can also use type assertions if a state is initialized soon after setup and always has a value after: const [ user , setUser ] = useState < User > ({} as User ); // later... setUser ( newUser ); This temporarily \"lies\" to the TypeScript compiler that {} is of type User . You should follow up by setting the user state \u2014 if you don't, the rest of your code may rely on the fact that user is of type User and that may lead to runtime errors. useReducer You can use Discriminated Unions for reducer actions. Don't forget to define the return type of reducer, otherwise TypeScript will infer it. import { useReducer } from \"react\" ; const initialState = { count : 0 }; type ACTIONTYPE = | { type : \"increment\" ; payload : number } | { type : \"decrement\" ; payload : string }; function reducer ( state : typeof initialState , action : ACTIONTYPE ) { switch ( action . type ) { case \"increment\" : return { count : state.count + action . payload }; case \"decrement\" : return { count : state.count - Number ( action . payload ) }; default : throw new Error (); } } function Counter () { const [ state , dispatch ] = useReducer ( reducer , initialState ); return ( <> Count : { state . count } < button onClick = {() => dispatch ({ type : \"decrement\" , payload : \"5\" })} > - < /button> < button onClick = {() => dispatch ({ type : \"increment\" , payload : 5 })} > + < /button> < /> ); } View in the TypeScript Playground Usage with Reducer from redux In case you use the [redux](https://github.com/reduxjs/redux) library to write reducer function, It provides a convenient helper of the format `Reducer ` which takes care of the return type for you. So the above reducer example becomes: import { Reducer } from 'redux' ; export function reducer : Reducer < AppState , Action > () {} useEffect / useLayoutEffect Both of useEffect and useLayoutEffect are used for performing side effects and return an optional cleanup function which means if they don't deal with returning values, no types are necessary. When using useEffect , take care not to return anything other than a function or undefined , otherwise both TypeScript and React will yell at you. This can be subtle when using arrow functions: function DelayedEffect ( props : { timerMs : number }) { const { timerMs } = props ; useEffect ( () => setTimeout (() => { /* do stuff */ }, timerMs ), [ timerMs ] ); // bad example! setTimeout implicitly returns a number // because the arrow function body isn't wrapped in curly braces return null ; } Solution to the above example function DelayedEffect ( props : { timerMs : number }) { const { timerMs } = props ; useEffect (() => { setTimeout (() => { /* do stuff */ }, timerMs ); }, [ timerMs ]); // better; use the void keyword to make sure you return undefined return null ; } useRef In TypeScript, useRef returns a reference that is either read-only or mutable , depends on whether your type argument fully covers the initial value or not. Choose one that suits your use case. Option 1: DOM element ref To access a DOM element : provide only the element type as argument, and use null as initial value. In this case, the returned reference will have a read-only .current that is managed by React. TypeScript expects you to give this ref to an element's ref prop: function Foo () { // - If possible, prefer as specific as possible. For example, HTMLDivElement // is better than HTMLElement and way better than Element. // - Technical-wise, this returns RefObject<HTMLDivElement> const divRef = useRef < HTMLDivElement > ( null ); useEffect (() => { // Note that ref.current may be null. This is expected, because you may // conditionally render the ref-ed element, or you may forgot to assign it if ( ! divRef . current ) throw Error ( \"divRef is not assigned\" ); // Now divRef.current is sure to be HTMLDivElement doSomethingWith ( divRef . current ); }); // Give the ref to an element so React can manage it for you return < div ref = { divRef } > etc < /div>; } If you are sure that divRef.current will never be null, it is also possible to use the non-null assertion operator ! : const divRef = useRef < HTMLDivElement > ( null ! ); // Later... No need to check if it is null doSomethingWith ( divRef . current ); Note that you are opting out of type safety here - you will have a runtime error if you forget to assign the ref to an element in the render, or if the ref-ed element is conditionally rendered. Tip: Choosing which HTMLElement to use Refs demand specificity - it is not enough to just specify any old `HTMLElement`. If you don't know the name of the element type you need, you can check [lib.dom.ts](https://github.com/microsoft/TypeScript/blob/v3.9.5/lib/lib.dom.d.ts#L19224-L19343) or make an intentional type error and let the language service tell you: ![image](https://user-images.githubusercontent.com/6764957/116914284-1c436380-ac7d-11eb-9150-f52c571c5f07.png) Option 2: Mutable value ref To have a mutable value : provide the type you want, and make sure the initial value fully belongs to that type: function Foo () { // Technical-wise, this returns MutableRefObject<number | null> const intervalRef = useRef < number | null > ( null ); // You manage the ref yourself (that's why it's called MutableRefObject!) useEffect (() => { intervalRef . current = setInterval (...); return () => clearInterval ( intervalRef . current ); }, []); // The ref is not passed to any element's \"ref\" prop return < button onClick = { /* clearInterval the ref */ } > Cancel timer < /button>; } See also Related issue by @rajivpunjabi - Playground Example from Stefan Baumgartner - Playground useImperativeHandle We don't have much here, but this is from a discussion in our issues . Please contribute if you have anything to add! type ListProps < ItemType > = { items : ItemType []; innerRef? : React.Ref < { scrollToItem ( item : ItemType ) : void } > ; }; function List < ItemType > ( props : ListProps < ItemType > ) { useImperativeHandle ( props . innerRef , () => ({ scrollToItem () {}, })); return null ; } Custom Hooks If you are returning an array in your Custom Hook, you will want to avoid type inference as TypeScript will infer a union type (when you actually want different types in each position of the array). Instead, use TS 3.4 const assertions : import { useState } from \"react\" ; export function useLoading () { const [ isLoading , setState ] = useState ( false ); const load = ( aPromise : Promise < any > ) => { setState ( true ); return aPromise . finally (() => setState ( false )); }; return [ isLoading , load ] as const ; // infers [boolean, typeof load] instead of (boolean | typeof load)[] } View in the TypeScript Playground This way, when you destructure you actually get the right types based on destructure position. Alternative: Asserting a tuple return type If you are [having trouble with const assertions](https://github.com/babel/babel/issues/9800), you can also assert or define the function return types: import { useState } from \"react\" ; export function useLoading () { const [ isLoading , setState ] = useState ( false ); const load = ( aPromise : Promise < any > ) => { setState ( true ); return aPromise . finally (() => setState ( false )); }; return [ isLoading , load ] as [ boolean , ( aPromise : Promise < any > ) => Promise < any > ]; } A helper function that automatically types tuples can also be helpful if you write a lot of custom hooks: function tuplify < T extends any [] > ( ...elements : T ) { return elements ; } function useArray () { const numberValue = useRef ( 3 ). current ; const functionValue = useRef (() => {}). current ; return [ numberValue , functionValue ]; // type is (number | (() => void))[] } function useTuple () { const numberValue = useRef ( 3 ). current ; const functionValue = useRef (() => {}). current ; return tuplify ( numberValue , functionValue ); // type is [number, () => void] } Note that the React team recommends that custom hooks that return more than two values should use proper objects instead of tuples, however. More Hooks + TypeScript reading: https://medium.com/@jrwebdev/react-hooks-in-typescript-88fce7001d0d https://fettblog.eu/typescript-react/hooks/#useref If you are writing a React Hooks library, don't forget that you should also expose your types for users to use. Example React Hooks + TypeScript Libraries: https://github.com/mweststrate/use-st8 https://github.com/palmerhq/the-platform https://github.com/sw-yx/hooks Something to add? File an issue .","title":"Hooks"},{"location":"pages/react/typescript/basic/getting-started/hooks/#usestate","text":"Type inference works very well for simple values: const [ state , setState ] = useState ( false ); // `state` is inferred to be a boolean // `setState` only takes booleans See also the Using Inferred Types section if you need to use a complex type that you've relied on inference for. However, many hooks are initialized with null-ish default values, and you may wonder how to provide types. Explicitly declare the type, and use a union type: const [ user , setUser ] = useState < User | null > ( null ); // later... setUser ( newUser ); You can also use type assertions if a state is initialized soon after setup and always has a value after: const [ user , setUser ] = useState < User > ({} as User ); // later... setUser ( newUser ); This temporarily \"lies\" to the TypeScript compiler that {} is of type User . You should follow up by setting the user state \u2014 if you don't, the rest of your code may rely on the fact that user is of type User and that may lead to runtime errors.","title":"useState"},{"location":"pages/react/typescript/basic/getting-started/hooks/#usereducer","text":"You can use Discriminated Unions for reducer actions. Don't forget to define the return type of reducer, otherwise TypeScript will infer it. import { useReducer } from \"react\" ; const initialState = { count : 0 }; type ACTIONTYPE = | { type : \"increment\" ; payload : number } | { type : \"decrement\" ; payload : string }; function reducer ( state : typeof initialState , action : ACTIONTYPE ) { switch ( action . type ) { case \"increment\" : return { count : state.count + action . payload }; case \"decrement\" : return { count : state.count - Number ( action . payload ) }; default : throw new Error (); } } function Counter () { const [ state , dispatch ] = useReducer ( reducer , initialState ); return ( <> Count : { state . count } < button onClick = {() => dispatch ({ type : \"decrement\" , payload : \"5\" })} > - < /button> < button onClick = {() => dispatch ({ type : \"increment\" , payload : 5 })} > + < /button> < /> ); } View in the TypeScript Playground Usage with Reducer from redux In case you use the [redux](https://github.com/reduxjs/redux) library to write reducer function, It provides a convenient helper of the format `Reducer ` which takes care of the return type for you. So the above reducer example becomes: import { Reducer } from 'redux' ; export function reducer : Reducer < AppState , Action > () {}","title":"useReducer"},{"location":"pages/react/typescript/basic/getting-started/hooks/#useeffect-uselayouteffect","text":"Both of useEffect and useLayoutEffect are used for performing side effects and return an optional cleanup function which means if they don't deal with returning values, no types are necessary. When using useEffect , take care not to return anything other than a function or undefined , otherwise both TypeScript and React will yell at you. This can be subtle when using arrow functions: function DelayedEffect ( props : { timerMs : number }) { const { timerMs } = props ; useEffect ( () => setTimeout (() => { /* do stuff */ }, timerMs ), [ timerMs ] ); // bad example! setTimeout implicitly returns a number // because the arrow function body isn't wrapped in curly braces return null ; } Solution to the above example function DelayedEffect ( props : { timerMs : number }) { const { timerMs } = props ; useEffect (() => { setTimeout (() => { /* do stuff */ }, timerMs ); }, [ timerMs ]); // better; use the void keyword to make sure you return undefined return null ; }","title":"useEffect / useLayoutEffect"},{"location":"pages/react/typescript/basic/getting-started/hooks/#useref","text":"In TypeScript, useRef returns a reference that is either read-only or mutable , depends on whether your type argument fully covers the initial value or not. Choose one that suits your use case.","title":"useRef"},{"location":"pages/react/typescript/basic/getting-started/hooks/#option-1-dom-element-ref","text":"To access a DOM element : provide only the element type as argument, and use null as initial value. In this case, the returned reference will have a read-only .current that is managed by React. TypeScript expects you to give this ref to an element's ref prop: function Foo () { // - If possible, prefer as specific as possible. For example, HTMLDivElement // is better than HTMLElement and way better than Element. // - Technical-wise, this returns RefObject<HTMLDivElement> const divRef = useRef < HTMLDivElement > ( null ); useEffect (() => { // Note that ref.current may be null. This is expected, because you may // conditionally render the ref-ed element, or you may forgot to assign it if ( ! divRef . current ) throw Error ( \"divRef is not assigned\" ); // Now divRef.current is sure to be HTMLDivElement doSomethingWith ( divRef . current ); }); // Give the ref to an element so React can manage it for you return < div ref = { divRef } > etc < /div>; } If you are sure that divRef.current will never be null, it is also possible to use the non-null assertion operator ! : const divRef = useRef < HTMLDivElement > ( null ! ); // Later... No need to check if it is null doSomethingWith ( divRef . current ); Note that you are opting out of type safety here - you will have a runtime error if you forget to assign the ref to an element in the render, or if the ref-ed element is conditionally rendered. Tip: Choosing which HTMLElement to use Refs demand specificity - it is not enough to just specify any old `HTMLElement`. If you don't know the name of the element type you need, you can check [lib.dom.ts](https://github.com/microsoft/TypeScript/blob/v3.9.5/lib/lib.dom.d.ts#L19224-L19343) or make an intentional type error and let the language service tell you: ![image](https://user-images.githubusercontent.com/6764957/116914284-1c436380-ac7d-11eb-9150-f52c571c5f07.png)","title":"Option 1: DOM element ref"},{"location":"pages/react/typescript/basic/getting-started/hooks/#option-2-mutable-value-ref","text":"To have a mutable value : provide the type you want, and make sure the initial value fully belongs to that type: function Foo () { // Technical-wise, this returns MutableRefObject<number | null> const intervalRef = useRef < number | null > ( null ); // You manage the ref yourself (that's why it's called MutableRefObject!) useEffect (() => { intervalRef . current = setInterval (...); return () => clearInterval ( intervalRef . current ); }, []); // The ref is not passed to any element's \"ref\" prop return < button onClick = { /* clearInterval the ref */ } > Cancel timer < /button>; }","title":"Option 2: Mutable value ref"},{"location":"pages/react/typescript/basic/getting-started/hooks/#see-also","text":"Related issue by @rajivpunjabi - Playground Example from Stefan Baumgartner - Playground","title":"See also"},{"location":"pages/react/typescript/basic/getting-started/hooks/#useimperativehandle","text":"We don't have much here, but this is from a discussion in our issues . Please contribute if you have anything to add! type ListProps < ItemType > = { items : ItemType []; innerRef? : React.Ref < { scrollToItem ( item : ItemType ) : void } > ; }; function List < ItemType > ( props : ListProps < ItemType > ) { useImperativeHandle ( props . innerRef , () => ({ scrollToItem () {}, })); return null ; }","title":"useImperativeHandle"},{"location":"pages/react/typescript/basic/getting-started/hooks/#custom-hooks","text":"If you are returning an array in your Custom Hook, you will want to avoid type inference as TypeScript will infer a union type (when you actually want different types in each position of the array). Instead, use TS 3.4 const assertions : import { useState } from \"react\" ; export function useLoading () { const [ isLoading , setState ] = useState ( false ); const load = ( aPromise : Promise < any > ) => { setState ( true ); return aPromise . finally (() => setState ( false )); }; return [ isLoading , load ] as const ; // infers [boolean, typeof load] instead of (boolean | typeof load)[] } View in the TypeScript Playground This way, when you destructure you actually get the right types based on destructure position. Alternative: Asserting a tuple return type If you are [having trouble with const assertions](https://github.com/babel/babel/issues/9800), you can also assert or define the function return types: import { useState } from \"react\" ; export function useLoading () { const [ isLoading , setState ] = useState ( false ); const load = ( aPromise : Promise < any > ) => { setState ( true ); return aPromise . finally (() => setState ( false )); }; return [ isLoading , load ] as [ boolean , ( aPromise : Promise < any > ) => Promise < any > ]; } A helper function that automatically types tuples can also be helpful if you write a lot of custom hooks: function tuplify < T extends any [] > ( ...elements : T ) { return elements ; } function useArray () { const numberValue = useRef ( 3 ). current ; const functionValue = useRef (() => {}). current ; return [ numberValue , functionValue ]; // type is (number | (() => void))[] } function useTuple () { const numberValue = useRef ( 3 ). current ; const functionValue = useRef (() => {}). current ; return tuplify ( numberValue , functionValue ); // type is [number, () => void] } Note that the React team recommends that custom hooks that return more than two values should use proper objects instead of tuples, however.","title":"Custom Hooks"},{"location":"pages/react/typescript/basic/getting-started/hooks/#more-hooks-typescript-reading","text":"https://medium.com/@jrwebdev/react-hooks-in-typescript-88fce7001d0d https://fettblog.eu/typescript-react/hooks/#useref If you are writing a React Hooks library, don't forget that you should also expose your types for users to use.","title":"More Hooks + TypeScript reading:"},{"location":"pages/react/typescript/basic/getting-started/hooks/#example-react-hooks-typescript-libraries","text":"https://github.com/mweststrate/use-st8 https://github.com/palmerhq/the-platform https://github.com/sw-yx/hooks Something to add? File an issue .","title":"Example React Hooks + TypeScript Libraries:"},{"location":"pages/react/typescript/basic/getting-started/portals/","text":"Using ReactDOM.createPortal : const modalRoot = document . getElementById ( \"modal-root\" ) as HTMLElement ; // assuming in your html file has a div with id 'modal-root'; export class Modal extends React . Component < { children? : React.ReactNode } > { el : HTMLElement = document . createElement ( \"div\" ); componentDidMount () { modalRoot . appendChild ( this . el ); } componentWillUnmount () { modalRoot . removeChild ( this . el ); } render () { return ReactDOM . createPortal ( this . props . children , this . el ); } } View in the TypeScript Playground Using hooks Same as above but using hooks import { useEffect , useRef , ReactNode } from \"react\" ; import { createPortal } from \"react-dom\" ; const modalRoot = document . querySelector ( \"#modal-root\" ) as HTMLElement ; interface ModalProps { children? : ReactNode ; } const Modal = ({ children } : ModalProps ) => { const el = useRef ( document . createElement ( \"div\" )); useEffect (() => { // Use this in case CRA throws an error about react-hooks/exhaustive-deps const current = el . current ; // We assume `modalRoot` exists with '!' modalRoot ! . appendChild ( current ); return () => void modalRoot ! . removeChild ( current ); }, []); return createPortal ( children , el . current ); }; export default Modal ; [View in the TypeScript Playground](https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wFgAoUSWOAbzjSJRiQAVoYUAbOAXzmy4CTDAFoAJrjLkKAellwUAZyUBXEMAB2Aczha4ATwiqocABYwQPTMC5JzyxXHHAAbnADuwGGb3iCIBDi3KI4EDD4ANwUFGgQmkrwALJB3ABciMQwAHQAYgDCADy0vAB8cAC8cAAU9GhmtuJEmnwAlJXltBRwcPJwAKIgqlzM9j72aCMqDLiQmkiaEUp6CZyaaPauKFDAKABGdp7evihwRJjdM6twSDxVyOg5qkpIyJjVkmjqCzmMqCz9OwgH7VABELlcoNarWiMnIPQeGGyzyQ-UwmCQGGq1XaFU6lx6fQA6vZlGpgXAAAaBYJcBAQcKUm4AD2AiWWXh8BAAhNIej04tcadx6eFKs4IF9gYtsgBHVRIKAGADKt0xMGgYIAxMKuKEGTAoYplgAJAAqSQAMoCkNKYLD+XBdaKYNzsigwGAFuJ8g0uOJqrdsl8oM0YDCCWckDATC0cR04K4IMB-M6DW6iIFXEhfY1A1xgyYwxH4XwADRwADaAF0S5c+gBJVaofwQTBU26UivjK6cLSKvTLHuU86F0M-SmXIgxqAtP6jdiwbjVeqNZoVoMh4uw3iwuQKZ4obRIGLkTCqdYwYDxOAAQU98a6pcFiSrSjMEA8KVpFZeMGVH5fqkXDVuKiJPC8yqcCw1SYNwLwlj006xjUkaFBCpSRoSChGKoDAoC08EQHAYCqPAPhsishjGKYiTMMAaDmJY1i2CepaOuhbh+BUoK6vq4SgqUhSyBhWF0O+n7ftwcAAGQyah7GOnAhRSVwmGKUpykQmJmmJAYdgVLQT6aSZzhsmAIwGBkoLaDs4igmWOkmRZ6BIA2LAgEo1kbIsioOU5mlmEgwDaBY1kAIwAAyRa4Zj+RpplHOIPgZPgUUxWY+COQlpl7OgADWtnGJo4jWVA2h5dUkVltVtXZOFrTxYlSkAF5NuISDMhkACc3XZc1PS8LwAVwOpA1wA2+B4KcurcrQoJwKCw05UphR7GRGotHpBlGXlaCFTgF6lYtYAegYKAeA0YBLfw8T5FwDH5YZ8Z4nAf4AZJwGwfBSCtGUkwQC8wnrTAm1jYlwmiStwmqeDjp-WJa0bTed0Pftz24uU72Aap1QwFACp-aUEkeHAqnA8jmhw-yfREK+bbUSYiiemhIluODrQULwQA) Modal Component Usage Example: import { useState } from \"react\" ; function App () { const [ showModal , setShowModal ] = useState ( false ); return ( < div > // you can also put this in your static html file < div id = \"modal-root\" >< /div> { showModal && ( < Modal > < div style = {{ display : \"grid\" , placeItems : \"center\" , height : \"100vh\" , width : \"100vh\" , background : \"rgba(0,0,0,0.1)\" , zIndex : 99 , }} > I ' m a modal ! { \" \" } < button style = {{ background : \"papyawhip\" }} onClick = {() => setShowModal ( false )} > close < /button> < /div> < /Modal> )} < button onClick = {() => setShowModal ( true )} > show Modal < /button> // rest of your app < /div> ); } Context of Example This example is based on the [Event Bubbling Through Portal](https://reactjs.org/docs/portals.html#event-bubbling-through-portals) example of React docs.","title":"Portals"},{"location":"pages/react/typescript/basic/recommended/codebases/","text":"Apps https://github.com/devhubapp/devhub https://github.com/benawad/codeponder (with coding livestream! ) https://github.com/cypress-io/cypress-realworld-app https://github.com/alan2207/bulletproof-react Design Systems/Component Libraries https://github.com/seek-oss/braid-design-system/ (see how to use TS to validate props ) https://github.com/palantir/blueprint https://github.com/Shopify/polaris https://github.com/microsoft/fluentui Libraries https://github.com/formium/formik/ https://github.com/jaredpalmer/react-fns Misc https://github.com/NullVoxPopuli/react-vs-ember/tree/master/testing/react https://github.com/artsy/reaction https://github.com/artsy/emission (React Native) @reach/ui's community typings https://github.com/pshrmn/curi/tree/master/packages/router Older but still worth checking: https://bitbucket.org/atlassian/atlaskit-mk-2/src/master/ https://github.com/contiamo/operational-ui React Boilerplates: https://github.com/rwieruch/nextjs-firebase-authentication: Next.js + Firebase Starter: styled, tested, typed, and authenticated @jpavon/react-scripts-ts alternative react-scripts with all TypeScript features using ts-loader webpack config tool is a visual tool for creating webpack projects with React and TypeScript https://github.com/innFactory/create-react-app-material-typescript-redux ready to go template with Material-UI , routing and Redux React Native Boilerplates: contributed by @spoeck https://github.com/GeekyAnts/react-native-seed https://github.com/lopezjurip/ReactNativeTS https://github.com/emin93/react-native-template-typescript https://github.com/Microsoft/TypeScript-React-Native-Starter TS Library Codebases to study https://github.com/Azure/azure-sdk-for-js https://github.com/sindresorhus/is https://github.com/probot/probot https://github.com/intuit/auto https://github.com/polymer/tools https://github.com/nteract/nteract https://github.com/pgilad/leasot https://github.com/JasonEtco/actions-toolkit https://github.com/ferdaber/typescript-bootstrap/ https://github.com/contiamo/operational-scripts https://github.com/nobrainr/morphism https://github.com/slackapi/node-slack-sdk","title":"Recommended React"},{"location":"pages/react/typescript/basic/recommended/resources/","text":"me! https://twitter.com/swyx https://www.freecodecamp.org/news/how-to-build-a-todo-app-with-react-typescript-nodejs-and-mongodb/ https://github.com/piotrwitek/react-redux-typescript-guide - HIGHLY HIGHLY RECOMMENDED , i wrote this repo before knowing about this one, this has a lot of stuff I don't cover, including REDUX and JEST . 10 Bad TypeScript Habits : not using \"strict\": true using || for default values when we have ?? Using any instead of unknown for API responses using as assertion instead of Type Guards ( function isFoo(obj: unknown): obj is Foo {} ) as any in tests Marking optional properties instead of modeling which combinations exist by extending interfaces One letter generics Non-boolean if (nonboolean) checks bangbang checks if (!!nonboolean) != null to check for null and undefined Ultimate React Component Patterns with TypeScript 2.8 Basarat's TypeScript gitbook has a React section with an Egghead.io course as well. Palmer Group's TypeScript + React Guidelines as well as Jared's other work like disco.chat Sindre Sorhus' TypeScript Style Guide TypeScript React Starter Template by Microsoft A starter template for TypeScript and React with a detailed README describing how to use the two together. Note: this doesn't seem to be frequently updated anymore. Steve Kinney's React and TypeScript course on Frontend Masters (paid) Brian Holt's Intermediate React course on Frontend Masters (paid) - Converting App To TypeScript Section Mike North's Production TypeScript course on Frontend Masters (paid) TSX Guide by gojutin TypeScript conversion: Lyft's React-To-TypeScript conversion CLI Gustav Wengel's blogpost - converting a React codebase to TypeScript Microsoft React TypeScript conversion guide You? .","title":"TypeScript resources"},{"location":"pages/react/typescript/basic/recommended/talks/","text":"Ultimate React Component Patterns with TypeScript , by Martin Hochel, GeeCon Prague 2018 Please help contribute this new section!","title":"Talks"},{"location":"pages/react/typescript/basic/troubleshooting/learn-ts/","text":"Believe it or not, we have only barely introduced TypeScript here in this cheatsheet. If you are still facing TypeScript troubleshooting issues, it is likely that your understanding of TS is still too superficial. There is a whole world of generic type logic that you will eventually get into, however it becomes far less dealing with React than just getting good at TypeScript so it is out of scope here. But at least you can get productive in React now :) It is worth mentioning some resources to help you get started: Step through the 40+ examples under the playground's Examples section, written by @Orta Anders Hejlsberg's overview of TS: https://www.youtube.com/watch?v=ET4kT88JRXs Marius Schultz: https://blog.mariusschulz.com/series/typescript-evolution with an Egghead.io course Basarat's Deep Dive: https://basarat.gitbook.io/typescript/ Axel Rauschmeyer's Tackling TypeScript Rares Matei: Egghead.io course 's advanced TypeScript course on Egghead.io is great for newer typescript features and practical type logic applications (e.g. recursively making all properties of a type readonly ) Learn about Generics, Conditional types and Mapped types Shu Uesugi: TypeScript for Beginner Programmers Here is another TypeScript Error Guide that you can check for your errors.","title":"Learn TypeScript"},{"location":"pages/react/typescript/basic/troubleshooting/non-ts-files/","text":"Use declaration merging . If, say, you are using a third party JS script that attaches on to the window global, you can extend Window : declare global { interface Window { MyVendorThing : MyVendorType ; } } Likewise if you wish to \"import\" an image or other non TS/TSX file: // declaration.d.ts // anywhere in your project, NOT the same name as any of your .ts/tsx files declare module \"*.png\" ; // importing in a tsx file import * as logo from \"./logo.png\" ; Note that tsc cannot bundle these files for you, you will have to use Webpack or Parcel. Related issue: https://github.com/Microsoft/TypeScript-React-Starter/issues/12 and StackOverflow","title":"Troubleshooting"},{"location":"pages/react/typescript/basic/troubleshooting/official-typings-bugs/","text":"If you run into bugs with your library's official typings, you can copy them locally and tell TypeScript to use your local version using the \"paths\" field. In your tsconfig.json : { \"compilerOptions\" : { \"paths\" : { \"mobx-react\" : [ \"../typings/modules/mobx-react\" ] } } } Thanks to @adamrackis for the tip. If you just need to add an interface, or add missing members to an existing interface, you don't need to copy the whole typing package. Instead, you can use declaration merging : // my-typings.ts declare module \"plotly.js\" { interface PlotlyHTMLElement { removeAllListeners () : void ; } } // MyComponent.tsx import { PlotlyHTMLElement } from \"plotly.js\" ; const f = ( e : PlotlyHTMLElement ) => { e . removeAllListeners (); }; You dont always have to implement the module, you can simply import the module as any for a quick start: // my-typings.ts declare module \"plotly.js\" ; // each of its imports are `any` Because you don't have to explicitly import this, this is known as an ambient module declaration . You can do AMD's in a script-mode .ts file (no imports or exports), or a .d.ts file anywhere in your project. You can also do ambient variable and ambient type declarations: // ambient utiltity type type ToArray < T > = T extends unknown [] ? T : T []; // ambient variable declare let process : { env : { NODE_ENV : \"development\" | \"production\" ; }; }; process = { env : { NODE_ENV : \"production\" , }, }; You can see examples of these included in the built in type declarations in the lib field of tsconfig.json","title":"Fixing bugs"},{"location":"pages/react/typescript/basic/troubleshooting/operators/","text":"typeof and instanceof : type query used for refinement keyof : get keys of an object. keyof T is an operator to tell you what values of k can be used for obj[k] . Some misconceptions here . O[K] : property lookup [K in O] : mapped types + or - or readonly or ? : addition and subtraction and readonly and optional modifiers x ? Y : Z : Conditional types for generic types, type aliases, function parameter types ! : Nonnull assertion for nullable types = : Generic type parameter default for generic types as : type assertion is : type guard for function return types Conditional Types are a difficult topic to get around so here are some extra resources: fully walked through explanation https://artsy.github.io/blog/2018/11/21/conditional-types-in-typescript/ Bailing out and other advanced topics https://github.com/sw-yx/ts-spec/blob/master/conditional-types.md Basarat's video https://www.youtube.com/watch?v=SbVgPQDealg&list=PLYvdvJlnTOjF6aJsWWAt7kZRJvzw-en8B&index=2&t=0s Generics, Conditional types and Mapped types","title":"Troubleshooting: Operators"},{"location":"pages/react/typescript/basic/troubleshooting/ts-config/","text":"You can find all the Compiler options in the TypeScript docs . The new TS docs also has per-flag annotations of what each does . This is the setup I roll with for APPS (not libraries - for libraries you may wish to see the settings we use in tsdx ): { \"compilerOptions\" : { \"incremental\" : true , \"outDir\" : \"build/lib\" , \"target\" : \"es5\" , \"module\" : \"esnext\" , \"lib\" : [ \"DOM\" , \"ESNext\" ], \"sourceMap\" : true , \"importHelpers\" : true , \"declaration\" : true , \"rootDir\" : \"src\" , \"strict\" : true , \"noUnusedLocals\" : true , \"noUnusedParameters\" : true , \"noImplicitReturns\" : true , \"noFallthroughCasesInSwitch\" : true , \"allowJs\" : false , \"jsx\" : \"react\" , \"moduleResolution\" : \"node\" , \"baseUrl\" : \"src\" , \"forceConsistentCasingInFileNames\" : true , \"esModuleInterop\" : true , \"suppressImplicitAnyIndexErrors\" : true , \"allowSyntheticDefaultImports\" : true , \"experimentalDecorators\" : true }, \"include\" : [ \"src/**/*\" ], \"exclude\" : [ \"node_modules\" , \"build\" , \"scripts\" ] } You can find more recommended TS config here . Please open an issue and discuss if there are better recommended choices for React. Selected flags and why we like them: esModuleInterop : disables namespace imports ( import * as foo from \"foo\" ) and enables CJS/AMD/UMD style imports ( import fs from \"fs\" ) strict : strictPropertyInitialization forces you to initialize class properties or explicitly declare that they can be undefined. You can opt out of this with a definite assignment assertion. \"typeRoots\": [\"./typings\", \"./node_modules/@types\"] : By default, TypeScript looks in node_modules/@types and parent folders for third party type declarations. You may wish to override this default resolution so you can put all your global type declarations in a special typings folder. Compilation time grows linearly with size of codebase. For large projects, you will want to use Project References . See our ADVANCED cheatsheet for commentary.","title":"Troubleshooting: tsconfig"},{"location":"pages/react/typescript/basic/troubleshooting/types/","text":"\u26a0\ufe0f Have you read the TypeScript FAQ Your answer might be there! Facing weird type errors? You aren't alone. This is the hardest part of using TypeScript with React. Be patient - you are learning a new language after all. However, the more you get good at this, the less time you'll be working against the compiler and the more the compiler will be working for you! Try to avoid typing with any as much as possible to experience the full benefits of TypeScript. Instead, let's try to be familiar with some of the common strategies to solve these issues. Union Types and Type Guarding Union types are handy for solving some of these typing problems: class App extends React . Component < {}, { count : number | null ; // like this } > { state = { count : null , }; render () { return < div onClick = {() => this . increment ( 1 )} > { this . state . count } < /div>; } increment = ( amt : number ) => { this . setState (( state ) => ({ count : ( state . count || 0 ) + amt , })); }; } View in the TypeScript Playground Type Guarding : Sometimes Union Types solve a problem in one area but create another downstream. If A and B are both object types, A | B isn't \"either A or B\", it is \"A or B or both at once\", which causes some confusion if you expected it to be the former. Learn how to write checks, guards, and assertions (also see the Conditional Rendering section below). For example: interface Admin { role : string ; } interface User { email : string ; } // Method 1: use `in` keyword function redirect ( user : Admin | User ) { if ( \"role\" in user ) { // use the `in` operator for typeguards since TS 2.7+ routeToAdminPage ( user . role ); } else { routeToHomePage ( user . email ); } } // Method 2: custom type guard, does the same thing in older TS versions or where `in` isnt enough function isAdmin ( user : Admin | User ) : user is Admin { return ( user as any ). role !== undefined ; } View in the TypeScript Playground Method 2 is also known as User-Defined Type Guards and can be really handy for readable code. This is how TS itself refines types with typeof and instanceof . If you need if...else chains or the switch statement instead, it should \"just work\", but look up Discriminated Unions if you need help. (See also: Basarat's writeup ). This is handy in typing reducers for useReducer or Redux. Optional Types If a component has an optional prop, add a question mark and assign during destructure (or use defaultProps). class MyComponent extends React . Component < { message? : string ; // like this } > { render () { const { message = \"default\" } = this . props ; return < div > { message } < /div>; } } You can also use a ! character to assert that something is not undefined, but this is not encouraged. Something to add? File an issue with your suggestions! Enum Types We recommend avoiding using enums as far as possible . Enums have a few documented issues (the TS team agrees ). A simpler alternative to enums is just declaring a union type of string literals: export declare type Position = \"left\" | \"right\" | \"top\" | \"bottom\" ; If you must use enums, remember that enums in TypeScript default to numbers. You will usually want to use them as strings instead: export enum ButtonSizes { default = \"default\" , small = \"small\" , large = \"large\" , } // usage export const PrimaryButton = ( props : Props & React . HTMLProps < HTMLButtonElement > ) => < Button size = { ButtonSizes . default } {... props } /> ; Type Assertion Sometimes you know better than TypeScript that the type you're using is narrower than it thinks, or union types need to be asserted to a more specific type to work with other APIs, so assert with the as keyword. This tells the compiler you know better than it does. class MyComponent extends React . Component < { message : string ; } > { render () { const { message } = this . props ; return ( < Component2 message = { message as SpecialMessageType } > { message } < /Component2> ); } } View in the TypeScript Playground Note that you cannot assert your way to anything - basically it is only for refining types. Therefore it is not the same as \"casting\" a type. You can also assert a property is non-null, when accessing it: element . parentNode ! . removeChild ( element ); // ! before the period myFunction ( document . getElementById ( dialog . id ! ) ! ); // ! after the property accessing let userID !: string ; // definite assignment assertion... be careful! Of course, try to actually handle the null case instead of asserting :) Simulating Nominal Types TS' structural typing is handy, until it is inconvenient. However you can simulate nominal typing with type branding : type OrderID = string & { readonly brand : unique symbol }; type UserID = string & { readonly brand : unique symbol }; type ID = OrderID | UserID ; We can create these values with the Companion Object Pattern: function OrderID ( id : string ) { return id as OrderID ; } function UserID ( id : string ) { return id as UserID ; } Now TypeScript will disallow you from using the wrong ID in the wrong place: function queryForUser ( id : UserID ) { // ... } queryForUser ( OrderID ( \"foobar\" )); // Error, Argument of type 'OrderID' is not assignable to parameter of type 'UserID' In future you can use the unique keyword to brand. See this PR . Intersection Types Adding two types together can be handy, for example when your component is supposed to mirror the props of a native component like a button : export interface PrimaryButtonProps { label : string ; } export const PrimaryButton = ( props : PrimaryButtonProps & React . ButtonHTMLAttributes < HTMLButtonElement > ) => { // do custom buttony stuff return < button {... props } > { props . label } < /button>; }; Playground here You can also use Intersection Types to make reusable subsets of props for similar components: type BaseProps = { className? : string , style? : React.CSSProperties name : string // used in both } type DogProps = { tailsCount : number } type HumanProps = { handsCount : number } export const Human = ( props : BaseProps & HumanProps ) => // ... export const Dog = ( props : BaseProps & DogProps ) => // ... View in the TypeScript Playground Make sure not to confuse Intersection Types (which are and operations) with Union Types (which are or operations). Union Types This section is yet to be written (please contribute!). Meanwhile, see our commentary on Union Types usecases . The ADVANCED cheatsheet also has information on Discriminated Union Types, which are helpful when TypeScript doesn't seem to be narrowing your union type as you expect. Overloading Function Types Specifically when it comes to functions, you may need to overload instead of union type. The most common way function types are written uses the shorthand: type FunctionType1 = ( x : string , y : number ) => number ; But this doesn't let you do any overloading. If you have the implementation, you can put them after each other with the function keyword: function pickCard ( x : { suit : string ; card : number }[]) : number ; function pickCard ( x : number ) : { suit : string ; card : number }; function pickCard ( x ) : any { // implementation with combined signature // ... } However, if you don't have an implementation and are just writing a .d.ts definition file, this won't help you either. In this case you can forego any shorthand and write them the old-school way. The key thing to remember here is as far as TypeScript is concerned, functions are just callable objects with no key : type pickCard = { ( x : { suit : string ; card : number }[]) : number ; ( x : number ) : { suit : string ; card : number }; // no need for combined signature in this form // you can also type static properties of functions here eg `pickCard.wasCalled` }; Note that when you implement the actual overloaded function, the implementation will need to declare the combined call signature that you'll be handling, it won't be inferred for you. You can readily see examples of overloads in DOM APIs, e.g. createElement . Read more about Overloading in the Handbook. Using Inferred Types Leaning on TypeScript's Type Inference is great... until you realize you need a type that was inferred, and have to go back and explicitly declare types/interfaces so you can export them for reuse. Fortunately, with typeof , you won't have to do that. Just use it on any value: const [ state , setState ] = useState ({ foo : 1 , bar : 2 , }); // state's type inferred to be {foo: number, bar: number} const someMethod = ( obj : typeof state ) => { // grabbing the type of state even though it was inferred // some code using obj setState ( obj ); // this works }; Using Partial Types Working with slicing state and props is common in React. Again, you don't really have to go and explicitly redefine your types if you use the Partial generic type: const [ state , setState ] = useState ({ foo : 1 , bar : 2 , }); // state's type inferred to be {foo: number, bar: number} // NOTE: stale state merging is not actually encouraged in useState // we are just demonstrating how to use Partial here const partialStateUpdate = ( obj : Partial < typeof state > ) => setState ({ ... state , ... obj }); // later on... partialStateUpdate ({ foo : 2 }); // this works Minor caveats on using Partial Note that there are some TS users who don't agree with using `Partial` as it behaves today. See [subtle pitfalls of the above example here](https://twitter.com/ferdaber/status/1084798596027957248), and check out this long discussion on [why @types/react uses Pick instead of Partial](https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18365). The Types I need weren't exported! This can be annoying but here are ways to grab the types! Grabbing the Prop types of a component: Use React.ComponentProps and typeof , and optionally Omit any overlapping types import { Button } from \"library\" ; // but doesn't export ButtonProps! oh no! type ButtonProps = React . ComponentProps < typeof Button > ; // no problem! grab your own! type AlertButtonProps = Omit < ButtonProps , \"onClick\" > ; // modify const AlertButton = ( props : AlertButtonProps ) => ( < Button onClick = {() => alert ( \"hello\" )} {... props } /> ); You may also use ComponentPropsWithoutRef (instead of ComponentProps) and ComponentPropsWithRef (if your component specifically forwards refs) Grabbing the return type of a function: use ReturnType : // inside some library - return type { baz: number } is inferred but not exported function foo ( bar : string ) { return { baz : 1 }; } // inside your app, if you need { baz: number } type FooReturn = ReturnType < typeof foo > ; // { baz: number } In fact you can grab virtually anything public: see this blogpost from Ivan Koshelev function foo () { return { a : 1 , b : 2 , subInstArr : [ { c : 3 , d : 4 , }, ], }; } type InstType = ReturnType < typeof foo > ; type SubInstArr = InstType [ \"subInstArr\" ]; type SubInstType = SubInstArr [ 0 ]; let baz : SubInstType = { c : 5 , d : 6 , // type checks ok! }; //You could just write a one-liner, //But please make sure it is forward-readable //(you can understand it from reading once left-to-right with no jumps) type SubInstType2 = ReturnType < typeof foo > [ \"subInstArr\" ][ 0 ]; let baz2 : SubInstType2 = { c : 5 , d : 6 , // type checks ok! }; TS also ships with a Parameters utility type for extracting the parameters of a function for anything more \"custom\", the infer keyword is the basic building block for this, but takes a bit of getting used to. Look at the source code for the above utility types, and this example to get the idea. Basarat also has a good video on infer . The Types I need don't exist! What's more annoying than modules with unexported types? Modules that are untyped ! Before you proceed - make sure you have checked that types don't exist in DefinitelyTyped or TypeSearch Fret not! There are more than a couple of ways in which you can solve this problem. Slapping any on everything A lazier way would be to create a new type declaration file, say typedec.d.ts \u2013 if you don't already have one. Ensure that the path to file is resolvable by TypeScript by checking the include array in the tsconfig.json file at the root of your directory. // inside tsconfig.json { // ... \"include\" : [ \"src\" // automatically resolves if the path to declaration is src/typedec.d.ts ] // ... } Within this file, add the declare syntax for your desired module, say my-untyped-module \u2013 to the declaration file: // inside typedec.d.ts declare module \"my-untyped-module\" ; This one-liner alone is enough if you just need it to work without errors. A even hackier, write-once-and-forget way would be to use \"*\" instead which would then apply the Any type for all existing and future untyped modules. This solution works well as a workaround if you have less than a couple untyped modules. Anything more, you now have a ticking type-bomb in your hands. The only way of circumventing this problem would be to define the missing types for those untyped modules as explained in the following sections. Autogenerate types You can use TypeScript with --allowJs and --declaration to see TypeScript's \"best guess\" at the types of the library. If this doesn't work well enough, use dts-gen to use the runtime shape of the object to accurately enumerate all available properties. This tends to be very accurate, BUT the tool does not yet support scraping JSDoc comments to populate additional types. npm install -g dts-gen dts-gen -m <your-module> There are other automated JS to TS conversion tools and migration strategies - see our MIGRATION cheatsheet . Typing Exported Hooks Typing Hooks is just like typing pure functions. The following steps work under two assumptions: You have already created a type declaration file as stated earlier in the section. You have access to the source code - specifically the code that directly exports the functions you will be using. In most cases, it would be housed in an index.js file. Typically you need a minimum of two type declarations (one for Input Prop and the other for Return Prop ) to define a hook completely. Suppose the hook you wish to type follows the following structure, // ... const useUntypedHook = ( prop ) => { // some processing happens here return { /* ReturnProps */ }; }; export default useUntypedHook ; then, your type declaration should most likely follow the following syntax. declare module 'use-untyped-hook' { export interface InputProps { ... } // type declaration for prop export interface ReturnProps { ... } // type declaration for return props export default function useUntypedHook ( prop : InputProps // ... ) : ReturnProps ; } For instance, the useDarkMode hook exports the functions that follows a similar structure. // inside src/index.js const useDarkMode = ( initialValue = false , // -> input props / config props to be exported { // -> input props / config props to be exported element , classNameDark , classNameLight , onChange , storageKey = \"darkMode\" , storageProvider , global , } = {} ) => { // ... return { // -> return props to be exported value : state , enable : useCallback (() => setState ( true ), [ setState ]), disable : useCallback (() => setState ( false ), [ setState ]), toggle : useCallback (() => setState (( current ) => ! current ), [ setState ]), }; }; export default useDarkMode ; As the comments suggest, exporting these config props and return props following the aforementioned structure will result in the following type export. declare module \"use-dark-mode\" { /** * A config object allowing you to specify certain aspects of `useDarkMode` */ export interface DarkModeConfig { classNameDark? : string ; // A className to set \"dark mode\". Default = \"dark-mode\". classNameLight? : string ; // A className to set \"light mode\". Default = \"light-mode\". element? : HTMLElement ; // The element to apply the className. Default = `document.body` onChange ?: ( val? : boolean ) => void ; // Override the default className handler with a custom callback. storageKey? : string ; // Specify the `localStorage` key. Default = \"darkMode\". Set to `null` to disable persistent storage. storageProvider? : WindowLocalStorage ; // A storage provider. Default = `localStorage`. global? : Window ; // The global object. Default = `window`. } /** * An object returned from a call to `useDarkMode`. */ export interface DarkMode { readonly value : boolean ; enable : () => void ; disable : () => void ; toggle : () => void ; } /** * A custom React Hook to help you implement a \"dark mode\" component for your application. */ export default function useDarkMode ( initialState? : boolean , config? : DarkModeConfig ) : DarkMode ; } Typing Exported Components In case of typing untyped class components, there's almost no difference in approach except for the fact that after declaring the types, you export the extend the type using class UntypedClassComponent extends React.Component<UntypedClassComponentProps, any> {} where UntypedClassComponentProps holds the type declaration. For instance, sw-yx's Gist on React Router 6 types implemented a similar method for typing the then untyped RR6. declare module \"react-router-dom\" { import * as React from 'react' ; // ... type NavigateProps < T > = { to : string | number , replace? : boolean , state? : T } //... export class Navigate < T = any > extends React . Component < NavigateProps < T >> {} // ... For more information on creating type definitions for class components, you can refer to this post for reference. Frequent Known Problems with TypeScript Just a list of stuff that React developers frequently run into, that TS has no solution for. Not necessarily TSX only. TypeScript doesn't narrow after an object element null check Ref: https://mobile.twitter.com/tannerlinsley/status/1390409931627499523. see also https://github.com/microsoft/TypeScript/issues/9998 TypeScript doesn't let you restrict the type of children Guaranteeing typesafety for this kind of API isn't possible: < Menu > < MenuItem /> { /* ok */ } < MenuLink /> { /* ok */ } < div > { /* error */ } < /Menu> Source: https://twitter.com/ryanflorence/status/1085745787982700544?s=20","title":"Troubleshooting: Types"},{"location":"pages/react/typescript/basic/troubleshooting/types/#union-types-and-type-guarding","text":"Union types are handy for solving some of these typing problems: class App extends React . Component < {}, { count : number | null ; // like this } > { state = { count : null , }; render () { return < div onClick = {() => this . increment ( 1 )} > { this . state . count } < /div>; } increment = ( amt : number ) => { this . setState (( state ) => ({ count : ( state . count || 0 ) + amt , })); }; } View in the TypeScript Playground Type Guarding : Sometimes Union Types solve a problem in one area but create another downstream. If A and B are both object types, A | B isn't \"either A or B\", it is \"A or B or both at once\", which causes some confusion if you expected it to be the former. Learn how to write checks, guards, and assertions (also see the Conditional Rendering section below). For example: interface Admin { role : string ; } interface User { email : string ; } // Method 1: use `in` keyword function redirect ( user : Admin | User ) { if ( \"role\" in user ) { // use the `in` operator for typeguards since TS 2.7+ routeToAdminPage ( user . role ); } else { routeToHomePage ( user . email ); } } // Method 2: custom type guard, does the same thing in older TS versions or where `in` isnt enough function isAdmin ( user : Admin | User ) : user is Admin { return ( user as any ). role !== undefined ; } View in the TypeScript Playground Method 2 is also known as User-Defined Type Guards and can be really handy for readable code. This is how TS itself refines types with typeof and instanceof . If you need if...else chains or the switch statement instead, it should \"just work\", but look up Discriminated Unions if you need help. (See also: Basarat's writeup ). This is handy in typing reducers for useReducer or Redux.","title":"Union Types and Type Guarding"},{"location":"pages/react/typescript/basic/troubleshooting/types/#optional-types","text":"If a component has an optional prop, add a question mark and assign during destructure (or use defaultProps). class MyComponent extends React . Component < { message? : string ; // like this } > { render () { const { message = \"default\" } = this . props ; return < div > { message } < /div>; } } You can also use a ! character to assert that something is not undefined, but this is not encouraged. Something to add? File an issue with your suggestions!","title":"Optional Types"},{"location":"pages/react/typescript/basic/troubleshooting/types/#enum-types","text":"We recommend avoiding using enums as far as possible . Enums have a few documented issues (the TS team agrees ). A simpler alternative to enums is just declaring a union type of string literals: export declare type Position = \"left\" | \"right\" | \"top\" | \"bottom\" ; If you must use enums, remember that enums in TypeScript default to numbers. You will usually want to use them as strings instead: export enum ButtonSizes { default = \"default\" , small = \"small\" , large = \"large\" , } // usage export const PrimaryButton = ( props : Props & React . HTMLProps < HTMLButtonElement > ) => < Button size = { ButtonSizes . default } {... props } /> ;","title":"Enum Types"},{"location":"pages/react/typescript/basic/troubleshooting/types/#type-assertion","text":"Sometimes you know better than TypeScript that the type you're using is narrower than it thinks, or union types need to be asserted to a more specific type to work with other APIs, so assert with the as keyword. This tells the compiler you know better than it does. class MyComponent extends React . Component < { message : string ; } > { render () { const { message } = this . props ; return ( < Component2 message = { message as SpecialMessageType } > { message } < /Component2> ); } } View in the TypeScript Playground Note that you cannot assert your way to anything - basically it is only for refining types. Therefore it is not the same as \"casting\" a type. You can also assert a property is non-null, when accessing it: element . parentNode ! . removeChild ( element ); // ! before the period myFunction ( document . getElementById ( dialog . id ! ) ! ); // ! after the property accessing let userID !: string ; // definite assignment assertion... be careful! Of course, try to actually handle the null case instead of asserting :)","title":"Type Assertion"},{"location":"pages/react/typescript/basic/troubleshooting/types/#simulating-nominal-types","text":"TS' structural typing is handy, until it is inconvenient. However you can simulate nominal typing with type branding : type OrderID = string & { readonly brand : unique symbol }; type UserID = string & { readonly brand : unique symbol }; type ID = OrderID | UserID ; We can create these values with the Companion Object Pattern: function OrderID ( id : string ) { return id as OrderID ; } function UserID ( id : string ) { return id as UserID ; } Now TypeScript will disallow you from using the wrong ID in the wrong place: function queryForUser ( id : UserID ) { // ... } queryForUser ( OrderID ( \"foobar\" )); // Error, Argument of type 'OrderID' is not assignable to parameter of type 'UserID' In future you can use the unique keyword to brand. See this PR .","title":"Simulating Nominal Types"},{"location":"pages/react/typescript/basic/troubleshooting/types/#intersection-types","text":"Adding two types together can be handy, for example when your component is supposed to mirror the props of a native component like a button : export interface PrimaryButtonProps { label : string ; } export const PrimaryButton = ( props : PrimaryButtonProps & React . ButtonHTMLAttributes < HTMLButtonElement > ) => { // do custom buttony stuff return < button {... props } > { props . label } < /button>; }; Playground here You can also use Intersection Types to make reusable subsets of props for similar components: type BaseProps = { className? : string , style? : React.CSSProperties name : string // used in both } type DogProps = { tailsCount : number } type HumanProps = { handsCount : number } export const Human = ( props : BaseProps & HumanProps ) => // ... export const Dog = ( props : BaseProps & DogProps ) => // ... View in the TypeScript Playground Make sure not to confuse Intersection Types (which are and operations) with Union Types (which are or operations).","title":"Intersection Types"},{"location":"pages/react/typescript/basic/troubleshooting/types/#union-types","text":"This section is yet to be written (please contribute!). Meanwhile, see our commentary on Union Types usecases . The ADVANCED cheatsheet also has information on Discriminated Union Types, which are helpful when TypeScript doesn't seem to be narrowing your union type as you expect.","title":"Union Types"},{"location":"pages/react/typescript/basic/troubleshooting/types/#overloading-function-types","text":"Specifically when it comes to functions, you may need to overload instead of union type. The most common way function types are written uses the shorthand: type FunctionType1 = ( x : string , y : number ) => number ; But this doesn't let you do any overloading. If you have the implementation, you can put them after each other with the function keyword: function pickCard ( x : { suit : string ; card : number }[]) : number ; function pickCard ( x : number ) : { suit : string ; card : number }; function pickCard ( x ) : any { // implementation with combined signature // ... } However, if you don't have an implementation and are just writing a .d.ts definition file, this won't help you either. In this case you can forego any shorthand and write them the old-school way. The key thing to remember here is as far as TypeScript is concerned, functions are just callable objects with no key : type pickCard = { ( x : { suit : string ; card : number }[]) : number ; ( x : number ) : { suit : string ; card : number }; // no need for combined signature in this form // you can also type static properties of functions here eg `pickCard.wasCalled` }; Note that when you implement the actual overloaded function, the implementation will need to declare the combined call signature that you'll be handling, it won't be inferred for you. You can readily see examples of overloads in DOM APIs, e.g. createElement . Read more about Overloading in the Handbook.","title":"Overloading Function Types"},{"location":"pages/react/typescript/basic/troubleshooting/types/#using-inferred-types","text":"Leaning on TypeScript's Type Inference is great... until you realize you need a type that was inferred, and have to go back and explicitly declare types/interfaces so you can export them for reuse. Fortunately, with typeof , you won't have to do that. Just use it on any value: const [ state , setState ] = useState ({ foo : 1 , bar : 2 , }); // state's type inferred to be {foo: number, bar: number} const someMethod = ( obj : typeof state ) => { // grabbing the type of state even though it was inferred // some code using obj setState ( obj ); // this works };","title":"Using Inferred Types"},{"location":"pages/react/typescript/basic/troubleshooting/types/#using-partial-types","text":"Working with slicing state and props is common in React. Again, you don't really have to go and explicitly redefine your types if you use the Partial generic type: const [ state , setState ] = useState ({ foo : 1 , bar : 2 , }); // state's type inferred to be {foo: number, bar: number} // NOTE: stale state merging is not actually encouraged in useState // we are just demonstrating how to use Partial here const partialStateUpdate = ( obj : Partial < typeof state > ) => setState ({ ... state , ... obj }); // later on... partialStateUpdate ({ foo : 2 }); // this works Minor caveats on using Partial Note that there are some TS users who don't agree with using `Partial` as it behaves today. See [subtle pitfalls of the above example here](https://twitter.com/ferdaber/status/1084798596027957248), and check out this long discussion on [why @types/react uses Pick instead of Partial](https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18365).","title":"Using Partial Types"},{"location":"pages/react/typescript/basic/troubleshooting/types/#the-types-i-need-werent-exported","text":"This can be annoying but here are ways to grab the types! Grabbing the Prop types of a component: Use React.ComponentProps and typeof , and optionally Omit any overlapping types import { Button } from \"library\" ; // but doesn't export ButtonProps! oh no! type ButtonProps = React . ComponentProps < typeof Button > ; // no problem! grab your own! type AlertButtonProps = Omit < ButtonProps , \"onClick\" > ; // modify const AlertButton = ( props : AlertButtonProps ) => ( < Button onClick = {() => alert ( \"hello\" )} {... props } /> ); You may also use ComponentPropsWithoutRef (instead of ComponentProps) and ComponentPropsWithRef (if your component specifically forwards refs) Grabbing the return type of a function: use ReturnType : // inside some library - return type { baz: number } is inferred but not exported function foo ( bar : string ) { return { baz : 1 }; } // inside your app, if you need { baz: number } type FooReturn = ReturnType < typeof foo > ; // { baz: number } In fact you can grab virtually anything public: see this blogpost from Ivan Koshelev function foo () { return { a : 1 , b : 2 , subInstArr : [ { c : 3 , d : 4 , }, ], }; } type InstType = ReturnType < typeof foo > ; type SubInstArr = InstType [ \"subInstArr\" ]; type SubInstType = SubInstArr [ 0 ]; let baz : SubInstType = { c : 5 , d : 6 , // type checks ok! }; //You could just write a one-liner, //But please make sure it is forward-readable //(you can understand it from reading once left-to-right with no jumps) type SubInstType2 = ReturnType < typeof foo > [ \"subInstArr\" ][ 0 ]; let baz2 : SubInstType2 = { c : 5 , d : 6 , // type checks ok! }; TS also ships with a Parameters utility type for extracting the parameters of a function for anything more \"custom\", the infer keyword is the basic building block for this, but takes a bit of getting used to. Look at the source code for the above utility types, and this example to get the idea. Basarat also has a good video on infer .","title":"The Types I need weren't exported!"},{"location":"pages/react/typescript/basic/troubleshooting/types/#the-types-i-need-dont-exist","text":"What's more annoying than modules with unexported types? Modules that are untyped ! Before you proceed - make sure you have checked that types don't exist in DefinitelyTyped or TypeSearch Fret not! There are more than a couple of ways in which you can solve this problem.","title":"The Types I need don't exist!"},{"location":"pages/react/typescript/basic/troubleshooting/types/#slapping-any-on-everything","text":"A lazier way would be to create a new type declaration file, say typedec.d.ts \u2013 if you don't already have one. Ensure that the path to file is resolvable by TypeScript by checking the include array in the tsconfig.json file at the root of your directory. // inside tsconfig.json { // ... \"include\" : [ \"src\" // automatically resolves if the path to declaration is src/typedec.d.ts ] // ... } Within this file, add the declare syntax for your desired module, say my-untyped-module \u2013 to the declaration file: // inside typedec.d.ts declare module \"my-untyped-module\" ; This one-liner alone is enough if you just need it to work without errors. A even hackier, write-once-and-forget way would be to use \"*\" instead which would then apply the Any type for all existing and future untyped modules. This solution works well as a workaround if you have less than a couple untyped modules. Anything more, you now have a ticking type-bomb in your hands. The only way of circumventing this problem would be to define the missing types for those untyped modules as explained in the following sections.","title":"Slapping any on everything"},{"location":"pages/react/typescript/basic/troubleshooting/types/#autogenerate-types","text":"You can use TypeScript with --allowJs and --declaration to see TypeScript's \"best guess\" at the types of the library. If this doesn't work well enough, use dts-gen to use the runtime shape of the object to accurately enumerate all available properties. This tends to be very accurate, BUT the tool does not yet support scraping JSDoc comments to populate additional types. npm install -g dts-gen dts-gen -m <your-module> There are other automated JS to TS conversion tools and migration strategies - see our MIGRATION cheatsheet .","title":"Autogenerate types"},{"location":"pages/react/typescript/basic/troubleshooting/types/#typing-exported-hooks","text":"Typing Hooks is just like typing pure functions. The following steps work under two assumptions: You have already created a type declaration file as stated earlier in the section. You have access to the source code - specifically the code that directly exports the functions you will be using. In most cases, it would be housed in an index.js file. Typically you need a minimum of two type declarations (one for Input Prop and the other for Return Prop ) to define a hook completely. Suppose the hook you wish to type follows the following structure, // ... const useUntypedHook = ( prop ) => { // some processing happens here return { /* ReturnProps */ }; }; export default useUntypedHook ; then, your type declaration should most likely follow the following syntax. declare module 'use-untyped-hook' { export interface InputProps { ... } // type declaration for prop export interface ReturnProps { ... } // type declaration for return props export default function useUntypedHook ( prop : InputProps // ... ) : ReturnProps ; } For instance, the useDarkMode hook exports the functions that follows a similar structure. // inside src/index.js const useDarkMode = ( initialValue = false , // -> input props / config props to be exported { // -> input props / config props to be exported element , classNameDark , classNameLight , onChange , storageKey = \"darkMode\" , storageProvider , global , } = {} ) => { // ... return { // -> return props to be exported value : state , enable : useCallback (() => setState ( true ), [ setState ]), disable : useCallback (() => setState ( false ), [ setState ]), toggle : useCallback (() => setState (( current ) => ! current ), [ setState ]), }; }; export default useDarkMode ; As the comments suggest, exporting these config props and return props following the aforementioned structure will result in the following type export. declare module \"use-dark-mode\" { /** * A config object allowing you to specify certain aspects of `useDarkMode` */ export interface DarkModeConfig { classNameDark? : string ; // A className to set \"dark mode\". Default = \"dark-mode\". classNameLight? : string ; // A className to set \"light mode\". Default = \"light-mode\". element? : HTMLElement ; // The element to apply the className. Default = `document.body` onChange ?: ( val? : boolean ) => void ; // Override the default className handler with a custom callback. storageKey? : string ; // Specify the `localStorage` key. Default = \"darkMode\". Set to `null` to disable persistent storage. storageProvider? : WindowLocalStorage ; // A storage provider. Default = `localStorage`. global? : Window ; // The global object. Default = `window`. } /** * An object returned from a call to `useDarkMode`. */ export interface DarkMode { readonly value : boolean ; enable : () => void ; disable : () => void ; toggle : () => void ; } /** * A custom React Hook to help you implement a \"dark mode\" component for your application. */ export default function useDarkMode ( initialState? : boolean , config? : DarkModeConfig ) : DarkMode ; }","title":"Typing Exported Hooks"},{"location":"pages/react/typescript/basic/troubleshooting/types/#typing-exported-components","text":"In case of typing untyped class components, there's almost no difference in approach except for the fact that after declaring the types, you export the extend the type using class UntypedClassComponent extends React.Component<UntypedClassComponentProps, any> {} where UntypedClassComponentProps holds the type declaration. For instance, sw-yx's Gist on React Router 6 types implemented a similar method for typing the then untyped RR6. declare module \"react-router-dom\" { import * as React from 'react' ; // ... type NavigateProps < T > = { to : string | number , replace? : boolean , state? : T } //... export class Navigate < T = any > extends React . Component < NavigateProps < T >> {} // ... For more information on creating type definitions for class components, you can refer to this post for reference.","title":"Typing Exported Components"},{"location":"pages/react/typescript/basic/troubleshooting/types/#frequent-known-problems-with-typescript","text":"Just a list of stuff that React developers frequently run into, that TS has no solution for. Not necessarily TSX only.","title":"Frequent Known Problems with TypeScript"},{"location":"pages/react/typescript/basic/troubleshooting/types/#typescript-doesnt-narrow-after-an-object-element-null-check","text":"Ref: https://mobile.twitter.com/tannerlinsley/status/1390409931627499523. see also https://github.com/microsoft/TypeScript/issues/9998","title":"TypeScript doesn't narrow after an object element null check"},{"location":"pages/react/typescript/basic/troubleshooting/types/#typescript-doesnt-let-you-restrict-the-type-of-children","text":"Guaranteeing typesafety for this kind of API isn't possible: < Menu > < MenuItem /> { /* ok */ } < MenuLink /> { /* ok */ } < div > { /* error */ } < /Menu> Source: https://twitter.com/ryanflorence/status/1085745787982700544?s=20","title":"TypeScript doesn't let you restrict the type of children"},{"location":"pages/react/typescript/basic/troubleshooting/utilities/","text":"These are all built in, see source in es5.d.ts : ConstructorParameters : a tuple of class constructor's parameter types Exclude : exclude a type from another type Extract : select a subtype that is assignable to another type InstanceType : the instance type you get from a new ing a class constructor NonNullable : exclude null and undefined from a type Parameters : a tuple of a function's parameter types Partial : Make all properties in an object optional Readonly : Make all properties in an object readonly ReadonlyArray : Make an immutable array of the given type Pick : A subtype of an object type with a subset of its keys Record : A map from a key type to a value type Required : Make all properties in an object required ReturnType : A function's return type","title":"Troubleshooting: Utilities"},{"location":"pages/react/typescript/hoc/","text":"This HOC Cheatsheet compiles all available knowledge for writing Higher Order Components with React and TypeScript. We will map closely to the official docs on HOCs initially While hooks exist, many libraries and codebases still have a need to type HOCs. Render props may be considered in future The goal is to write HOCs that offer type safety while not getting in the way. Here is a base HOC example you can copy right away: type PropsAreEqual < P > = ( prevProps : Readonly < P > , nextProps : Readonly < P > ) => boolean ; const withSampleHoC = < P extends {} > ( component : { ( props : P ) : Exclude < React . ReactNode , undefined > ; displayName? : string ; }, propsAreEqual? : PropsAreEqual < P > | false , componentName = component . displayName ?? component . name ) : { ( props : P ) : JSX . Element ; displayName : string ; } => { function WithSampleHoc ( props : P ) { //Do something special to justify the HoC. return component ( props ) as JSX . Element ; } WithSampleHoc . displayName = `withSampleHoC( ${ componentName } )` ; let wrappedComponent = propsAreEqual === false ? WithSampleHoc : React.memo ( WithSampleHoc , propsAreEqual ); //copyStaticProperties(component, wrappedComponent); return wrappedComponent as typeof WithSampleHoc }; This code meets these criteria: Allows a component to return valid elements ( strings | array | boolean | null | number ) and not just JSX.Element | null . Wraps it in a memo unless you opt out. Removes the nested component, so React Dev tools will just show one component. Indicates with displayName in React Dev Tool with an annotation that this is a component wrapped in two HoCs Optional: Copies over static properties that might have been defined on the original component.","title":"HOC Cheatsheet"},{"location":"pages/react/typescript/hoc/excluding-props/","text":"This is covered in passing in Section 1 but we focus on it here as it is such a common issue. HOCs often inject props to premade components. The problem we want to solve is having the HOC-wrapped-component exposing a type that reflects the reduced surface area of props - without manually retyping the HOC every time. This involves some generics, fortunately with some helper utilities. Say we have a component: type DogProps { name : string owner : string } function Dog ({ name , owner } : DogProps ) { return < div > Woof : { name }, Owner : { owner } < /div> } And we have a withOwner HOC that injects the owner : const OwnedDog = withOwner ( \"swyx\" )( Dog ); We want to type withOwner such that it will pass through the types of any component like Dog , into the type of OwnedDog , minus the owner property it injects: typeof OwnedDog ; // we want this to be equal to { name: string } < Dog name = \"fido\" owner = \"swyx\" /> ; // this should be fine < OwnedDog name = \"fido\" owner = \"swyx\" /> ; // this should have a typeError < OwnedDog name = \"fido\" /> ; // this should be fine // and the HOC should be reusable for completely different prop types! type CatProps = { lives : number ; owner : string ; }; function Cat ({ lives , owner } : CatProps ) { return ( < div > { \" \" } Meow : { lives }, Owner : { owner } < /div> ); } const OwnedCat = withOwner ( \"swyx\" )( Cat ); < Cat lives = { 9 } owner = \"swyx\" /> ; // this should be fine < OwnedCat lives = { 9 } owner = \"swyx\" /> ; // this should have a typeError < OwnedCat lives = { 9 } /> ; // this should be fine So how do we type withOwner ? We get the types of the component: keyof T We Exclude the property we want to mask: Exclude<keyof T, 'owner'> , this leaves you with a list of names of properties you want on the wrapped component e.g. name (optional) Use intersection types if you have more to exclude: Exclude<keyof T, 'owner' | 'otherprop' | 'moreprop'> Names of properties aren't quite the same as properties themselves, which also have an associated type. So we use this generated list of names to Pick from the original props: Pick<keyof T, Exclude<keyof T, 'owner'>> , this leaves you with the new, filtered props, e.g. { name: string } (optional) Instead of writing this manually each time, we could use this utility: type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>> Now we write the HOC as a generic function: function withOwner ( owner : string ) { return function < T extends { owner : string } > ( Component : React.ComponentType < T > ) { return function ( props : Omit < T , \"owner\" > ) : JSX . Element { const newProps = { ... props , owner } as T ; return < Component {... newProps } /> ; }; }; } ( Link to TS Playground ) Note that we need to do a type coercion here. This is because TypeScript does not know that merging Omit<T, \"owner\"> and {owner: \"whatever\"} is the same as T . See this GitHub issue for more. Generic solution The above snippet can be modified to create a generic solution to inject any arbitrary props; function withInjectedProps < U extends Record < string , unknown >> ( injectedProps : U ) { return function < T extends U > ( Component : React.ComponentType < T > ) { return function ( props : Omit < T , keyof U > ) : JSX . Element { //A type coercion is neccessary because TypeScript doesn't know that the Omit<T, keyof U> + {...injectedProps} = T const newProps = { ... props , ... injectedProps } as T ; return < Component {... newProps } /> ; }; }; } ( Link to TS Playground ) Without coercion function withOwner ( owner : string ) { return function < T extends { owner : string } > ( Component : React.ComponentType < T > ) : React . ComponentType < Omit < T , \"owner\" > & { owner? : never } > { return function ( props ) { const newProps = { ... props , owner }; return < Component {... newProps } /> ; }; }; } ( Link to TS Playground ) Learn More We will need to extract lessons from here in future but here they are: https://medium.com/@xfor/typescript-react-hocs-context-api-cb46da611f12 https://medium.com/@jrwebdev/react-higher-order-component-patterns-in-typescript-42278f7590fb https://www.matthewgerstman.com/tech/ts-tricks-higher-order-components/","title":"Section 2: Excluding Props"},{"location":"pages/react/typescript/hoc/excluding-props/#generic-solution","text":"The above snippet can be modified to create a generic solution to inject any arbitrary props; function withInjectedProps < U extends Record < string , unknown >> ( injectedProps : U ) { return function < T extends U > ( Component : React.ComponentType < T > ) { return function ( props : Omit < T , keyof U > ) : JSX . Element { //A type coercion is neccessary because TypeScript doesn't know that the Omit<T, keyof U> + {...injectedProps} = T const newProps = { ... props , ... injectedProps } as T ; return < Component {... newProps } /> ; }; }; } ( Link to TS Playground )","title":"Generic solution"},{"location":"pages/react/typescript/hoc/excluding-props/#without-coercion","text":"function withOwner ( owner : string ) { return function < T extends { owner : string } > ( Component : React.ComponentType < T > ) : React . ComponentType < Omit < T , \"owner\" > & { owner? : never } > { return function ( props ) { const newProps = { ... props , owner }; return < Component {... newProps } /> ; }; }; } ( Link to TS Playground )","title":"Without coercion"},{"location":"pages/react/typescript/hoc/excluding-props/#learn-more","text":"We will need to extract lessons from here in future but here they are: https://medium.com/@xfor/typescript-react-hocs-context-api-cb46da611f12 https://medium.com/@jrwebdev/react-higher-order-component-patterns-in-typescript-42278f7590fb https://www.matthewgerstman.com/tech/ts-tricks-higher-order-components/","title":"Learn More"},{"location":"pages/react/typescript/hoc/full-example/","text":"This is an HOC example for you to copy and paste. If certain pieces don't make sense for you, head to the React HOC Docs intro to get a detailed walkthrough via a complete translation of the React docs in TypeScript. Sometimes you want a simple way to inject props from somewhere else (either a global store or a provider) and don't want to continually pass down the props for it. Context is great for it, but then the values from the context can only be used in your render function. A HoC will provide these values as props. The injected props interface WithThemeProps { primaryColor : string ; } Usage in the component The goal is to have the props available on the interface for the component, but subtracted out for the consumers of the component when wrapped in the HoC. interface Props extends WithThemeProps { children? : React.ReactNode ; } class MyButton extends React . Component < Props > { public render () { // Render an the element using the theme and other props. } private someInternalMethod () { // The theme values are also available as props here. } } export default withTheme ( MyButton ); Consuming the Component Now when consuming the component you can omit the primaryColor prop or override the one provided through context. < MyButton > Hello button < /MyButton> / / Valid < MyButton primaryColor = \"#333\" > Hello Button < /MyButton> / / Also valid Declaring the HoC The actual HoC. export function withTheme < T extends WithThemeProps = WithThemeProps > ( WrappedComponent : React.ComponentType < T > ) { // Try to create a nice displayName for React Dev Tools. const displayName = WrappedComponent . displayName || WrappedComponent . name || \"Component\" ; // Creating the inner component. The calculated Props type here is the where the magic happens. const ComponentWithTheme = ( props : Omit < T , keyof WithThemeProps > ) => { // Fetch the props you want to inject. This could be done with context instead. const themeProps = useTheme (); // props comes afterwards so the can override the default ones. return < WrappedComponent {... themeProps } {...( props as T )} /> ; }; ComponentWithTheme . displayName = `withTheme( ${ displayName } )` ; return ComponentWithTheme ; } Note that the {...(props as T)} assertion is needed because of a current bug in TS 3.2 https://github.com/Microsoft/TypeScript/issues/28938#issuecomment-450636046 Here is a more advanced example of a dynamic higher order component that bases some of its parameters on the props of the component being passed in: // inject static values to a component so that they're always provided export function inject < TProps , TInjectedKeys extends keyof TProps > ( Component : React.JSXElementConstructor < TProps > , injector : Pick < TProps , TInjectedKeys > ) { return function Injected ( props : Omit < TProps , TInjectedKeys > ) { return < Component {...( props as TProps )} {... injector } /> ; }; } Using forwardRef For \"true\" reusability you should also consider exposing a ref for your HOC. You can use React.forwardRef<Ref, Props> as documented in the basic cheatsheet , but we are interested in more real world examples. Here is a nice example in practice from @OliverJAsh (note - it still has some rough edges, we need help to test this out/document this). Supporting defaultProps of Wrapped Component If this is something you need, please see the stale discussion we had and comment with your requirements. We will pick this up again if needed.","title":"Full HOC Example"},{"location":"pages/react/typescript/hoc/full-example/#using-forwardref","text":"For \"true\" reusability you should also consider exposing a ref for your HOC. You can use React.forwardRef<Ref, Props> as documented in the basic cheatsheet , but we are interested in more real world examples. Here is a nice example in practice from @OliverJAsh (note - it still has some rough edges, we need help to test this out/document this).","title":"Using forwardRef"},{"location":"pages/react/typescript/hoc/full-example/#supporting-defaultprops-of-wrapped-component","text":"If this is something you need, please see the stale discussion we had and comment with your requirements. We will pick this up again if needed.","title":"Supporting defaultProps of Wrapped Component"},{"location":"pages/react/typescript/hoc/react-hoc-docs/","text":"In this first section we refer closely to the React docs on HOCs and offer direct TypeScript parallels. Docs Example: Use HOCs For Cross-Cutting Concerns Misc variables referenced in the example below /** dummy child components that take anything */ const Comment = ( _ : any ) => null ; const TextBlock = Comment ; /** dummy Data */ type CommentType = { text : string ; id : number }; const comments : CommentType [] = [ { text : \"comment1\" , id : 1 , }, { text : \"comment2\" , id : 2 , }, ]; const blog = \"blogpost\" ; /** mock data source */ const DataSource = { addChangeListener ( e : Function ) { // do something }, removeChangeListener ( e : Function ) { // do something }, getComments () { return comments ; }, getBlogPost ( id : number ) { return blog ; }, }; /** type aliases just to deduplicate */ type DataType = typeof DataSource ; // type TODO_ANY = any; /** utility types we use */ type Omit < T , K extends keyof T > = Pick < T , Exclude < keyof T , K >> ; // type Optionalize<T extends K, K> = Omit<T, keyof K>; /** Rewritten Components from the React docs that just uses injected data prop */ function CommentList ({ data } : WithDataProps < typeof comments > ) { return ( < div > { data . map (( comment : CommentType ) => ( < Comment comment = { comment } key = { comment . id } /> ))} < /div> ); } interface BlogPostProps extends WithDataProps < string > { id : number ; } function BlogPost ({ data , id } : BlogPostProps ) { return ( < div key = { id } > < TextBlock text = { data } /> ; < /div> ); } [View in TypeScript Playground](https://www.typescriptlang.org/play/?jsx=2#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wFgAoCgeirhgAskBnJOFIuxuMHMJuiHABGrYADsAVkgxIAJsICenVgAkA8gGEK4mEiiZ0rAOrAGAERQwUABV5MAPABUAfHADeFOHFmWUALjhHAG44Gm9fOGB+AHMkMT1gNAoAX2paR0j+BlYYBTBWCExwqzS4a0zlbjs4QsqAdygUMHz5NFxIeLF4BksK8Uw9IllSjQrstgwAVxQAG0iuvQM0AqLxhqaWuDbwCE74AApJlnkYQWjGoW8kA0mZmFsIPjhsXEiYAEoKJAAPSFhnyZiDDAXZwOqmegAZUmQiYaCgwDAMBBYicABoynAfroxLJ+CZzL4HnwnM4MRpnPtPKFaAwonQ8qxZjMIHV+EcBPMBlAyhihJN4OcUJdxrl8jUikZGs05Bp2rs4vAWGB2JYkDMlOCGBABW95rp9AkxNEwRDKv09HFlhKytSpRtZfK9gFkOgYAA6ABSkIAGgBRGZIECKuViJgwKCTDDQezWVwAMjgGjR1LCLEDGAsVgqKABQNOPMw0ECqdoPEe-Hprtkuw1wmkKCOohg+H4RBQNbEdfETGAshWlTQMxQTCY1PT0hgWf8cCp5C8Xh8VkhOqgywCYqQtWnK8ma6QKfnC-LfBdqE7Gvs3p97oAMsAhI0oAoALIoMQoWKyACCMAjD4FZh7GTOA1BAUxYwxAAiJcUCg5wEOpd44AAXlcRwKGQjwjzCcYQE-RIKkYIgAmvO8HyfV930-ORf3-fldH4cEZjmKwAGsci4TcbXtFo5R2PY2FxOAiCYCAZgAN2bfh+xuO4qgrUs2GiFAe26LgT34WoCXoacMTqehEnoCoJCOdSCgRaJxFmTFuK1Yz8Fg-ARKDCApPkF48FMNskAAR0mYAiGDLoxyPbjiX4FC4DI+9H3YKiPy-OiEQYoCQLAiDrGg2D4OcIJqW4yErF0VD3GpRdfACYJqWSfKjyIGA9zELZh1HOAdOnLFvhxPFEGID1+I6RVYzsDEirVVxsIXLZdnDSNoygfZNICCKsPKhcmEmfJFs0946umrw6SYd16HfWRAw0U7jVYKKjpOs6Lqu2J3SEcRZH2I69vWw7DOO8M1VKqaDoqqwAgnTNfH2HdV2WDFdu+uBavW1JKCPLxtiGrozD7F8dS6Ur9mQtC4GhvdlndDtZEu99YnvcM4j0D7fvu3FHpppAvtR6aMYVLoTBYgBVMQQDx+AosJ1DnAR0n93dIK3KQanrrpnFGbuq7zsVp6Obq9aNbZ66CaJqW0YXO6WBgcbdH2IHgdgsH1Unacod8Xd9wxO74dNrxkk59aiFxRm1u9mlKjFcQTSLHkmB4c8I84KJ3U0zJ3VTuApOfGbwEDb53XrcMwRQJRLPoeAxFZMZBFMgvuNMNh+HfBQEbCWDTRYuBw2AduRAZfI0EYNAOOGEOGqa2cEa8exeL4p1FWKFAULcc3iqQd1YOSdxU-dJnE+TkchIUd4N6oE3gc56aUZ9-bQ9HqBmo63w6pR6gACoX7gdRRiOGjTQYJNZ5CnAF+VAvi-GgPANoYZ4D8WCjAFWOloSwnhIiZEoIor2UQXCBESIURzi8DAxUKtDxeBdsuGGSAAjTkcIyY2JNXbkPdLEGABCQqE0wrrcgPw-gQNmvAAAQiyaI1gIDhgQTCLBKCUSlQweI5BODdh4LgAIiAQiREwGIbOGW646FWGofkOGdgAgZRgPYZRqjwwRWyr4eCxt1paNXkwsxwjwxLTsO6PsnxyB7SAA) Example HOC from React Docs translated to TypeScript // these are the props to be injected by the HOC interface WithDataProps < T > { data : T ; // data is generic } // T is the type of data // P is the props of the wrapped component that is inferred // C is the actual interface of the wrapped component (used to grab defaultProps from it) export function withSubscription < T , P extends WithDataProps < T > , C > ( // this type allows us to infer P, but grab the type of WrappedComponent separately without it interfering with the inference of P WrappedComponent : React.JSXElementConstructor < P > & C , // selectData is a functor for T // props is Readonly because it's readonly inside of the class selectData : ( dataSource : typeof DataSource , props : Readonly < JSX . LibraryManagedAttributes < C , Omit < P , \"data\" >>> ) => T ) { // the magic is here: JSX.LibraryManagedAttributes will take the type of WrapedComponent and resolve its default props // against the props of WithData, which is just the original P type with 'data' removed from its requirements type Props = JSX . LibraryManagedAttributes < C , Omit < P , \"data\" >> ; type State = { data : T ; }; return class WithData extends React . Component < Props , State > { constructor ( props : Props ) { super ( props ); this . handleChange = this . handleChange . bind ( this ); this . state = { data : selectData ( DataSource , props ), }; } componentDidMount = () => DataSource . addChangeListener ( this . handleChange ); componentWillUnmount = () => DataSource . removeChangeListener ( this . handleChange ); handleChange = () => this . setState ({ data : selectData ( DataSource , this . props ), }); render () { // the typing for spreading this.props is... very complex. best way right now is to just type it as any // data will still be typechecked return ( < WrappedComponent data = { this . state . data } {...( this . props as any )} /> ); } }; // return WithData; } /** HOC usage with Components */ export const CommentListWithSubscription = withSubscription ( CommentList , ( DataSource : DataType ) => DataSource . getComments () ); export const BlogPostWithSubscription = withSubscription ( BlogPost , ( DataSource : DataType , props : Omit < BlogPostProps , \"data\" > ) => DataSource . getBlogPost ( props . id ) ); Docs Example: Don\u2019t Mutate the Original Component. Use Composition. This is pretty straightforward - make sure to assert the passed props as T due to the TS 3.2 bug . function logProps < T > ( WrappedComponent : React.ComponentType < T > ) { return class extends React . Component { componentWillReceiveProps ( nextProps : React.ComponentProps < typeof WrappedComponent > ) { console . log ( \"Current props: \" , this . props ); console . log ( \"Next props: \" , nextProps ); } render () { // Wraps the input component in a container, without mutating it. Good! return < WrappedComponent {...( this . props as T )} /> ; } }; } Docs Example: Pass Unrelated Props Through to the Wrapped Component No TypeScript specific advice needed here. Docs Example: Maximizing Composability HOCs can take the form of Functions that return Higher Order Components that return Components. connect from react-redux has a number of overloads you can take inspiration from in the source . Here we build our own mini connect to understand HOCs: Misc variables referenced in the example below /** utility types we use */ type Omit < T , K extends keyof T > = Pick < T , Exclude < keyof T , K >> ; /** dummy Data */ type CommentType = { text : string ; id : number }; const comments : CommentType [] = [ { text : \"comment1\" , id : 1 , }, { text : \"comment2\" , id : 2 , }, ]; /** dummy child components that take anything */ const Comment = ( _ : any ) => null ; /** Rewritten Components from the React docs that just uses injected data prop */ function CommentList ({ data } : WithSubscriptionProps < typeof comments > ) { return ( < div > { data . map (( comment : CommentType ) => ( < Comment comment = { comment } key = { comment . id } /> ))} < /div> ); } const commentSelector = ( _ : any , ownProps : any ) => ({ id : ownProps.id , }); const commentActions = () => ({ addComment : ( str : string ) => comments . push ({ text : str , id : comments.length }), }); const ConnectedComment = connect ( commentSelector , commentActions )( CommentList ); // these are the props to be injected by the HOC interface WithSubscriptionProps < T > { data : T ; } function connect ( mapStateToProps : Function , mapDispatchToProps : Function ) { return function < T , P extends WithSubscriptionProps < T > , C > ( WrappedComponent : React.ComponentType < T > ) { type Props = JSX . LibraryManagedAttributes < C , Omit < P , \"data\" >> ; // Creating the inner component. The calculated Props type here is the where the magic happens. return class ComponentWithTheme extends React . Component < Props > { public render () { // Fetch the props you want inject. This could be done with context instead. const mappedStateProps = mapStateToProps ( this . state , this . props ); const mappedDispatchProps = mapDispatchToProps ( this . state , this . props ); // this.props comes afterwards so the can override the default ones. return ( < WrappedComponent {... this . props } {... mappedStateProps } {... mappedDispatchProps } /> ); } }; }; } View in TypeScript Playground Docs Example: Wrap the Display Name for Easy Debugging This is pretty straightforward as well. interface WithSubscriptionProps { data : any ; } function withSubscription < T extends WithSubscriptionProps = WithSubscriptionProps > ( WrappedComponent : React.ComponentType < T > ) { class WithSubscription extends React . Component { /* ... */ public static displayName = `WithSubscription( ${ getDisplayName ( WrappedComponent ) } )` ; } return WithSubscription ; } function getDisplayName < T > ( WrappedComponent : React.ComponentType < T > ) { return WrappedComponent . displayName || WrappedComponent . name || \"Component\" ; } Unwritten: Caveats section Don\u2019t Use HOCs Inside the render Method Static Methods Must Be Copied Over Refs Aren\u2019t Passed Through","title":"React HOC docs"},{"location":"pages/react/typescript/hoc/react-hoc-docs/#docs-example-use-hocs-for-cross-cutting-concerns","text":"Misc variables referenced in the example below /** dummy child components that take anything */ const Comment = ( _ : any ) => null ; const TextBlock = Comment ; /** dummy Data */ type CommentType = { text : string ; id : number }; const comments : CommentType [] = [ { text : \"comment1\" , id : 1 , }, { text : \"comment2\" , id : 2 , }, ]; const blog = \"blogpost\" ; /** mock data source */ const DataSource = { addChangeListener ( e : Function ) { // do something }, removeChangeListener ( e : Function ) { // do something }, getComments () { return comments ; }, getBlogPost ( id : number ) { return blog ; }, }; /** type aliases just to deduplicate */ type DataType = typeof DataSource ; // type TODO_ANY = any; /** utility types we use */ type Omit < T , K extends keyof T > = Pick < T , Exclude < keyof T , K >> ; // type Optionalize<T extends K, K> = Omit<T, keyof K>; /** Rewritten Components from the React docs that just uses injected data prop */ function CommentList ({ data } : WithDataProps < typeof comments > ) { return ( < div > { data . map (( comment : CommentType ) => ( < Comment comment = { comment } key = { comment . id } /> ))} < /div> ); } interface BlogPostProps extends WithDataProps < string > { id : number ; } function BlogPost ({ data , id } : BlogPostProps ) { return ( < div key = { id } > < TextBlock text = { data } /> ; < /div> ); } [View in TypeScript Playground](https://www.typescriptlang.org/play/?jsx=2#code/JYWwDg9gTgLgBAJQKYEMDG8BmUIjgcilQ3wFgAoCgeirhgAskBnJOFIuxuMHMJuiHABGrYADsAVkgxIAJsICenVgAkA8gGEK4mEiiZ0rAOrAGAERQwUABV5MAPABUAfHADeFOHFmWUALjhHAG44Gm9fOGB+AHMkMT1gNAoAX2paR0j+BlYYBTBWCExwqzS4a0zlbjs4QsqAdygUMHz5NFxIeLF4BksK8Uw9IllSjQrstgwAVxQAG0iuvQM0AqLxhqaWuDbwCE74AApJlnkYQWjGoW8kA0mZmFsIPjhsXEiYAEoKJAAPSFhnyZiDDAXZwOqmegAZUmQiYaCgwDAMBBYicABoynAfroxLJ+CZzL4HnwnM4MRpnPtPKFaAwonQ8qxZjMIHV+EcBPMBlAyhihJN4OcUJdxrl8jUikZGs05Bp2rs4vAWGB2JYkDMlOCGBABW95rp9AkxNEwRDKv09HFlhKytSpRtZfK9gFkOgYAA6ABSkIAGgBRGZIECKuViJgwKCTDDQezWVwAMjgGjR1LCLEDGAsVgqKABQNOPMw0ECqdoPEe-Hprtkuw1wmkKCOohg+H4RBQNbEdfETGAshWlTQMxQTCY1PT0hgWf8cCp5C8Xh8VkhOqgywCYqQtWnK8ma6QKfnC-LfBdqE7Gvs3p97oAMsAhI0oAoALIoMQoWKyACCMAjD4FZh7GTOA1BAUxYwxAAiJcUCg5wEOpd44AAXlcRwKGQjwjzCcYQE-RIKkYIgAmvO8HyfV930-ORf3-fldH4cEZjmKwAGsci4TcbXtFo5R2PY2FxOAiCYCAZgAN2bfh+xuO4qgrUs2GiFAe26LgT34WoCXoacMTqehEnoCoJCOdSCgRaJxFmTFuK1Yz8Fg-ARKDCApPkF48FMNskAAR0mYAiGDLoxyPbjiX4FC4DI+9H3YKiPy-OiEQYoCQLAiDrGg2D4OcIJqW4yErF0VD3GpRdfACYJqWSfKjyIGA9zELZh1HOAdOnLFvhxPFEGID1+I6RVYzsDEirVVxsIXLZdnDSNoygfZNICCKsPKhcmEmfJFs0946umrw6SYd16HfWRAw0U7jVYKKjpOs6Lqu2J3SEcRZH2I69vWw7DOO8M1VKqaDoqqwAgnTNfH2HdV2WDFdu+uBavW1JKCPLxtiGrozD7F8dS6Ur9mQtC4GhvdlndDtZEu99YnvcM4j0D7fvu3FHpppAvtR6aMYVLoTBYgBVMQQDx+AosJ1DnAR0n93dIK3KQanrrpnFGbuq7zsVp6Obq9aNbZ66CaJqW0YXO6WBgcbdH2IHgdgsH1Unacod8Xd9wxO74dNrxkk59aiFxRm1u9mlKjFcQTSLHkmB4c8I84KJ3U0zJ3VTuApOfGbwEDb53XrcMwRQJRLPoeAxFZMZBFMgvuNMNh+HfBQEbCWDTRYuBw2AduRAZfI0EYNAOOGEOGqa2cEa8exeL4p1FWKFAULcc3iqQd1YOSdxU-dJnE+TkchIUd4N6oE3gc56aUZ9-bQ9HqBmo63w6pR6gACoX7gdRRiOGjTQYJNZ5CnAF+VAvi-GgPANoYZ4D8WCjAFWOloSwnhIiZEoIor2UQXCBESIURzi8DAxUKtDxeBdsuGGSAAjTkcIyY2JNXbkPdLEGABCQqE0wrrcgPw-gQNmvAAAQiyaI1gIDhgQTCLBKCUSlQweI5BODdh4LgAIiAQiREwGIbOGW646FWGofkOGdgAgZRgPYZRqjwwRWyr4eCxt1paNXkwsxwjwxLTsO6PsnxyB7SAA) Example HOC from React Docs translated to TypeScript // these are the props to be injected by the HOC interface WithDataProps < T > { data : T ; // data is generic } // T is the type of data // P is the props of the wrapped component that is inferred // C is the actual interface of the wrapped component (used to grab defaultProps from it) export function withSubscription < T , P extends WithDataProps < T > , C > ( // this type allows us to infer P, but grab the type of WrappedComponent separately without it interfering with the inference of P WrappedComponent : React.JSXElementConstructor < P > & C , // selectData is a functor for T // props is Readonly because it's readonly inside of the class selectData : ( dataSource : typeof DataSource , props : Readonly < JSX . LibraryManagedAttributes < C , Omit < P , \"data\" >>> ) => T ) { // the magic is here: JSX.LibraryManagedAttributes will take the type of WrapedComponent and resolve its default props // against the props of WithData, which is just the original P type with 'data' removed from its requirements type Props = JSX . LibraryManagedAttributes < C , Omit < P , \"data\" >> ; type State = { data : T ; }; return class WithData extends React . Component < Props , State > { constructor ( props : Props ) { super ( props ); this . handleChange = this . handleChange . bind ( this ); this . state = { data : selectData ( DataSource , props ), }; } componentDidMount = () => DataSource . addChangeListener ( this . handleChange ); componentWillUnmount = () => DataSource . removeChangeListener ( this . handleChange ); handleChange = () => this . setState ({ data : selectData ( DataSource , this . props ), }); render () { // the typing for spreading this.props is... very complex. best way right now is to just type it as any // data will still be typechecked return ( < WrappedComponent data = { this . state . data } {...( this . props as any )} /> ); } }; // return WithData; } /** HOC usage with Components */ export const CommentListWithSubscription = withSubscription ( CommentList , ( DataSource : DataType ) => DataSource . getComments () ); export const BlogPostWithSubscription = withSubscription ( BlogPost , ( DataSource : DataType , props : Omit < BlogPostProps , \"data\" > ) => DataSource . getBlogPost ( props . id ) );","title":"Docs Example: Use HOCs For Cross-Cutting Concerns"},{"location":"pages/react/typescript/hoc/react-hoc-docs/#docs-example-dont-mutate-the-original-component-use-composition","text":"This is pretty straightforward - make sure to assert the passed props as T due to the TS 3.2 bug . function logProps < T > ( WrappedComponent : React.ComponentType < T > ) { return class extends React . Component { componentWillReceiveProps ( nextProps : React.ComponentProps < typeof WrappedComponent > ) { console . log ( \"Current props: \" , this . props ); console . log ( \"Next props: \" , nextProps ); } render () { // Wraps the input component in a container, without mutating it. Good! return < WrappedComponent {...( this . props as T )} /> ; } }; }","title":"Docs Example: Don\u2019t Mutate the Original Component. Use Composition."},{"location":"pages/react/typescript/hoc/react-hoc-docs/#docs-example-pass-unrelated-props-through-to-the-wrapped-component","text":"No TypeScript specific advice needed here.","title":"Docs Example: Pass Unrelated Props Through to the Wrapped Component"},{"location":"pages/react/typescript/hoc/react-hoc-docs/#docs-example-maximizing-composability","text":"HOCs can take the form of Functions that return Higher Order Components that return Components. connect from react-redux has a number of overloads you can take inspiration from in the source . Here we build our own mini connect to understand HOCs: Misc variables referenced in the example below /** utility types we use */ type Omit < T , K extends keyof T > = Pick < T , Exclude < keyof T , K >> ; /** dummy Data */ type CommentType = { text : string ; id : number }; const comments : CommentType [] = [ { text : \"comment1\" , id : 1 , }, { text : \"comment2\" , id : 2 , }, ]; /** dummy child components that take anything */ const Comment = ( _ : any ) => null ; /** Rewritten Components from the React docs that just uses injected data prop */ function CommentList ({ data } : WithSubscriptionProps < typeof comments > ) { return ( < div > { data . map (( comment : CommentType ) => ( < Comment comment = { comment } key = { comment . id } /> ))} < /div> ); } const commentSelector = ( _ : any , ownProps : any ) => ({ id : ownProps.id , }); const commentActions = () => ({ addComment : ( str : string ) => comments . push ({ text : str , id : comments.length }), }); const ConnectedComment = connect ( commentSelector , commentActions )( CommentList ); // these are the props to be injected by the HOC interface WithSubscriptionProps < T > { data : T ; } function connect ( mapStateToProps : Function , mapDispatchToProps : Function ) { return function < T , P extends WithSubscriptionProps < T > , C > ( WrappedComponent : React.ComponentType < T > ) { type Props = JSX . LibraryManagedAttributes < C , Omit < P , \"data\" >> ; // Creating the inner component. The calculated Props type here is the where the magic happens. return class ComponentWithTheme extends React . Component < Props > { public render () { // Fetch the props you want inject. This could be done with context instead. const mappedStateProps = mapStateToProps ( this . state , this . props ); const mappedDispatchProps = mapDispatchToProps ( this . state , this . props ); // this.props comes afterwards so the can override the default ones. return ( < WrappedComponent {... this . props } {... mappedStateProps } {... mappedDispatchProps } /> ); } }; }; } View in TypeScript Playground","title":"Docs Example: Maximizing Composability"},{"location":"pages/react/typescript/hoc/react-hoc-docs/#docs-example-wrap-the-display-name-for-easy-debugging","text":"This is pretty straightforward as well. interface WithSubscriptionProps { data : any ; } function withSubscription < T extends WithSubscriptionProps = WithSubscriptionProps > ( WrappedComponent : React.ComponentType < T > ) { class WithSubscription extends React . Component { /* ... */ public static displayName = `WithSubscription( ${ getDisplayName ( WrappedComponent ) } )` ; } return WithSubscription ; } function getDisplayName < T > ( WrappedComponent : React.ComponentType < T > ) { return WrappedComponent . displayName || WrappedComponent . name || \"Component\" ; }","title":"Docs Example: Wrap the Display Name for Easy Debugging"},{"location":"pages/react/typescript/hoc/react-hoc-docs/#unwritten-caveats-section","text":"Don\u2019t Use HOCs Inside the render Method Static Methods Must Be Copied Over Refs Aren\u2019t Passed Through","title":"Unwritten: Caveats section"},{"location":"pages/tips/css-reset/","text":"HTML CSS Reset *, * :: before , * :: after { margin : 0 ; padding : 0 ; box-sizing : inherit ; } html { box-sizing : border-box ; font-size : 62.5 % } body { font-family : \u2018 Lato \u2019 ; color : #ddd ; } . container { }","title":"Css reset"},{"location":"pages/tips/css/shruti-balasa/css-animation-line-hover/","text":"CSS line animation on hover See this text underline animation? Looks really nice right? Let\u2019s go straight into understanding how to create it step-by-step. Text underline animation on hover The Markup HTML The CSS There are two ways to achieve the animation Using **::after** pseudo-element In this method we can create a pseudo-element, position it below the link using position: absolute , give it a 2px height and animate the width from 0 to 100%. Something like this: Method 1: Using pseudo element And it works! Here\u2019s the working demo . The only problem with this method is that, if the link text flows into next line, the underline appears only on the first line! Remove display:inline-block on the a element in the above demo and try it out for yourself. So if you need the animation to work on a multi-line text, follow the next method. Using **background** property In this method, we use an underline background image and position it at the bottom of the link. We set the size to 0 width initially and set it to 100% on hover, For the background image, we don\u2019t need an actual image. We can use linear gradient along with other properties like this. Background values to create an underline As you can see, we have used the background-image property to set the color of the underline. The background-size property is needed to specify that the image (underline) occupies 100% width and 2px height. The background-position property is used to specify the position and the last line makes the background image not repeat. If you use the above CSS, you\u2019ll get an underline right away. But we need an underline only on hover. So, let\u2019s change the second line above to: Initial background-size is 0 And on hover, we change the background-size to 100% 2px . Also, add some transition. This will be the full CSS: Full CSS for underline animation Unlike the previous method, this underline flows into multiple lines. See it for yourself in the working demo . Bonus If you want the underline to animate from center instead of left to right, change the background-position value to center bottom. On hover, the line appears from left to right. On leaving the mouse, if you want it to exit to the right like the below demo: Starts from left and leaves to right You need to change the background-position to following: Change in background-position values If you found the background properties and their values confusing, I encourage you to visit the MDN docs for background-image , background-position and background-size . That\u2019s a wrap! Hope you learnt something new this week. Reply to this email and let me know if you are particularly interested in learning a trick you\u2019ve seen somewhere.","title":"CSS line animation on hover"},{"location":"pages/tips/css/shruti-balasa/css-animation-line-hover/#css-line-animation-on-hover","text":"See this text underline animation? Looks really nice right? Let\u2019s go straight into understanding how to create it step-by-step. Text underline animation on hover The Markup HTML The CSS There are two ways to achieve the animation Using **::after** pseudo-element In this method we can create a pseudo-element, position it below the link using position: absolute , give it a 2px height and animate the width from 0 to 100%. Something like this: Method 1: Using pseudo element And it works! Here\u2019s the working demo . The only problem with this method is that, if the link text flows into next line, the underline appears only on the first line! Remove display:inline-block on the a element in the above demo and try it out for yourself. So if you need the animation to work on a multi-line text, follow the next method. Using **background** property In this method, we use an underline background image and position it at the bottom of the link. We set the size to 0 width initially and set it to 100% on hover, For the background image, we don\u2019t need an actual image. We can use linear gradient along with other properties like this. Background values to create an underline As you can see, we have used the background-image property to set the color of the underline. The background-size property is needed to specify that the image (underline) occupies 100% width and 2px height. The background-position property is used to specify the position and the last line makes the background image not repeat. If you use the above CSS, you\u2019ll get an underline right away. But we need an underline only on hover. So, let\u2019s change the second line above to: Initial background-size is 0 And on hover, we change the background-size to 100% 2px . Also, add some transition. This will be the full CSS: Full CSS for underline animation Unlike the previous method, this underline flows into multiple lines. See it for yourself in the working demo . Bonus If you want the underline to animate from center instead of left to right, change the background-position value to center bottom. On hover, the line appears from left to right. On leaving the mouse, if you want it to exit to the right like the below demo: Starts from left and leaves to right You need to change the background-position to following: Change in background-position values If you found the background properties and their values confusing, I encourage you to visit the MDN docs for background-image , background-position and background-size . That\u2019s a wrap! Hope you learnt something new this week. Reply to this email and let me know if you are particularly interested in learning a trick you\u2019ve seen somewhere.","title":"CSS line animation on hover"},{"location":"pages/tips/css/shruti-balasa/display-contents-in-CSS-rule/","text":"Display contents in CSS rule Hey! Welcome to the second issue of this newsletter. Let\u2019s create a responsive blog post display layout using the lesser known CSS rule display: contents . Responsive Blog Post Display using Grid and display:contents Consider this blog post display section. On a wider screen, we want the image to be on the right separated from the text. While on a mobile screen, we want the image to appear in between our heading and the paragraph. Desktop and mobile layouts This layout could easily be a hero section of your website too. There are multiple ways to approach this, based on the HTML markup. Likely, your markup looks something like this: HTML With this markup, the desktop layout is straight forward. You can use flexbox like this: Desktop layout with flexbox But for smaller screens, how do you get that image in between heading and paragraph? Introducting **display: contents** CSS rule When you set use display: contents on an element, that element\u2019s children become direct children of the element\u2019s parent. It\u2019s like, that element disappears from the Markup. So, in our case, for mobile layout, if we use display: contents on our .text element, it gets ignored: display: contents makes the element get ignored And now it\u2019s equivalent to the below markup, for styling: Now we can use flexbox for the .container with flex-direction as column and then use order property to get the image element in between heading and para! \ud83e\ude84 Here\u2019s the simplified CSS snippet: Simplified CSS snippet You can see the full working demo on Codepen Responsive blog post display Image appears in different places on mobile and in desktop layouts codepen.io","title":"Display contents in CSS rule"},{"location":"pages/tips/css/shruti-balasa/display-contents-in-CSS-rule/#display-contents-in-css-rule","text":"Hey! Welcome to the second issue of this newsletter. Let\u2019s create a responsive blog post display layout using the lesser known CSS rule display: contents . Responsive Blog Post Display using Grid and display:contents Consider this blog post display section. On a wider screen, we want the image to be on the right separated from the text. While on a mobile screen, we want the image to appear in between our heading and the paragraph. Desktop and mobile layouts This layout could easily be a hero section of your website too. There are multiple ways to approach this, based on the HTML markup. Likely, your markup looks something like this: HTML With this markup, the desktop layout is straight forward. You can use flexbox like this: Desktop layout with flexbox But for smaller screens, how do you get that image in between heading and paragraph? Introducting **display: contents** CSS rule When you set use display: contents on an element, that element\u2019s children become direct children of the element\u2019s parent. It\u2019s like, that element disappears from the Markup. So, in our case, for mobile layout, if we use display: contents on our .text element, it gets ignored: display: contents makes the element get ignored And now it\u2019s equivalent to the below markup, for styling: Now we can use flexbox for the .container with flex-direction as column and then use order property to get the image element in between heading and para! \ud83e\ude84 Here\u2019s the simplified CSS snippet: Simplified CSS snippet You can see the full working demo on Codepen Responsive blog post display Image appears in different places on mobile and in desktop layouts codepen.io","title":"Display contents in CSS rule"},{"location":"pages/tools/","tags":["web","basis"],"text":"","title":"Tools"},{"location":"pages/tools/git/","text":"Git Master commands Github base List the actual Config setup from current directory $ git config -l Setup the Global Config # Exemple $ git config --global user.name electroheadfx $ git config --global user.email \"laurent@efxdesign.fr\" Setup the local Config (per project) # Exemple $ git config user.name efx $ git config user.email \"laurent@electroheadfx.fr\" Setup for mac lf/cr git config --global core.autocrlf input Setup for windows lf/cr git config --global core.autocrlf true Setup for rebase git config --global credential.helper store git config --global pull.rebase true git config --global merge.ff true Create a git project # Create a folder $ mkdir folder && cd folder # init git (when the project is new) $ git init # Add origin url from remote $ git remote add origin https://github.com/electroheadfx/test.git # Now you can push the code after you will add file then commit $ git push -u origin master Add file and commit # add folder, files $ git add [ folders ] [ file1 ] [ file2 ] # or add all from current directory $ git add . # commit the added file with a message $ git commit -m \u201dmsg\u201d # Push on server to origin from master $ git push -u origin master Git status and log # Commit status $ git status # See all the commits done $ git log # See all the i commits $ git log -n i # See All the diff before git add $ git diff Revert a file to last comit git checkout file Git Branches # cr\u00e9\u00e9 une branche au repo $ git branch myfeature # see all branchs list $ git branch # switch to myfeature branch $ git checkout myfeature # see the diff between 2 branch $ git diff master...myfeature # Create master branch $ git branch master # merge branch my feature on master $ git merge myfeature # delete myfeature branch $ git branch -d myfeature Get a GIT repository # Create a test folder with the repo $ git clone https://github.com/electroheadfx/test.git Delete/add a folder and commit # Remove a folder $ git rm -rf <folder> # Remove files $ git rm file1 file2 # Commit with a message $ git commit -m \u201cmsg\u201c # Push the commit on server to master like origin, after just do git push $ git push -u origin master # Add a folder or file $ git add <folder> file1 file2 # commit again $ git commit -m \u201cmsg\u201c # Push to the server a new version $ git push -u origin master # You can do the shorter version if its always master $ git push Push branch commits to github # Setuo origin remote $ git remote add origin https://github.com/electroheadfx/test.git $ git push -u origin master # list the remote $ git remote -v # if a problem, you can remove it with: $ Add gitignore git commit # Create gitignore $ touch .gitignore # Edit it in vs code for add files to ignore $ code .gitignore # Add it to repo $ git add .gitignore # Commit it $ git commit -m \"add gitignore\" Update Your repo There 2 ways to do it : # 1- In old day we get the repo with fetch and merge FETCH_HEAD $ git fetch https://github.com/electroheadfx/test.git $ git merge FETCH_HEAD # 2- Now its easier to pull directely : $ git pull https://github.com/electroheadfx/test.git # If there is conflit, fix them in code and does a : $ git commit -m \"update\" GIT Rebase process Setup to do on the repo before git config --global credential.helper store git config --global pull.rebase true git config --global merge.ff true Switch on develop : git checkout develop Create your own branch git checkout -b feature/name_of_the_feature We flat a commit series where N is the number of previous commit to squash git rebase -i HEAD~N Before to commit, we switch on develop branch and update it: git checkout develop git pull We switch back to feature branch git checkout feature/name_of_the_feature we update the branch from develop rebase command : git rebase develop feature/name_of_the_feature is update, we swich on develop for merge the branch git checkout develop git merge feature/name_of_the_feature Push all on the server git push We can destroy the feature/name_of_the_feature git branch -D feature/name_of_the_feature Branch commands Rename a branch (g.g. main to master) git branch -m main master Copy a branch (main to dev branch) git branch -c main dev Delete branch git branch -d dev Git Tools - Restore and reset git restore <a-file-or-a-folder> git reset <pathspec> # is the opposite of : git add <pathspec> # equivalent to : git restore [ --source = <tree-ish> ] --staged <pathspec> Git - git-reset Documentation Git Tools - Stashing and Cleaning git status Changes to be committed: ( use \"git reset HEAD <file>...\" to unstage ) modified: index.html git stash git status # On branch master nothing to commit, working directory clean # list stored stashes git stash list stash@ { 0 } : WIP on master: 049d078 Create index file stash@ { 1 } : WIP on master: c264051 Revert \"Add file_size\" stash@ { 2 } : WIP on master: 21d80a5 Add number to log # apply the previous stash git stash apply # apply the stash@{2} git stash apply stash@ { 2 } # Drop any stash git stash drop stash@ { 2 } Git - Stashing and Cleaning Git subtree : Publish a folder to a branch in github # for exemple you add dist (static files) to our repo git add dist && git commit -m \"Initial dist subtree commit\" # Push dist folder to github gh-pages branch git subtree push --prefix dist origin gh-pages # then at each normal push to the main branch, dist is pushed to gh-pages Git subtree script for gh-deploy I create a script called gh-deploy for automate the subtree push: #!/bin/sh if [ -z \" $1 \" ] then echo \"Which folder do you want to deploy to GitHub Pages?\" exit 1 fi git subtree push --prefix $1 origin gh-pages and use the script in this way: git gh-deploy path/to/your/site","title":"Git Master commands"},{"location":"pages/tools/git/#git-master-commands","text":"","title":"Git Master commands"},{"location":"pages/tools/git/#github-base","text":"List the actual Config setup from current directory $ git config -l Setup the Global Config # Exemple $ git config --global user.name electroheadfx $ git config --global user.email \"laurent@efxdesign.fr\" Setup the local Config (per project) # Exemple $ git config user.name efx $ git config user.email \"laurent@electroheadfx.fr\"","title":"Github base"},{"location":"pages/tools/git/#setup-for-mac-lfcr","text":"git config --global core.autocrlf input","title":"Setup for mac lf/cr"},{"location":"pages/tools/git/#setup-for-windows-lfcr","text":"git config --global core.autocrlf true","title":"Setup for windows lf/cr"},{"location":"pages/tools/git/#setup-for-rebase","text":"git config --global credential.helper store git config --global pull.rebase true git config --global merge.ff true","title":"Setup for rebase"},{"location":"pages/tools/git/#create-a-git-project","text":"# Create a folder $ mkdir folder && cd folder # init git (when the project is new) $ git init # Add origin url from remote $ git remote add origin https://github.com/electroheadfx/test.git # Now you can push the code after you will add file then commit $ git push -u origin master Add file and commit # add folder, files $ git add [ folders ] [ file1 ] [ file2 ] # or add all from current directory $ git add . # commit the added file with a message $ git commit -m \u201dmsg\u201d # Push on server to origin from master $ git push -u origin master Git status and log # Commit status $ git status # See all the commits done $ git log # See all the i commits $ git log -n i # See All the diff before git add $ git diff Revert a file to last comit git checkout file","title":"Create a git project"},{"location":"pages/tools/git/#git-branches","text":"# cr\u00e9\u00e9 une branche au repo $ git branch myfeature # see all branchs list $ git branch # switch to myfeature branch $ git checkout myfeature # see the diff between 2 branch $ git diff master...myfeature # Create master branch $ git branch master # merge branch my feature on master $ git merge myfeature # delete myfeature branch $ git branch -d myfeature","title":"Git Branches"},{"location":"pages/tools/git/#get-a-git-repository","text":"# Create a test folder with the repo $ git clone https://github.com/electroheadfx/test.git Delete/add a folder and commit # Remove a folder $ git rm -rf <folder> # Remove files $ git rm file1 file2 # Commit with a message $ git commit -m \u201cmsg\u201c # Push the commit on server to master like origin, after just do git push $ git push -u origin master # Add a folder or file $ git add <folder> file1 file2 # commit again $ git commit -m \u201cmsg\u201c # Push to the server a new version $ git push -u origin master # You can do the shorter version if its always master $ git push Push branch commits to github # Setuo origin remote $ git remote add origin https://github.com/electroheadfx/test.git $ git push -u origin master # list the remote $ git remote -v # if a problem, you can remove it with: $ Add gitignore git commit # Create gitignore $ touch .gitignore # Edit it in vs code for add files to ignore $ code .gitignore # Add it to repo $ git add .gitignore # Commit it $ git commit -m \"add gitignore\"","title":"Get a GIT repository"},{"location":"pages/tools/git/#update-your-repo","text":"There 2 ways to do it : # 1- In old day we get the repo with fetch and merge FETCH_HEAD $ git fetch https://github.com/electroheadfx/test.git $ git merge FETCH_HEAD # 2- Now its easier to pull directely : $ git pull https://github.com/electroheadfx/test.git # If there is conflit, fix them in code and does a : $ git commit -m \"update\"","title":"Update Your repo"},{"location":"pages/tools/git/#git-rebase-process","text":"Setup to do on the repo before git config --global credential.helper store git config --global pull.rebase true git config --global merge.ff true Switch on develop : git checkout develop Create your own branch git checkout -b feature/name_of_the_feature We flat a commit series where N is the number of previous commit to squash git rebase -i HEAD~N Before to commit, we switch on develop branch and update it: git checkout develop git pull We switch back to feature branch git checkout feature/name_of_the_feature we update the branch from develop rebase command : git rebase develop feature/name_of_the_feature is update, we swich on develop for merge the branch git checkout develop git merge feature/name_of_the_feature Push all on the server git push We can destroy the feature/name_of_the_feature git branch -D feature/name_of_the_feature","title":"GIT Rebase process"},{"location":"pages/tools/git/#branch-commands","text":"Rename a branch (g.g. main to master) git branch -m main master Copy a branch (main to dev branch) git branch -c main dev Delete branch git branch -d dev","title":"Branch commands"},{"location":"pages/tools/git/#git-tools-restore-and-reset","text":"git restore <a-file-or-a-folder> git reset <pathspec> # is the opposite of : git add <pathspec> # equivalent to : git restore [ --source = <tree-ish> ] --staged <pathspec> Git - git-reset Documentation","title":"Git Tools - Restore and reset"},{"location":"pages/tools/git/#git-tools-stashing-and-cleaning","text":"git status Changes to be committed: ( use \"git reset HEAD <file>...\" to unstage ) modified: index.html git stash git status # On branch master nothing to commit, working directory clean # list stored stashes git stash list stash@ { 0 } : WIP on master: 049d078 Create index file stash@ { 1 } : WIP on master: c264051 Revert \"Add file_size\" stash@ { 2 } : WIP on master: 21d80a5 Add number to log # apply the previous stash git stash apply # apply the stash@{2} git stash apply stash@ { 2 } # Drop any stash git stash drop stash@ { 2 } Git - Stashing and Cleaning","title":"Git Tools - Stashing and Cleaning"},{"location":"pages/tools/git/#git-subtree-publish-a-folder-to-a-branch-in-github","text":"# for exemple you add dist (static files) to our repo git add dist && git commit -m \"Initial dist subtree commit\" # Push dist folder to github gh-pages branch git subtree push --prefix dist origin gh-pages # then at each normal push to the main branch, dist is pushed to gh-pages","title":"Git subtree : Publish a folder to a branch in github"},{"location":"pages/tools/git/#git-subtree-script-for-gh-deploy","text":"I create a script called gh-deploy for automate the subtree push: #!/bin/sh if [ -z \" $1 \" ] then echo \"Which folder do you want to deploy to GitHub Pages?\" exit 1 fi git subtree push --prefix $1 origin gh-pages and use the script in this way: git gh-deploy path/to/your/site","title":"Git subtree script for gh-deploy"},{"location":"pages/tools/node/","text":"Node Degit install from current working directory mkdir react-prerequis-debutants && cd !$ npx degit https://github.com/MikeCodeur/react-prerequis-debutants npm run install # or npm i npm run test # run test npm run start # or npm run dev (see package.json > scripts) install to a directory repo npx degit https://github.com/MikeCodeur/react-prerequis-debutants repo cd repo npm i npm run start GitHub - Rich-Harris/degit: Straightforward project scaffolding","title":"Node"},{"location":"pages/tools/node/#node","text":"","title":"Node"},{"location":"pages/tools/node/#degit","text":"install from current working directory mkdir react-prerequis-debutants && cd !$ npx degit https://github.com/MikeCodeur/react-prerequis-debutants npm run install # or npm i npm run test # run test npm run start # or npm run dev (see package.json > scripts) install to a directory repo npx degit https://github.com/MikeCodeur/react-prerequis-debutants repo cd repo npm i npm run start GitHub - Rich-Harris/degit: Straightforward project scaffolding","title":"Degit"},{"location":"pages/tools/services/","text":"Services Icons ic\u00f4nes Material, Carbon, Phosphor, Bootstrap, Gridicons libraries ... Icons, Emojis - Material for MkDocs http Codes de r\u00e9ponse HTTP - HTTP | MDN Super simple service for generating different HTTP codes Node/javascript Package Find NPM Package Alternatives : pkg.land Cost of adding npm package in bundle : bundlephobia : find the cost of adding a npm package to your bundle Dev Placeholder and mocking Free fake API for testing and prototyping in JSON : jsonplaceholder Simple HTTP Request & Response Service : httpbin.org API mocking library : Mirage JS RapidAPI with VSCODE , Tutorial here React React docs beta pmndrs/suspend-react: \ud83d\udea5 Async/await for React components Bash GitHub - ranger/ranger: A VIM-inspired filemanager for the console VScode Quokka.js: Introduction New Frameworks/tools # Virtual DOM into the future with preact The next-gen web framework with preact and Deno iles framework based on vuejs on islands multi-libraries RGPD/Copyright RGPD e-Services - Touati La Motte Rouge Avocats","title":"Services"},{"location":"pages/tools/services/#services","text":"","title":"Services"},{"location":"pages/tools/services/#icons","text":"ic\u00f4nes Material, Carbon, Phosphor, Bootstrap, Gridicons libraries ... Icons, Emojis - Material for MkDocs","title":"Icons"},{"location":"pages/tools/services/#http","text":"Codes de r\u00e9ponse HTTP - HTTP | MDN Super simple service for generating different HTTP codes","title":"http"},{"location":"pages/tools/services/#nodejavascript-package","text":"Find NPM Package Alternatives : pkg.land Cost of adding npm package in bundle : bundlephobia : find the cost of adding a npm package to your bundle","title":"Node/javascript Package"},{"location":"pages/tools/services/#dev-placeholder-and-mocking","text":"Free fake API for testing and prototyping in JSON : jsonplaceholder Simple HTTP Request & Response Service : httpbin.org API mocking library : Mirage JS RapidAPI with VSCODE , Tutorial here","title":"Dev Placeholder and mocking"},{"location":"pages/tools/services/#react","text":"React docs beta pmndrs/suspend-react: \ud83d\udea5 Async/await for React components","title":"React"},{"location":"pages/tools/services/#bash","text":"GitHub - ranger/ranger: A VIM-inspired filemanager for the console","title":"Bash"},{"location":"pages/tools/services/#vscode","text":"Quokka.js: Introduction","title":"VScode"},{"location":"pages/tools/services/#new-frameworkstools","text":"# Virtual DOM into the future with preact The next-gen web framework with preact and Deno iles framework based on vuejs on islands multi-libraries","title":"New Frameworks/tools"},{"location":"pages/tools/services/#rgpdcopyright","text":"RGPD e-Services - Touati La Motte Rouge Avocats","title":"RGPD/Copyright"},{"location":"pages/tools/docker/","tags":["Docker"],"text":"","title":"Docker"},{"location":"pages/tools/docker/docker-exercice1/","text":"Create a dockerfile/ex1 Project Based this video GitHub - Antoine-Flo/tuto-docker Setup project The Project setup is available here npm init -y npm i express touch app.js code app.js Enter this code in app.js const express = require ( 'express' ) const app = express () const port = 8080 app.get ( '/' , ( req, res ) = > { res.send ( 'Hello World!' ) }) # it expose port 8080 and log the info app.listen ( port, () = > { console.log ( ` App listening port ${ port } ` ) }) From package.json, change \"main\" to \"app.js\" Create Dockerfile touch Dockerfile touch .dockerignore # ignore node_modules from our repository because it will be installed # from our docker image echo \"node_modules\" > .dockerignore code Dockerfile Put this code in Dockerfile : FROM node:alpine # Setup the working path (where all goes) inside the node image WORKDIR /usr/src/app # install package and install COPY package*.json ./ RUN npm install && npm cache clean --force # copy all the current files in the Image working dir COPY . . # CREATE THE PORT EXPOSE 8080 # execute the process from the app CMD [ \"node\" , \"app.js\" ] Build our Docker Image # . : build from current directory # -t : create the image test-app from the folder efx docker build . -t efx/test-app Test our docker image # Create container from test-app image on port 3000 docker run -p 3000 :8080 efx/test-app How the port work with Docker : Docker Volume #create a volume $ docker volume create data #show volume liste $ docker volume ls DRIVER VOLUME NAME local data #show volume info $ docker volume inspect data #exemple with postgres sync data on volume $ docker run -v postgres-data:/var/lib/postgresql/datap postgres #sync data an external volume on disk without docker volume $ docker run --mount \\ type = bind,source = /home/exyzt/Documents,target = /var/lib/postgresql/data Docker compose #list all compose command available $ docker compose console #create the compose file $ touch docker-compose.yml : cat <<EOF > docker-compose.yml services: app: build: . depends_on: - postgres environment: DATABASE_URL: postgres://user:pass@postgres:5432/db ports: - \"3000:8080\" postgres: # connect to database postgres @ localhost:5432 # on pg_db Database with user: efx, pass: 1234 image: postgres:alpine environment: POSTGRES_PASSWORD: 1234 POSTGRES_DB: pg_db POSTGRES_USER: efx ports: - \"5432:5432\" volumes: - volumePgData:/var/lib/postgresql/data volumes: volumePgData: EOF #Run our compose $ docker-compose up Compose commands #Stop the container(s) using the following command: docker-compose down #Delete all containers using the following command: docker rm -f $( docker ps -a -q ) #Delete all volumes using the following command: docker volume rm $( docker volume ls -q ) #Restart the containers using the following command: docker-compose up -d","title":"Create a dockerfile/ex1"},{"location":"pages/tools/docker/docker-exercice1/#create-a-dockerfileex1","text":"Project Based this video GitHub - Antoine-Flo/tuto-docker","title":"Create a dockerfile/ex1"},{"location":"pages/tools/docker/docker-exercice1/#setup-project","text":"The Project setup is available here npm init -y npm i express touch app.js code app.js Enter this code in app.js const express = require ( 'express' ) const app = express () const port = 8080 app.get ( '/' , ( req, res ) = > { res.send ( 'Hello World!' ) }) # it expose port 8080 and log the info app.listen ( port, () = > { console.log ( ` App listening port ${ port } ` ) }) From package.json, change \"main\" to \"app.js\"","title":"Setup project"},{"location":"pages/tools/docker/docker-exercice1/#create-dockerfile","text":"touch Dockerfile touch .dockerignore # ignore node_modules from our repository because it will be installed # from our docker image echo \"node_modules\" > .dockerignore code Dockerfile Put this code in Dockerfile : FROM node:alpine # Setup the working path (where all goes) inside the node image WORKDIR /usr/src/app # install package and install COPY package*.json ./ RUN npm install && npm cache clean --force # copy all the current files in the Image working dir COPY . . # CREATE THE PORT EXPOSE 8080 # execute the process from the app CMD [ \"node\" , \"app.js\" ]","title":"Create Dockerfile"},{"location":"pages/tools/docker/docker-exercice1/#build-our-docker-image","text":"# . : build from current directory # -t : create the image test-app from the folder efx docker build . -t efx/test-app","title":"Build our Docker Image"},{"location":"pages/tools/docker/docker-exercice1/#test-our-docker-image","text":"# Create container from test-app image on port 3000 docker run -p 3000 :8080 efx/test-app How the port work with Docker :","title":"Test our docker image"},{"location":"pages/tools/docker/docker-exercice1/#docker-volume","text":"#create a volume $ docker volume create data #show volume liste $ docker volume ls DRIVER VOLUME NAME local data #show volume info $ docker volume inspect data #exemple with postgres sync data on volume $ docker run -v postgres-data:/var/lib/postgresql/datap postgres #sync data an external volume on disk without docker volume $ docker run --mount \\ type = bind,source = /home/exyzt/Documents,target = /var/lib/postgresql/data","title":"Docker Volume"},{"location":"pages/tools/docker/docker-exercice1/#docker-compose","text":"#list all compose command available $ docker compose console #create the compose file $ touch docker-compose.yml : cat <<EOF > docker-compose.yml services: app: build: . depends_on: - postgres environment: DATABASE_URL: postgres://user:pass@postgres:5432/db ports: - \"3000:8080\" postgres: # connect to database postgres @ localhost:5432 # on pg_db Database with user: efx, pass: 1234 image: postgres:alpine environment: POSTGRES_PASSWORD: 1234 POSTGRES_DB: pg_db POSTGRES_USER: efx ports: - \"5432:5432\" volumes: - volumePgData:/var/lib/postgresql/data volumes: volumePgData: EOF #Run our compose $ docker-compose up","title":"Docker compose"},{"location":"pages/tools/docker/docker-exercice1/#compose-commands","text":"#Stop the container(s) using the following command: docker-compose down #Delete all containers using the following command: docker rm -f $( docker ps -a -q ) #Delete all volumes using the following command: docker volume rm $( docker volume ls -q ) #Restart the containers using the following command: docker-compose up -d","title":"Compose commands"},{"location":"pages/tools/docker/docker-exercice2/","text":"Create a dockerfile/ex2 App Create app.py : from flask import Flask from redis import Redis , RedisError import os import socket # Connect to Redis redis = Redis ( host = \"redis\" , db = 0 , socket_connect_timeout = 2 , socket_timeout = 2 ) app = Flask ( __name__ ) @app . route ( \"/\" ) def hello (): try : visites = redis . incr ( \"compteur\" ) except RedisError : visites = \"<i>Erreur de connection Redis, compteur desactive</i>\" html = \"<h3>Bonjour {nom} !</h3>\" \\ \"<b>Hostname:</b> {hostname} <br/>\" \\ \"<b>Visites:</b> {visites} <br/>\" \\ \"<p>Abonne toi!</p>\" return html . format ( nom = os . getenv ( \"NOM\" , \"youtube\" ), hostname = socket . gethostname (), visites = visites ) if __name__ == \"__main__\" : app . run ( host = '0.0.0.0' , port = 80 ) Create requirements.txt cat <<EOF > requirements.txt Flask Redis EOF Dockerfile Setup Dockerfile : # start from python slim image FROM python:2.7-slim # definite the working directory on the image : root/app WORKDIR /app # copy all file from current repo to /app COPY . /app # install python libs from requirements.txt RUN pip install -r requirements.txt # expose to the web (port 80) EXPOSE 80 # setup env variable nom=coca ENV NOM coca # execute app.py with python at container creation CMD [ \"python\" , \"app.py\" ] Create the Docker Image with: # create `monimage` from current directory # where Dockerfile exist docker build -t monimage . Docker-compose Create now docker-compose.yml : version: \"3\" services: monapp: image: monimage depends_on: - redis ports: - \"80:80\" networks: - monreseau environment: - NOM=les amis redis: image: redis networks: - monreseau networks: monreseau: We create here 2 services and the networks monapp : Create container from from our monimage created previously. it depends of redis service into monreseau network redis : Create container from redis into monreseau monreseau network declared Run the container with compose # it mount containers and create the services docker-compose up Run the app on : http://localhost:80 ! GitHub Video","title":"Create a dockerfile/ex2"},{"location":"pages/tools/docker/docker-exercice2/#create-a-dockerfileex2","text":"","title":"Create a dockerfile/ex2"},{"location":"pages/tools/docker/docker-exercice2/#app","text":"Create app.py : from flask import Flask from redis import Redis , RedisError import os import socket # Connect to Redis redis = Redis ( host = \"redis\" , db = 0 , socket_connect_timeout = 2 , socket_timeout = 2 ) app = Flask ( __name__ ) @app . route ( \"/\" ) def hello (): try : visites = redis . incr ( \"compteur\" ) except RedisError : visites = \"<i>Erreur de connection Redis, compteur desactive</i>\" html = \"<h3>Bonjour {nom} !</h3>\" \\ \"<b>Hostname:</b> {hostname} <br/>\" \\ \"<b>Visites:</b> {visites} <br/>\" \\ \"<p>Abonne toi!</p>\" return html . format ( nom = os . getenv ( \"NOM\" , \"youtube\" ), hostname = socket . gethostname (), visites = visites ) if __name__ == \"__main__\" : app . run ( host = '0.0.0.0' , port = 80 ) Create requirements.txt cat <<EOF > requirements.txt Flask Redis EOF","title":"App"},{"location":"pages/tools/docker/docker-exercice2/#dockerfile","text":"Setup Dockerfile : # start from python slim image FROM python:2.7-slim # definite the working directory on the image : root/app WORKDIR /app # copy all file from current repo to /app COPY . /app # install python libs from requirements.txt RUN pip install -r requirements.txt # expose to the web (port 80) EXPOSE 80 # setup env variable nom=coca ENV NOM coca # execute app.py with python at container creation CMD [ \"python\" , \"app.py\" ] Create the Docker Image with: # create `monimage` from current directory # where Dockerfile exist docker build -t monimage .","title":"Dockerfile"},{"location":"pages/tools/docker/docker-exercice2/#docker-compose","text":"Create now docker-compose.yml : version: \"3\" services: monapp: image: monimage depends_on: - redis ports: - \"80:80\" networks: - monreseau environment: - NOM=les amis redis: image: redis networks: - monreseau networks: monreseau: We create here 2 services and the networks monapp : Create container from from our monimage created previously. it depends of redis service into monreseau network redis : Create container from redis into monreseau monreseau network declared","title":"Docker-compose"},{"location":"pages/tools/docker/docker-exercice2/#run-the-container-with-compose","text":"# it mount containers and create the services docker-compose up","title":"Run the container with compose"},{"location":"pages/tools/docker/docker-exercice2/#run-the-app-on-httplocalhost80","text":"GitHub Video","title":"Run the app on : http://localhost:80 !"},{"location":"pages/tools/docker/docker-start/","text":"Docker Start Find Docker Images Hub docker : https://hub.docker.com Basic Docker image docker image docker image essentials commands : docker image ... build # Build an image from a Dockerfile inspect # Display detailed information on one or more images load # Load an image from a tar archive or STDIN ls # List images prune # Remove unused images pull # Pull an image or a repository from a registry push # Push an image or a repository to a registry rm # Remove one or more images save # Save one or more images to a tar archive tag # Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE # shorcut for docker image ls docker images # delete an image docker rmi image_name Docker container # list all container commands docker container # list all containers mounted docker container ls # list all containers (mounted and unmounted) docker container ls -a Docker pull # Download an docker imagz with pull docker pull hello-world Docker run # download image `ubuntu` and run in interactive mode like root user # --rm delete the container when exit it # bash is the command it run from the container docker run -it --rm ubuntu bash Docker activity with ps , rm, stop, prune # list all containers running docker ps # list all containers running and stopped docker ps -a # stop a container docker stop container_id # delete a container docker rm container_id # CLEAN docker ram remove : # - all stopped docker # - all networks not used # - all dangling images and build cache docker system prune Practice with docker # download image `debian` run and ssh login like root from it # -it = execute in interactive mode for run command without exit $ docker run -it debian # --rm : Automatically remove the container when we exit bash window $ docker run --rm -it debian # -v : Bind mount a volume $ docker run --rm -it -v ${ PWD } :/var/www/html debian # run a command from container $ docker run -rm -it -v ${ PWD } :/var/www/html \\ -p 8000 :80 \\ # Map 8O port from container to 8000 port php:apache \\ # The image with apache like tag apache2-foreground # The command to run Docker run always mount a fresh container from image Docker creation (commit) # List difference between the docker running and the image $ docker diff container_id # Save docker diff to the disk in a new image $ docker commit container_id debiantest # Exit and Export the new image $ exit $ docker save debiantest > /var/www/Lab/debiantest.tar Exemple docker-wordpress pas besoin de faire un docker pull # here we map the port of the container 80 to the machine 80 # -p external_port:container_port $ docker run -p 80 :80 tutum/wordpress # with -d : run the container in background WARMING The date in container are not persisted, you lost all when you close the bash, so you need to sync the data to the disk : # -v folder/to/your/disk:folder/in/docker # --name is for name the container with a nice name : $ docker ps # -d run docker in background task name ghost $ docker run --name some-ghost -p 8080 :2368 \\ -v /var/www/Lab/ghost:/varlib/ghost \\ -d ghost # I modify file in /var/www/Lab/ghost # if after I remove the container with: $ docker rm -f some-ghost # the container is destroyed # if I re create the container with the image : $ docker run --name some-ghost -p 8080 :2368 \\ -v /var/www/Lab/ghost:/varlib/ghost \\ -d ghost # The data is persisted because its always linked with /var/www/Lab/ghost Permission issue with Docker When you create file from container, the synchronized file are create like root user, it an issue. Just fix with --user param : # ${PWD}:/app : app container mapped to current folder $ docker run --rm -ti -v ${ PWD } :/app --user 1000 :100 -p 8000 :80 # get the user $ id -u 1000 # get group $ id -g 100 # use it in docker run $ docker run --rm -ti -v ${ PWD } :/app --user $( id -u ) : $( id -g )","title":"Docker Start"},{"location":"pages/tools/docker/docker-start/#docker-start","text":"","title":"Docker Start"},{"location":"pages/tools/docker/docker-start/#find-docker-images","text":"Hub docker : https://hub.docker.com","title":"Find Docker Images"},{"location":"pages/tools/docker/docker-start/#basic","text":"","title":"Basic"},{"location":"pages/tools/docker/docker-start/#docker-image","text":"docker image docker image essentials commands : docker image ... build # Build an image from a Dockerfile inspect # Display detailed information on one or more images load # Load an image from a tar archive or STDIN ls # List images prune # Remove unused images pull # Pull an image or a repository from a registry push # Push an image or a repository to a registry rm # Remove one or more images save # Save one or more images to a tar archive tag # Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE # shorcut for docker image ls docker images # delete an image docker rmi image_name","title":"Docker image"},{"location":"pages/tools/docker/docker-start/#docker-container","text":"# list all container commands docker container # list all containers mounted docker container ls # list all containers (mounted and unmounted) docker container ls -a","title":"Docker container"},{"location":"pages/tools/docker/docker-start/#docker-pull","text":"# Download an docker imagz with pull docker pull hello-world","title":"Docker pull"},{"location":"pages/tools/docker/docker-start/#docker-run","text":"# download image `ubuntu` and run in interactive mode like root user # --rm delete the container when exit it # bash is the command it run from the container docker run -it --rm ubuntu bash","title":"Docker run"},{"location":"pages/tools/docker/docker-start/#docker-activity-with-ps-rm-stop-prune","text":"# list all containers running docker ps # list all containers running and stopped docker ps -a # stop a container docker stop container_id # delete a container docker rm container_id # CLEAN docker ram remove : # - all stopped docker # - all networks not used # - all dangling images and build cache docker system prune","title":"Docker activity with ps , rm, stop, prune"},{"location":"pages/tools/docker/docker-start/#practice-with-docker","text":"# download image `debian` run and ssh login like root from it # -it = execute in interactive mode for run command without exit $ docker run -it debian # --rm : Automatically remove the container when we exit bash window $ docker run --rm -it debian # -v : Bind mount a volume $ docker run --rm -it -v ${ PWD } :/var/www/html debian # run a command from container $ docker run -rm -it -v ${ PWD } :/var/www/html \\ -p 8000 :80 \\ # Map 8O port from container to 8000 port php:apache \\ # The image with apache like tag apache2-foreground # The command to run Docker run always mount a fresh container from image","title":"Practice with docker"},{"location":"pages/tools/docker/docker-start/#docker-creation-commit","text":"# List difference between the docker running and the image $ docker diff container_id # Save docker diff to the disk in a new image $ docker commit container_id debiantest # Exit and Export the new image $ exit $ docker save debiantest > /var/www/Lab/debiantest.tar","title":"Docker creation (commit)"},{"location":"pages/tools/docker/docker-start/#exemple-docker-wordpress","text":"pas besoin de faire un docker pull # here we map the port of the container 80 to the machine 80 # -p external_port:container_port $ docker run -p 80 :80 tutum/wordpress # with -d : run the container in background WARMING The date in container are not persisted, you lost all when you close the bash, so you need to sync the data to the disk : # -v folder/to/your/disk:folder/in/docker # --name is for name the container with a nice name : $ docker ps # -d run docker in background task name ghost $ docker run --name some-ghost -p 8080 :2368 \\ -v /var/www/Lab/ghost:/varlib/ghost \\ -d ghost # I modify file in /var/www/Lab/ghost # if after I remove the container with: $ docker rm -f some-ghost # the container is destroyed # if I re create the container with the image : $ docker run --name some-ghost -p 8080 :2368 \\ -v /var/www/Lab/ghost:/varlib/ghost \\ -d ghost # The data is persisted because its always linked with /var/www/Lab/ghost","title":"Exemple docker-wordpress"},{"location":"pages/tools/docker/docker-start/#permission-issue-with-docker","text":"When you create file from container, the synchronized file are create like root user, it an issue. Just fix with --user param : # ${PWD}:/app : app container mapped to current folder $ docker run --rm -ti -v ${ PWD } :/app --user 1000 :100 -p 8000 :80 # get the user $ id -u 1000 # get group $ id -g 100 # use it in docker run $ docker run --rm -ti -v ${ PWD } :/app --user $( id -u ) : $( id -g )","title":"Permission issue with Docker"},{"location":"pages/tools/static/","tags":["Static"],"text":"","title":"Static Site Generators"},{"location":"pages/tools/static/docusaurus-create/","text":"Create doc with Docusaurus in GitLab Pages 2022-02-25 Here the Docusaurus docs et GitLab Pages docs . Create a Docusaurus project $ npx create-docusaurus@latest <your-repo> classic $ npm install @cmfcmf/docusaurus-search-local Add to docusaurus.config.js file before themeConfig: // ... plugins : [ [ require . resolve ( \"@cmfcmf/docusaurus-search-local\" ), { language : \"fr\" , } ], ], themeConfig : // ... Create the build and test the search with serve : $ npm run build $ npm run serve Go in repo cd <your-repo> And start the dev $ npx docusaurus start # or npm run start Custom project All are in docusaurus.config.js file Change the title and tagline const config = { title : 'YoanDev Doc' , tagline : 'Documenter c\\'est cool !' , Change the menu and logo: navbar : { title : 'YoanDev Doc' , logo : { alt : 'My Site Logo' , src : 'img/logo.svg' , }, Change the copyright in footer copyright : `Copyright \u00a9 ${ new Date (). getFullYear () } YoanDev Doc. Built with Docusaurus.` , Change the style with : src/css/custom.css Here a style generator : Styling layout in Docusaurus . Change dark theme: [ data-theme = 'dark' ] { --ifm-color-primary : #b3dde6 ; --ifm-color-primary-dark : #94cfdc ; --ifm-color-primary-darker : #85c8d7 ; --ifm-color-primary-darkest : #57b4c8 ; --ifm-color-primary-light : #d2ebf0 ; --ifm-color-primary-lighter : #e1f2f5 ; --ifm-color-primary-lightest : #ffffff ; } light theme: :root { --ifm-color-primary : #043c48 ; --ifm-color-primary-dark : #043641 ; --ifm-color-primary-darker : #03333d ; --ifm-color-primary-darkest : #032a32 ; --ifm-color-primary-light : #04424f ; --ifm-color-primary-lighter : #054553 ; --ifm-color-primary-lightest : #054e5e ; } Change Doc content Supress Blog 2 steps Delete blog directory and remove link in docusaurus.config.js file: // header menu { to : '/blog' , label : 'Blog' , position : 'left' }, // in footer { label : 'Blog' , to : '/blog' , }, Produce content Add a new section For exemple create a docs/efx-doc directory Create a file : _category_.json to the root of efx-doc directory : { \"label\" : \"YoanDev - Doc\" , \"position\" : 4 } And add a markdown demo.md file --- sidebar_position: 1 --- # Ceci est un H1 ## Ceci est un H2 ### Ceci est un H3 **Texte en gras** *Texte en italique* Ceci est une liste : * Lorem * ipsum > Ceci est un citation :::danger Ceci est le titre du bloc ! Ceci est un blog de **danger** ::: :::success Ceci est un blog de **success** ::: Doc are available : Add a extension theme syntax add-on, e.g. php Open docusaurus.config.js and add: prism : { theme : lightCodeTheme , darkTheme : darkCodeTheme , // Ajoutons le php avec cette ligne additionalLanguages : [ 'php' ], }, GitLab Pages Create the repo Create a free account on GitLab.com Create a GitLab repo Do a git push on it Add a pipe deployment La publication de notre Docusaurus sera piloter par un pipeline GitLab CI (Et si les pipeline CI/CD vous interesse, vous pouvez jetter un cop d\u2019oeil \u00e0 ma formation sur le sujet ) Cr\u00e9ation d\u2019un fichier .gitlab-ci.yml \u00e0 la racine du projet, avec le contenu suivant: image : node:15.12-alpine3.13 stages : - test - deploy test : stage : test script : - npm install --force - npm run build pages : stage : deploy script : - npm install --force - npm run build - mv ./build ./public artifacts : paths : - public only : - pages Ce fichier, va faire les choses suivantes : Lors d\u2019un push: lancer un npm run build pour v\u00e9rifier que le build fonctionne bien Lors d\u2019un push, ou merge request sur la branche pages : lancer le build et g\u00e9n\u00e9rer un artefact avec la version statique de notre Docusaurus On commit et on push La branche pages Cr\u00e9ons la branche pages depuis GitLab (cela devrait imm\u00e9diatement lancer le pipeline de d\u00e9ploiement) Une fois la CI/CD ex\u00e9cut\u00e9e, dans Settings > Pages , activons le https et faisons un save changes Et testons la page ( l\u2019obtebtion du certificat pour le HTTPS peut ne pas \u00eatre imm\u00e9diat ! ) Adpatons le projet \u00e0 notre d\u00e9pot GitLab Modifions notre fichier docusaurus.config.js avec les adresses de notre d\u00e9pot const config = { title : 'YoanDev Doc' , tagline : 'Documenter c\\'est cool !' , url : 'https://yoandev.co.gitlab.io' , baseUrl : '/yoandev-doc-prepa/' , onBrokenLinks : 'throw' , onBrokenMarkdownLinks : 'warn' , favicon : 'img/favicon.ico' , organizationName : 'yoandev' , // Usually your GitHub org/user name. projectName : 'yoandev-doc-prepa' , // Usually your repo name. presets : [ [ 'classic' , /** @type {import('@docusaurus/preset-classic').Options} */ ({ docs : { sidebarPath : require . resolve ( './sidebars.js' ), // Please change this to your repo. editUrl : 'https://gitlab.com/yoandev.co/yoandev-doc-prepa/-/edit/master/' , }, blog : { showReadingTime : true , // Please change this to your repo. editUrl : 'https://gitlab.com/yoandev.co/yoandev-doc-prepa/-/edit/master/' , }, theme : { customCss : require . resolve ( './src/css/custom.css' ), }, }), ], ], Et faisons une Merge Request de Master vers Pages , et constatons le r\u00e9sultat \ud83d\ude80 BONUS : Ajoutons un moteur de recherche Il existe des solutions plus performante pour mettre en place un moteur de recherche, mais celle-ci \u00e0 le bon gout de fonctionner simplement, rapidement, y compris pour un d\u00e9pot priv\u00e9 (et donc un GitLab Pages non accessible \u00e0 tous le monde) Installons la d\u00e9pendance docusaurus-serach-local npm install npm install @cmfcmf/docusaurus-search-local Ajoutons la recherche dans le fichier docusaurus.config.js // ... plugins : [ [ require . resolve ( \"@cmfcmf/docusaurus-search-local\" ), { language : \"fr\" , } ], ], themeConfig : // ... Et finalement testons npm run build npm run serve Il ne nous reste qu\u2019\u00e0 commit + push + MR sur la branche pages ! Conclusions Nous venons de voir comment mettre en ligne hyper simplement un site statique de documentation \u00e0 l\u2019aide de plusieurs outils : Docusaurus, Gitlab CI et GitLab Pages ! Vous n\u2019avez plus aucunes excuse pour ne pas \u00e9crire et partager de la documentations avec vos coll\u00e8gues (vous devriez vous faire des plateformes de doc !), pour vos clients ou vos utilisateurs ! Nous allons poursuivre prochainement notre d\u00e9couverte des outils de g\u00e9n\u00e9ration de sites statique (jamstack) avec un g\u00e9n\u00e9rateur super cool pour un blog\u2026 rendez vous bient\u00f4t !","title":"Create doc with Docusaurus in GitLab Pages"},{"location":"pages/tools/static/docusaurus-create/#create-doc-with-docusaurus-in-gitlab-pages","text":"2022-02-25 Here the Docusaurus docs et GitLab Pages docs . Create a Docusaurus project $ npx create-docusaurus@latest <your-repo> classic $ npm install @cmfcmf/docusaurus-search-local Add to docusaurus.config.js file before themeConfig: // ... plugins : [ [ require . resolve ( \"@cmfcmf/docusaurus-search-local\" ), { language : \"fr\" , } ], ], themeConfig : // ... Create the build and test the search with serve : $ npm run build $ npm run serve Go in repo cd <your-repo> And start the dev $ npx docusaurus start # or npm run start","title":"Create doc with Docusaurus in GitLab Pages"},{"location":"pages/tools/static/docusaurus-create/#custom-project","text":"","title":"Custom project"},{"location":"pages/tools/static/docusaurus-create/#all-are-in-docusaurusconfigjs-file","text":"Change the title and tagline const config = { title : 'YoanDev Doc' , tagline : 'Documenter c\\'est cool !' , Change the menu and logo: navbar : { title : 'YoanDev Doc' , logo : { alt : 'My Site Logo' , src : 'img/logo.svg' , }, Change the copyright in footer copyright : `Copyright \u00a9 ${ new Date (). getFullYear () } YoanDev Doc. Built with Docusaurus.` ,","title":"All are in docusaurus.config.js file"},{"location":"pages/tools/static/docusaurus-create/#change-the-style-with-srccsscustomcss","text":"Here a style generator : Styling layout in Docusaurus . Change dark theme: [ data-theme = 'dark' ] { --ifm-color-primary : #b3dde6 ; --ifm-color-primary-dark : #94cfdc ; --ifm-color-primary-darker : #85c8d7 ; --ifm-color-primary-darkest : #57b4c8 ; --ifm-color-primary-light : #d2ebf0 ; --ifm-color-primary-lighter : #e1f2f5 ; --ifm-color-primary-lightest : #ffffff ; } light theme: :root { --ifm-color-primary : #043c48 ; --ifm-color-primary-dark : #043641 ; --ifm-color-primary-darker : #03333d ; --ifm-color-primary-darkest : #032a32 ; --ifm-color-primary-light : #04424f ; --ifm-color-primary-lighter : #054553 ; --ifm-color-primary-lightest : #054e5e ; }","title":"Change the style with :\u00a0src/css/custom.css"},{"location":"pages/tools/static/docusaurus-create/#change-doc-content","text":"","title":"Change Doc content"},{"location":"pages/tools/static/docusaurus-create/#supress-blog","text":"2 steps Delete blog directory and remove link in docusaurus.config.js file: // header menu { to : '/blog' , label : 'Blog' , position : 'left' }, // in footer { label : 'Blog' , to : '/blog' , },","title":"Supress\u00a0Blog"},{"location":"pages/tools/static/docusaurus-create/#produce-content","text":"Add a new section For exemple create a docs/efx-doc directory Create a file : _category_.json to the root of efx-doc directory : { \"label\" : \"YoanDev - Doc\" , \"position\" : 4 } And add a markdown demo.md file --- sidebar_position: 1 --- # Ceci est un H1 ## Ceci est un H2 ### Ceci est un H3 **Texte en gras** *Texte en italique* Ceci est une liste : * Lorem * ipsum > Ceci est un citation :::danger Ceci est le titre du bloc ! Ceci est un blog de **danger** ::: :::success Ceci est un blog de **success** ::: Doc are available :","title":"Produce content"},{"location":"pages/tools/static/docusaurus-create/#add-a-extension-theme-syntax-add-on-eg-php","text":"Open docusaurus.config.js and add: prism : { theme : lightCodeTheme , darkTheme : darkCodeTheme , // Ajoutons le php avec cette ligne additionalLanguages : [ 'php' ], },","title":"Add a extension theme syntax add-on, e.g. php"},{"location":"pages/tools/static/docusaurus-create/#gitlab-pages","text":"","title":"GitLab Pages"},{"location":"pages/tools/static/docusaurus-create/#create-the-repo","text":"Create a free account on GitLab.com Create a GitLab repo Do a git push on it","title":"Create the repo"},{"location":"pages/tools/static/docusaurus-create/#add-a-pipe-deployment","text":"La publication de notre Docusaurus sera piloter par un pipeline GitLab CI (Et si les pipeline CI/CD vous interesse, vous pouvez jetter un cop d\u2019oeil \u00e0 ma formation sur le sujet ) Cr\u00e9ation d\u2019un fichier .gitlab-ci.yml \u00e0 la racine du projet, avec le contenu suivant: image : node:15.12-alpine3.13 stages : - test - deploy test : stage : test script : - npm install --force - npm run build pages : stage : deploy script : - npm install --force - npm run build - mv ./build ./public artifacts : paths : - public only : - pages Ce fichier, va faire les choses suivantes : Lors d\u2019un push: lancer un npm run build pour v\u00e9rifier que le build fonctionne bien Lors d\u2019un push, ou merge request sur la branche pages : lancer le build et g\u00e9n\u00e9rer un artefact avec la version statique de notre Docusaurus On commit et on push","title":"Add a pipe deployment"},{"location":"pages/tools/static/docusaurus-create/#la-branche-pages","text":"Cr\u00e9ons la branche pages depuis GitLab (cela devrait imm\u00e9diatement lancer le pipeline de d\u00e9ploiement) Une fois la CI/CD ex\u00e9cut\u00e9e, dans Settings > Pages , activons le https et faisons un save changes Et testons la page ( l\u2019obtebtion du certificat pour le HTTPS peut ne pas \u00eatre imm\u00e9diat ! )","title":"La branche\u00a0pages"},{"location":"pages/tools/static/docusaurus-create/#adpatons-le-projet-a-notre-depot-gitlab","text":"Modifions notre fichier docusaurus.config.js avec les adresses de notre d\u00e9pot const config = { title : 'YoanDev Doc' , tagline : 'Documenter c\\'est cool !' , url : 'https://yoandev.co.gitlab.io' , baseUrl : '/yoandev-doc-prepa/' , onBrokenLinks : 'throw' , onBrokenMarkdownLinks : 'warn' , favicon : 'img/favicon.ico' , organizationName : 'yoandev' , // Usually your GitHub org/user name. projectName : 'yoandev-doc-prepa' , // Usually your repo name. presets : [ [ 'classic' , /** @type {import('@docusaurus/preset-classic').Options} */ ({ docs : { sidebarPath : require . resolve ( './sidebars.js' ), // Please change this to your repo. editUrl : 'https://gitlab.com/yoandev.co/yoandev-doc-prepa/-/edit/master/' , }, blog : { showReadingTime : true , // Please change this to your repo. editUrl : 'https://gitlab.com/yoandev.co/yoandev-doc-prepa/-/edit/master/' , }, theme : { customCss : require . resolve ( './src/css/custom.css' ), }, }), ], ], Et faisons une Merge Request de Master vers Pages , et constatons le r\u00e9sultat \ud83d\ude80","title":"Adpatons le projet \u00e0 notre d\u00e9pot GitLab"},{"location":"pages/tools/static/docusaurus-create/#bonus-ajoutons-un-moteur-de-recherche","text":"Il existe des solutions plus performante pour mettre en place un moteur de recherche, mais celle-ci \u00e0 le bon gout de fonctionner simplement, rapidement, y compris pour un d\u00e9pot priv\u00e9 (et donc un GitLab Pages non accessible \u00e0 tous le monde) Installons la d\u00e9pendance docusaurus-serach-local npm install npm install @cmfcmf/docusaurus-search-local Ajoutons la recherche dans le fichier docusaurus.config.js // ... plugins : [ [ require . resolve ( \"@cmfcmf/docusaurus-search-local\" ), { language : \"fr\" , } ], ], themeConfig : // ... Et finalement testons npm run build npm run serve Il ne nous reste qu\u2019\u00e0 commit + push + MR sur la branche pages !","title":"BONUS : Ajoutons un\u00a0moteur de recherche"},{"location":"pages/tools/static/docusaurus-create/#conclusions","text":"Nous venons de voir comment mettre en ligne hyper simplement un site statique de documentation \u00e0 l\u2019aide de plusieurs outils : Docusaurus, Gitlab CI et GitLab Pages ! Vous n\u2019avez plus aucunes excuse pour ne pas \u00e9crire et partager de la documentations avec vos coll\u00e8gues (vous devriez vous faire des plateformes de doc !), pour vos clients ou vos utilisateurs ! Nous allons poursuivre prochainement notre d\u00e9couverte des outils de g\u00e9n\u00e9ration de sites statique (jamstack) avec un g\u00e9n\u00e9rateur super cool pour un blog\u2026 rendez vous bient\u00f4t !","title":"Conclusions"},{"location":"pages/tools/static/mkdocs-material/","text":"Install mkdocs-material # Install mkdocs before mkdocs new <my-project> cd <my-project> pip install mkdocs-material # add image zoom feature pip install mkdocs-glightbox Add line to mkdocs.yml : theme : name : material Run or deploy on Github site_name: <your_site_name> site_url: https://<account>.github.io/<your_site_name> site_author: your name site_description: >- Efxdev docs, exercices, tips on web technologies and tools # Repository repo_name: <account>/<your_site_name> repo_url: https://github.com/<account>/<your_site_name> # Run in local mkdocs serve # deploy on github page : # info with : mkdocs gh-deploy --help mkdocs gh-deploy If you want custom material template add in mkdocs.yml : theme: name: material custom_dir: overrides The structure in the overrides directory must mirror the directory structure of the original theme, as any file in the overrides directory will replace the file with the same name which is part of the original theme. Besides, further assets may also be put in the overrides directory: . \u251c\u2500 .icons/ # Bundled icon sets \u251c\u2500 assets/ \u2502 \u251c\u2500 images/ # Images and icons \u2502 \u251c\u2500 javascripts/ # JavaScript files \u2502 \u2514\u2500 stylesheets/ # Style sheets \u251c\u2500 partials/ \u2502 \u251c\u2500 integrations/ # Third-party integrations \u2502 \u2502 \u251c\u2500 analytics/ # Analytics integrations \u2502 \u2502 \u2514\u2500 analytics.html # Analytics setup \u2502 \u251c\u2500 languages/ # Translation languages \u2502 \u251c\u2500 content.html # Page content \u2502 \u251c\u2500 copyright.html # Copyright and theme information \u2502 \u251c\u2500 footer.html # Footer bar \u2502 \u251c\u2500 header.html # Header bar \u2502 \u251c\u2500 language.html # Translation setup \u2502 \u251c\u2500 logo.html # Logo in header and sidebar \u2502 \u251c\u2500 nav.html # Main navigation \u2502 \u251c\u2500 nav-item.html # Main navigation item \u2502 \u251c\u2500 palette.html # Color palette \u2502 \u251c\u2500 search.html # Search interface \u2502 \u251c\u2500 social.html # Social links \u2502 \u251c\u2500 source.html # Repository information \u2502 \u251c\u2500 source-file.html # Source file information \u2502 \u251c\u2500 tabs.html # Tabs navigation \u2502 \u251c\u2500 tabs-item.html # Tabs navigation item \u2502 \u251c\u2500 toc.html # Table of contents \u2502 \u2514\u2500 toc-item.html # Table of contents item \u251c\u2500 404.html # 404 error page \u251c\u2500 base.html # Base template \u2514\u2500 main.html # Default page See the detail of files in : ~/Desktop/dev/docs/templates/mkdocs-material Extending MkDocs Material Docs Custom mkdocs-material template git clone https://github.com/squidfunk/mkdocs-material cd mkdocs-material pip install -e . pip install mkdocs-minify-plugin pip install mkdocs-redirect npm install mkdocs serve # ? mkdocs serve --watch-theme Doc & source mkdocs-material Git Material for MkDocs Customization - Material for MkDocs Installing the dev git clone https://github.com/squidfunk/mkdocs-material Next, all dependencies need to be installed, which is done with: cd mkdocs-material pip install -e . pip install mkdocs-minify-plugin pip install mkdocs-redirects npm install Start the watcher: npm start and in a seconde bash launch the preview: mkdocs serve --watch-theme Doc Installing dev of Material for MkDocs","title":"Install mkdocs-material"},{"location":"pages/tools/static/mkdocs-material/#install-mkdocs-material","text":"# Install mkdocs before mkdocs new <my-project> cd <my-project> pip install mkdocs-material # add image zoom feature pip install mkdocs-glightbox Add line to mkdocs.yml : theme : name : material Run or deploy on Github site_name: <your_site_name> site_url: https://<account>.github.io/<your_site_name> site_author: your name site_description: >- Efxdev docs, exercices, tips on web technologies and tools # Repository repo_name: <account>/<your_site_name> repo_url: https://github.com/<account>/<your_site_name> # Run in local mkdocs serve # deploy on github page : # info with : mkdocs gh-deploy --help mkdocs gh-deploy If you want custom material template add in mkdocs.yml : theme: name: material custom_dir: overrides The structure in the overrides directory must mirror the directory structure of the original theme, as any file in the overrides directory will replace the file with the same name which is part of the original theme. Besides, further assets may also be put in the overrides directory: . \u251c\u2500 .icons/ # Bundled icon sets \u251c\u2500 assets/ \u2502 \u251c\u2500 images/ # Images and icons \u2502 \u251c\u2500 javascripts/ # JavaScript files \u2502 \u2514\u2500 stylesheets/ # Style sheets \u251c\u2500 partials/ \u2502 \u251c\u2500 integrations/ # Third-party integrations \u2502 \u2502 \u251c\u2500 analytics/ # Analytics integrations \u2502 \u2502 \u2514\u2500 analytics.html # Analytics setup \u2502 \u251c\u2500 languages/ # Translation languages \u2502 \u251c\u2500 content.html # Page content \u2502 \u251c\u2500 copyright.html # Copyright and theme information \u2502 \u251c\u2500 footer.html # Footer bar \u2502 \u251c\u2500 header.html # Header bar \u2502 \u251c\u2500 language.html # Translation setup \u2502 \u251c\u2500 logo.html # Logo in header and sidebar \u2502 \u251c\u2500 nav.html # Main navigation \u2502 \u251c\u2500 nav-item.html # Main navigation item \u2502 \u251c\u2500 palette.html # Color palette \u2502 \u251c\u2500 search.html # Search interface \u2502 \u251c\u2500 social.html # Social links \u2502 \u251c\u2500 source.html # Repository information \u2502 \u251c\u2500 source-file.html # Source file information \u2502 \u251c\u2500 tabs.html # Tabs navigation \u2502 \u251c\u2500 tabs-item.html # Tabs navigation item \u2502 \u251c\u2500 toc.html # Table of contents \u2502 \u2514\u2500 toc-item.html # Table of contents item \u251c\u2500 404.html # 404 error page \u251c\u2500 base.html # Base template \u2514\u2500 main.html # Default page See the detail of files in : ~/Desktop/dev/docs/templates/mkdocs-material Extending MkDocs Material Docs","title":"Install mkdocs-material"},{"location":"pages/tools/static/mkdocs-material/#custom-mkdocs-material-template","text":"git clone https://github.com/squidfunk/mkdocs-material cd mkdocs-material pip install -e . pip install mkdocs-minify-plugin pip install mkdocs-redirect npm install mkdocs serve # ? mkdocs serve --watch-theme","title":"Custom mkdocs-material template"},{"location":"pages/tools/static/mkdocs-material/#doc-source","text":"mkdocs-material Git Material for MkDocs Customization - Material for MkDocs","title":"Doc &amp; source"},{"location":"pages/tools/static/mkdocs-material/#installing-the-dev","text":"git clone https://github.com/squidfunk/mkdocs-material Next, all dependencies need to be installed, which is done with: cd mkdocs-material pip install -e . pip install mkdocs-minify-plugin pip install mkdocs-redirects npm install Start the watcher: npm start and in a seconde bash launch the preview: mkdocs serve --watch-theme Doc Installing dev of Material for MkDocs","title":"Installing the dev"},{"location":"pages/tools/typescript/","tags":["Typescript"],"text":"","title":"Typescript"},{"location":"pages/tools/typescript/advanced/","text":"TypeScript Avanced Type et Interface Intersection type Fish = { fin : number ; element : \"water\" ; gills : true ; } type Shark = { weight : number ; length : number ; } type HammerheadShark = Fish & Shark & { test : \"abc\" }; const shark1 : HammerheadShark = { fin : 3 , element : \"water\" , gills : true , weight : 500 , length : 200 , test : \"abc\" } let obj : { prop1 : \"a\" } & { prop2 : \"b\" } Lier des interfaces interface Flower { pollen : true ; type : \"vegetal\" } interface Rose extends Flower { color : string ; thorn : boolean ; } const RedRose : Rose = { pollen : true , type : \"vegetal\" , color : \"Rose\" , thorn : true } Union discriminante type Japan = { lang : \"JA\" ; food : string []; } type Italy = { lang : \"IT\" ; food : string []; } type Country = Japan | Italy ; const automaticResponse = ( country : Country ) => { if ( country . lang === \"JA\" ) { console . log ( \"Hello Japan\" ); } else if ( country . lang === \"IT\" ) { console . log ( \"Hello Italy\" ); } } const Japanese1 : Country = { lang : \"JA\" , food : [ \"Ramen\" , \"Sushis\" ] } automaticResponse ( Japanese1 ) Unknown number of props interface Group { [ name : string ] : object ; } const spainTrip : Group = { john : { id : 1 }, tom : { id : 2 }, julia : { id : 3 }, } 2- Op\u00e9rateurs L'op\u00e9rateur : ! const container = document . querySelector ( \".container\" ) ! ; // console.log(container.children); L'op\u00e9rateur : ? type Job = { title : string ; description? : string ; salary : number ; } const user1 : Job = { title : \"Dev Front-End\" , description : \"D\u00e9veloppeur de sites internet.\" , salary : 30000 } // console.log(user1?.description); Optional Parameter function message ( msg? : string ){ if ( msg ) { console . log ( msg ); } else { console . log ( \"No message provided\" ); } } // message(\"Hello World\") Optional interface property interface House { room : number ; price : number ; garage? : number ; } const house1 : House = { room : 4 , price : 300000 } ?? op\u00e9rateur const data = \"\" ; const display = data ?? \"Hello World\" console . log ( display ); // Never function alertUser ( msg : string ) : never { throw msg ; } alertUser ( \"Alerte, comportement dangereux\" ) 3- Overload type NumberOrString = number | string ; function combine ( a : number , b : number ) : number function combine ( a : number , b : string ) : string function combine ( a : string , b : number ) : string function combine ( a : string , b : string ) : string function combine ( a : NumberOrString , b : NumberOrString ){ if ( typeof a === \"string\" || typeof b === \"string\" ) { return a . toString () + b . toString () } else { return a + b ; } } console . log ( combine ( 50 , 1 )); 4- Les Generics Interface Reutilisable interface City < T > { name : string , pop : number , additionalData : T } const Londres : City < object > = { name : \"Londres\" , pop : 10 , additionalData : { area : 1572 } } const Paris : City < object [] > = { name : \"Paris\" , pop : 5 , additionalData : [{ underground : true , lines : 57 }, { restaurant : true Generics with functions const addRepairDate = < T extends object > ( obj : T ) => { const lastRepair = new Date () return {... obj , lastRepair } } const auto1 = addRepairDate ({ model : \"A1\" , km : 70000 , price : 10000 }) const auto2 = addRepairDate ({ model : \"A1\" , km : 70000 , price : 10000 , color : \"white\" }) console . log ( auto1 . model );","title":"TypeScript Avanced"},{"location":"pages/tools/typescript/advanced/#typescript-avanced","text":"","title":"TypeScript Avanced"},{"location":"pages/tools/typescript/advanced/#type-et-interface","text":"Intersection type Fish = { fin : number ; element : \"water\" ; gills : true ; } type Shark = { weight : number ; length : number ; } type HammerheadShark = Fish & Shark & { test : \"abc\" }; const shark1 : HammerheadShark = { fin : 3 , element : \"water\" , gills : true , weight : 500 , length : 200 , test : \"abc\" } let obj : { prop1 : \"a\" } & { prop2 : \"b\" } Lier des interfaces interface Flower { pollen : true ; type : \"vegetal\" } interface Rose extends Flower { color : string ; thorn : boolean ; } const RedRose : Rose = { pollen : true , type : \"vegetal\" , color : \"Rose\" , thorn : true } Union discriminante type Japan = { lang : \"JA\" ; food : string []; } type Italy = { lang : \"IT\" ; food : string []; } type Country = Japan | Italy ; const automaticResponse = ( country : Country ) => { if ( country . lang === \"JA\" ) { console . log ( \"Hello Japan\" ); } else if ( country . lang === \"IT\" ) { console . log ( \"Hello Italy\" ); } } const Japanese1 : Country = { lang : \"JA\" , food : [ \"Ramen\" , \"Sushis\" ] } automaticResponse ( Japanese1 ) Unknown number of props interface Group { [ name : string ] : object ; } const spainTrip : Group = { john : { id : 1 }, tom : { id : 2 }, julia : { id : 3 }, }","title":"Type et Interface"},{"location":"pages/tools/typescript/advanced/#2-operateurs","text":"L'op\u00e9rateur : ! const container = document . querySelector ( \".container\" ) ! ; // console.log(container.children); L'op\u00e9rateur : ? type Job = { title : string ; description? : string ; salary : number ; } const user1 : Job = { title : \"Dev Front-End\" , description : \"D\u00e9veloppeur de sites internet.\" , salary : 30000 } // console.log(user1?.description); Optional Parameter function message ( msg? : string ){ if ( msg ) { console . log ( msg ); } else { console . log ( \"No message provided\" ); } } // message(\"Hello World\") Optional interface property interface House { room : number ; price : number ; garage? : number ; } const house1 : House = { room : 4 , price : 300000 } ?? op\u00e9rateur const data = \"\" ; const display = data ?? \"Hello World\" console . log ( display ); // Never function alertUser ( msg : string ) : never { throw msg ; } alertUser ( \"Alerte, comportement dangereux\" )","title":"2- Op\u00e9rateurs"},{"location":"pages/tools/typescript/advanced/#3-overload","text":"type NumberOrString = number | string ; function combine ( a : number , b : number ) : number function combine ( a : number , b : string ) : string function combine ( a : string , b : number ) : string function combine ( a : string , b : string ) : string function combine ( a : NumberOrString , b : NumberOrString ){ if ( typeof a === \"string\" || typeof b === \"string\" ) { return a . toString () + b . toString () } else { return a + b ; } } console . log ( combine ( 50 , 1 ));","title":"3- Overload"},{"location":"pages/tools/typescript/advanced/#4-les-generics","text":"Interface Reutilisable interface City < T > { name : string , pop : number , additionalData : T } const Londres : City < object > = { name : \"Londres\" , pop : 10 , additionalData : { area : 1572 } } const Paris : City < object [] > = { name : \"Paris\" , pop : 5 , additionalData : [{ underground : true , lines : 57 }, { restaurant : true Generics with functions const addRepairDate = < T extends object > ( obj : T ) => { const lastRepair = new Date () return {... obj , lastRepair } } const auto1 = addRepairDate ({ model : \"A1\" , km : 70000 , price : 10000 }) const auto2 = addRepairDate ({ model : \"A1\" , km : 70000 , price : 10000 , color : \"white\" }) console . log ( auto1 . model );","title":"4- Les Generics"},{"location":"pages/tools/typescript/classes/","text":"Class Base class Book { title : string ; price : number ; dateOfParution : string ; author : string ; theme? : string [] constructor ( t : string , p : number , dop : string , a : string , th? : string []) { this . title = t ; this . price = p ; this . dateOfParution = dop ; this . author = a ; this . theme = th ; } promo (){ return this . price * 0.5 ; } } const book1 = new Book ( \"The Great Gatsby\" , 20 , \"11/04/1955\" , \"Tom Joe\" ); // console.log(book1); // console.log(book1.promo()); const addToShelter = ( obj : Book ) => { console . log ( \"ADDED TO SHELTER\" , obj ); } // addToShelter(new Book(\"Nana\", 5, \"12/07/1905\", \"Zola\", // [\"Roman Historique\", \"Roman\"])) let onlyBook : Book [] = []; onlyBook . push ( new Book ( \"Nana\" , 5 , \"12/07/1905\" , \"Zola\" , [ \"Roman Historique\" , \"Roman\" ])) console . log ( onlyBook ); Les champs class Book { private bookID = 88 readonly libraryName = \"The Book Shelf\" constructor ( public title : string , public price : number , public dateOfParution : string , public author : string , public theme? : string [] ) {} promo (){ console . log ( \"ID\" , this . bookID ); console . log ( \"NAME\" , this . libraryName ); // this.libraryName = 500 return this . price * 0.5 ; } } const book1 = new Book ( \"The Great Gatsby\" , 20 , \"11/04/1955\" , \"Tom Joe\" ); console . log ( book1 ); console . log ( book1 . promo ()); console . log ( book1 . libraryName ); const addToShelter = ( obj : Book ) => { console . log ( \"ADDED TO SHELTER\" , obj ); } // addToShelter(new Book(\"Nana\", 5, \"12/07/1905\", \"Zola\", // [\"Roman Historique\", \"Roman\"])) let onlyBook : Book [] = []; onlyBook . push ( new Book ( \"Nana\" , 5 , \"12/07/1905\" , \"Zola\" , [ \"Roman Historique\" , \"Roman\" ])) // console.log(onlyBook); // Syntaxe sans raccourci class Book { title : string ; price : number ; dateOfParution : string ; author : string ; theme? : string []; private bookID = 88 readonly libraryName = \"The Book Shelf\" constructor ( t : string , p : number , dop : string , a : string , th? : string []) { this . title = t ; this . price = p ; this . dateOfParution = dop ; this . author = a ; this . theme = th ; } promo (){ console . log ( \"ID\" , this . bookID ); console . log ( \"NAME\" , this . libraryName ); this . libraryName = 500 return this . price * 0.5 ; } } Les Interfaces et Classes interface Country { name : string ; population : number ; lang : string [] } class Norway implements Country { constructor ( public name : string , public population : number , public lang : string [], public Capital : string ) {} } const NorwayData = new Norway ( 'Norway' , 9 , [ \"Norwegian\" ], \"Oslo\" ) console . log ( NorwayData ); class France implements Country { constructor ( public name : string , public population : number , public lang : string [] ) {} } const FranceData = new France ( 'France' , 70 , [ \"Fran\u00e7ais\" , \"Breton\" , \"Basque\" ] ) console . log ( FranceData ); class Aquitaine extends France {} const AquitaineData = new Aquitaine ( \"Aquitaine\" , 4 , [ \"Fran\u00e7ais\" , \"Basque\" , \"Gascon\" ] )","title":"Class"},{"location":"pages/tools/typescript/classes/#class","text":"","title":"Class"},{"location":"pages/tools/typescript/classes/#base","text":"class Book { title : string ; price : number ; dateOfParution : string ; author : string ; theme? : string [] constructor ( t : string , p : number , dop : string , a : string , th? : string []) { this . title = t ; this . price = p ; this . dateOfParution = dop ; this . author = a ; this . theme = th ; } promo (){ return this . price * 0.5 ; } } const book1 = new Book ( \"The Great Gatsby\" , 20 , \"11/04/1955\" , \"Tom Joe\" ); // console.log(book1); // console.log(book1.promo()); const addToShelter = ( obj : Book ) => { console . log ( \"ADDED TO SHELTER\" , obj ); } // addToShelter(new Book(\"Nana\", 5, \"12/07/1905\", \"Zola\", // [\"Roman Historique\", \"Roman\"])) let onlyBook : Book [] = []; onlyBook . push ( new Book ( \"Nana\" , 5 , \"12/07/1905\" , \"Zola\" , [ \"Roman Historique\" , \"Roman\" ])) console . log ( onlyBook );","title":"Base"},{"location":"pages/tools/typescript/classes/#les-champs","text":"class Book { private bookID = 88 readonly libraryName = \"The Book Shelf\" constructor ( public title : string , public price : number , public dateOfParution : string , public author : string , public theme? : string [] ) {} promo (){ console . log ( \"ID\" , this . bookID ); console . log ( \"NAME\" , this . libraryName ); // this.libraryName = 500 return this . price * 0.5 ; } } const book1 = new Book ( \"The Great Gatsby\" , 20 , \"11/04/1955\" , \"Tom Joe\" ); console . log ( book1 ); console . log ( book1 . promo ()); console . log ( book1 . libraryName ); const addToShelter = ( obj : Book ) => { console . log ( \"ADDED TO SHELTER\" , obj ); } // addToShelter(new Book(\"Nana\", 5, \"12/07/1905\", \"Zola\", // [\"Roman Historique\", \"Roman\"])) let onlyBook : Book [] = []; onlyBook . push ( new Book ( \"Nana\" , 5 , \"12/07/1905\" , \"Zola\" , [ \"Roman Historique\" , \"Roman\" ])) // console.log(onlyBook); // Syntaxe sans raccourci class Book { title : string ; price : number ; dateOfParution : string ; author : string ; theme? : string []; private bookID = 88 readonly libraryName = \"The Book Shelf\" constructor ( t : string , p : number , dop : string , a : string , th? : string []) { this . title = t ; this . price = p ; this . dateOfParution = dop ; this . author = a ; this . theme = th ; } promo (){ console . log ( \"ID\" , this . bookID ); console . log ( \"NAME\" , this . libraryName ); this . libraryName = 500 return this . price * 0.5 ; } }","title":"Les champs"},{"location":"pages/tools/typescript/classes/#les-interfaces-et-classes","text":"interface Country { name : string ; population : number ; lang : string [] } class Norway implements Country { constructor ( public name : string , public population : number , public lang : string [], public Capital : string ) {} } const NorwayData = new Norway ( 'Norway' , 9 , [ \"Norwegian\" ], \"Oslo\" ) console . log ( NorwayData ); class France implements Country { constructor ( public name : string , public population : number , public lang : string [] ) {} } const FranceData = new France ( 'France' , 70 , [ \"Fran\u00e7ais\" , \"Breton\" , \"Basque\" ] ) console . log ( FranceData ); class Aquitaine extends France {} const AquitaineData = new Aquitaine ( \"Aquitaine\" , 4 , [ \"Fran\u00e7ais\" , \"Basque\" , \"Gascon\" ] )","title":"Les Interfaces et Classes"},{"location":"pages/tools/typescript/conditional/","text":"Conditional type Create a basic component with conditional props Create types interface CircleProps { shape : 'circle' ; radius : number ; } interface SquareProps { shape : 'square' ; width : number ; } interface ReactangleProps { shape : 'rectangle' ; width : number ; height : number ; } Here shape is the differ property Create the conditional type type DrawerProps = CircleProps | SquareProps | ReactangleProps ; Use DrawerProps in a component function Drawer ( props : DrawerProps ) { return ( < div > < h1 > '{props.shape}' Shape with props condition < /h1> { props . shape === 'circle' && < p > Radius : { props . radius } < /p>} { props . shape === 'square' && < p > Width : { props . width } < /p>} { props . shape === 'rectangle' && < p > Width : { props . width } - Height : { props . height } < /p>} < /div> ); } Simplier way to create DrawerProps type DrawerProps = { shape : 'circle' ; radius : number } | { shape : 'square' ; width : number } | { shape : 'rectangle' ; width : number ; height : number } ); Now add a common property : fullname with & : DrawerProps with fullname type DrawerProps = { fullname : string } & ( | { shape : 'circle' ; radius : number } | { shape : 'square' ; width : number } | { shape : 'rectangle' ; width : number ; height : number } ); Create the final component : Drawer.tsx function Drawer ( props : DrawerProps ) { return ( < Paper shadow = \"xs\" p = \"md\" > < Title order = { 1 } style = {{ color : \"brown\" }} > { props . fullname } < /Title> < Title order = { 5 } > '{props.shape}' Shape with props condition < /Title> { props . shape === 'circle' && < p > Radius : { props . radius } < /p>} { props . shape === 'square' && < p > Width : { props . width } < /p>} { props . shape === 'rectangle' && < p > Width : { props . width } - Height : { props . height } < /p>} < /Paper> ); } Use the Drawer component in an app : App.tsx import Drawer from './components/typescript/Drawer' ; function App () { return ( < Container size = \"lg\" style = {{ backgroundColor : \"orange\" }} > < h1 > Typescript exo < /h1> < Stack align = \"center\" > < Group position = \"left\" spacing = \"xs\" > < Drawer fullname = 'alberto' shape = 'square' width = { 10 } /> < Drawer fullname = 'coco' shape = 'circle' radius = { 10 } /> < Drawer fullname = 'bruno' shape = 'rectangle' width = { 10 } height = { 20 } /> < /Group> < /Stack> < /Container> ) } export default App Create a collapsed expanded component The purpose is to have collapsed OR expanded property and not accepting both at same time.","title":"Conditional type"},{"location":"pages/tools/typescript/conditional/#conditional-type","text":"","title":"Conditional type"},{"location":"pages/tools/typescript/conditional/#create-a-basic-component-with-conditional-props","text":"Create types interface CircleProps { shape : 'circle' ; radius : number ; } interface SquareProps { shape : 'square' ; width : number ; } interface ReactangleProps { shape : 'rectangle' ; width : number ; height : number ; } Here shape is the differ property Create the conditional type type DrawerProps = CircleProps | SquareProps | ReactangleProps ; Use DrawerProps in a component function Drawer ( props : DrawerProps ) { return ( < div > < h1 > '{props.shape}' Shape with props condition < /h1> { props . shape === 'circle' && < p > Radius : { props . radius } < /p>} { props . shape === 'square' && < p > Width : { props . width } < /p>} { props . shape === 'rectangle' && < p > Width : { props . width } - Height : { props . height } < /p>} < /div> ); } Simplier way to create DrawerProps type DrawerProps = { shape : 'circle' ; radius : number } | { shape : 'square' ; width : number } | { shape : 'rectangle' ; width : number ; height : number } ); Now add a common property : fullname with & : DrawerProps with fullname type DrawerProps = { fullname : string } & ( | { shape : 'circle' ; radius : number } | { shape : 'square' ; width : number } | { shape : 'rectangle' ; width : number ; height : number } ); Create the final component : Drawer.tsx function Drawer ( props : DrawerProps ) { return ( < Paper shadow = \"xs\" p = \"md\" > < Title order = { 1 } style = {{ color : \"brown\" }} > { props . fullname } < /Title> < Title order = { 5 } > '{props.shape}' Shape with props condition < /Title> { props . shape === 'circle' && < p > Radius : { props . radius } < /p>} { props . shape === 'square' && < p > Width : { props . width } < /p>} { props . shape === 'rectangle' && < p > Width : { props . width } - Height : { props . height } < /p>} < /Paper> ); } Use the Drawer component in an app : App.tsx import Drawer from './components/typescript/Drawer' ; function App () { return ( < Container size = \"lg\" style = {{ backgroundColor : \"orange\" }} > < h1 > Typescript exo < /h1> < Stack align = \"center\" > < Group position = \"left\" spacing = \"xs\" > < Drawer fullname = 'alberto' shape = 'square' width = { 10 } /> < Drawer fullname = 'coco' shape = 'circle' radius = { 10 } /> < Drawer fullname = 'bruno' shape = 'rectangle' width = { 10 } height = { 20 } /> < /Group> < /Stack> < /Container> ) } export default App","title":"Create a basic component with conditional props"},{"location":"pages/tools/typescript/conditional/#create-a-collapsed-expanded-component","text":"The purpose is to have collapsed OR expanded property and not accepting both at same time.","title":"Create a collapsed expanded component"},{"location":"pages/tools/typescript/introreact/","text":"Intro with react app.tsx import React , { useState , useRef , useEffect } from 'react' ; import Card from './components/Card' function App () { const [ cardsData , setCardsData ] = useState ([ { title : \"Picasso\" , content : \"Peintre XX\u00e8me si\u00e8cle\" , id : 1 }, { title : \"Van Gogh\" , content : \"Peintre XIX\u00e8me si\u00e8cle\" , id : 2 }, ]) const btnRef = useRef < HTMLButtonElement > ( null ) useEffect (() => { console . log ( btnRef ); const handleResize = ( e : Event ) => { console . log ( \"RESIZED\" , e ); } window . addEventListener ( \"resize\" , handleResize ); return () => { window . removeEventListener ( 'resize' , handleResize ) } }, []) return ( < div className = \"App\" > { cardsData . map (( item ) => ( < Card key = { item . id } title = { item . title } content = { item . content } /> ))} { /* <Card title=\"La Carte\" content=\"Le Contenu\" /> */ } < button ref = { btnRef } > Submit < /button> < /div> ); } export default App ; component/Card.tsx import React from 'react' type CardProps = { title : string ; content : string ; } // export default function Card(props: CardProps) { export default function Card ({ title , content } : CardProps ) { // console.log(props); return ( < div > < h1 > { title } < /h1> < p > { content } < /p> < /div> ) }","title":"Intro with react"},{"location":"pages/tools/typescript/introreact/#intro-with-react","text":"","title":"Intro with react"},{"location":"pages/tools/typescript/introreact/#apptsx","text":"import React , { useState , useRef , useEffect } from 'react' ; import Card from './components/Card' function App () { const [ cardsData , setCardsData ] = useState ([ { title : \"Picasso\" , content : \"Peintre XX\u00e8me si\u00e8cle\" , id : 1 }, { title : \"Van Gogh\" , content : \"Peintre XIX\u00e8me si\u00e8cle\" , id : 2 }, ]) const btnRef = useRef < HTMLButtonElement > ( null ) useEffect (() => { console . log ( btnRef ); const handleResize = ( e : Event ) => { console . log ( \"RESIZED\" , e ); } window . addEventListener ( \"resize\" , handleResize ); return () => { window . removeEventListener ( 'resize' , handleResize ) } }, []) return ( < div className = \"App\" > { cardsData . map (( item ) => ( < Card key = { item . id } title = { item . title } content = { item . content } /> ))} { /* <Card title=\"La Carte\" content=\"Le Contenu\" /> */ } < button ref = { btnRef } > Submit < /button> < /div> ); } export default App ;","title":"app.tsx"},{"location":"pages/tools/typescript/introreact/#componentcardtsx","text":"import React from 'react' type CardProps = { title : string ; content : string ; } // export default function Card(props: CardProps) { export default function Card ({ title , content } : CardProps ) { // console.log(props); return ( < div > < h1 > { title } < /h1> < p > { content } < /p> < /div> ) }","title":"component/Card.tsx"},{"location":"pages/tools/typescript/start/","text":"TypeScript Start 1-Types let str = \"str\" let num = 5 let array = [] let obj = { a : 5 } let toggle = true let anything ; let randomNumber : number ; const conversion = ( celsius : number ) => { return ( celsius * 9 / 5 ) + 32 ; } console . log ( conversion ( 50 )); version ( 50 )); 2- Array and Object Array const fruits = [ 'fraise' , 'pomme' ] fruits . push ( \"cerises\" ) console . log ( fruits ); const mixedArray = [ 1 , 'txt' , [ 1 , 2 , 3 ]] let nums : number []; nums . push ( 1 ) // erreur nums = [ 1 , 2 , 3 ] let nums2 : number [] = [] nums2 . push ( 2 ) let random : any []; random = [ true , false , true ] Object const car = { name : \"Audi\" , model : \"A1\" , km : 70000 } car . name = 4 // erreur let profile : { name : string , age : number , hobbies : string [] } profile = { name : \"John\" , age : 85 , hobbies : [] } let user : { name : string , age : number , favFood : string [], data : any } = { name : \"Joe\" , age : 45 , favFood : [ 'pasta' , 'cheese' ], data : 50 } let obj : object ; obj = { name : \"Enzo\" } 3- Functions function multiply ( num1 : number , num2 = 10 , action? : string ) { if ( action ) console . log ( action ); return num1 * num2 ; } console . log ( multiply ( 6 , 10 , \"create\" )); let foo : Function ; foo = () => {} Function signatures let baz : ( a : number , b : number ) => number ; baz = ( a , b ) => a + b ; // Callback function greetings ( fn : ( a : string ) => void ) { fn ( \"Hello World\" ) } function printToConsole ( msg : string ) { console . log ( msg ); } greetings ( printToConsole ) 4- Union and custom types Unions let code : string | number | boolean | object | Function ; code = 5 let arr : ( boolean | number )[] arr = [ true , false , 999 ] const foo = ( param : number | string ) => { console . log ( param ); } foo ( 'Test' ) Custom types type mixedNumStr = number | string ; type booleanOrObject = boolean | object ; const baz = ( param : mixedNumStr | booleanOrObject ) => { console . log ( param ); } baz ( true ) type element = { x : number ; y : number ; id : number | string ; visible : boolean ; } const button : element = { x : 99 , y : 50 , id : 999 , visible : true } 5- Tuple and Enum Tuple let tuple : [ boolean , number ] tuple = [ false , 20 ] Enum const Roles = { JAVASCRIPT : 1 , CSS : 2 , REACT : 3 } console . log ( Roles . JAVASCRIPT ); enum Roles { JAVASCRIPT = 1 , CSS , REACT } console . log ( Roles ); 6- Interfaces interface Rocket { reactors : number ; vMax : number ; takeOff : ( action : string ) => void } interface Rocket { price : number ; carburant : number ; } class RocketFactory implements Rocket { reactors : number ; vMax : number ; price : number ; carburant : number ; constructor ( reactors : number , vMax : number , price : number , carburant : number ) { this . reactors = reactors ; this . vMax = vMax ; this . price = price ; this . carburant = carburant ; } takeOff ( action : string ){ console . log ( action ); } } const Falcon1 = new RocketFactory ( 12 , 900 , 2 , 9000 ) console . log ( Falcon1 ); Falcon1 . takeOff ( 'D\u00e9collage' ) 7- DOM Type Assertion let txt : string ; txt = \"str\" Assertion const form : HTMLFormElement = document . querySelector ( 'form' ) ! console . log ( form . children ); Type Casting const form = document . querySelector ( 'form' ) as HTMLFormElement console . log ( form . children ); const input = document . querySelector ( 'input' ) as HTMLInputElement form . addEventListener ( 'submit' , handleSubmit ) function handleSubmit ( event : Event ){ event . preventDefault () console . log ( \"SUBMITTED\" ); } window . addEventListener ( 'click' , handleClick ) function handleClick ( event : MouseEvent ) { console . log ( event . clientX , event . clientY ); } const paragraphsList = document . querySelectorAll ( 'p' );","title":"TypeScript Start"},{"location":"pages/tools/typescript/start/#typescript-start","text":"","title":"TypeScript Start"},{"location":"pages/tools/typescript/start/#1-types","text":"let str = \"str\" let num = 5 let array = [] let obj = { a : 5 } let toggle = true let anything ; let randomNumber : number ; const conversion = ( celsius : number ) => { return ( celsius * 9 / 5 ) + 32 ; } console . log ( conversion ( 50 )); version ( 50 ));","title":"1-Types"},{"location":"pages/tools/typescript/start/#2-array-and-object","text":"Array const fruits = [ 'fraise' , 'pomme' ] fruits . push ( \"cerises\" ) console . log ( fruits ); const mixedArray = [ 1 , 'txt' , [ 1 , 2 , 3 ]] let nums : number []; nums . push ( 1 ) // erreur nums = [ 1 , 2 , 3 ] let nums2 : number [] = [] nums2 . push ( 2 ) let random : any []; random = [ true , false , true ] Object const car = { name : \"Audi\" , model : \"A1\" , km : 70000 } car . name = 4 // erreur let profile : { name : string , age : number , hobbies : string [] } profile = { name : \"John\" , age : 85 , hobbies : [] } let user : { name : string , age : number , favFood : string [], data : any } = { name : \"Joe\" , age : 45 , favFood : [ 'pasta' , 'cheese' ], data : 50 } let obj : object ; obj = { name : \"Enzo\" }","title":"2- Array and Object"},{"location":"pages/tools/typescript/start/#3-functions","text":"function multiply ( num1 : number , num2 = 10 , action? : string ) { if ( action ) console . log ( action ); return num1 * num2 ; } console . log ( multiply ( 6 , 10 , \"create\" )); let foo : Function ; foo = () => {} Function signatures let baz : ( a : number , b : number ) => number ; baz = ( a , b ) => a + b ; // Callback function greetings ( fn : ( a : string ) => void ) { fn ( \"Hello World\" ) } function printToConsole ( msg : string ) { console . log ( msg ); } greetings ( printToConsole )","title":"3- Functions"},{"location":"pages/tools/typescript/start/#4-union-and-custom-types","text":"Unions let code : string | number | boolean | object | Function ; code = 5 let arr : ( boolean | number )[] arr = [ true , false , 999 ] const foo = ( param : number | string ) => { console . log ( param ); } foo ( 'Test' ) Custom types type mixedNumStr = number | string ; type booleanOrObject = boolean | object ; const baz = ( param : mixedNumStr | booleanOrObject ) => { console . log ( param ); } baz ( true ) type element = { x : number ; y : number ; id : number | string ; visible : boolean ; } const button : element = { x : 99 , y : 50 , id : 999 , visible : true }","title":"4- Union and custom types"},{"location":"pages/tools/typescript/start/#5-tuple-and-enum","text":"Tuple let tuple : [ boolean , number ] tuple = [ false , 20 ] Enum const Roles = { JAVASCRIPT : 1 , CSS : 2 , REACT : 3 } console . log ( Roles . JAVASCRIPT ); enum Roles { JAVASCRIPT = 1 , CSS , REACT } console . log ( Roles );","title":"5- Tuple and Enum"},{"location":"pages/tools/typescript/start/#6-interfaces","text":"interface Rocket { reactors : number ; vMax : number ; takeOff : ( action : string ) => void } interface Rocket { price : number ; carburant : number ; } class RocketFactory implements Rocket { reactors : number ; vMax : number ; price : number ; carburant : number ; constructor ( reactors : number , vMax : number , price : number , carburant : number ) { this . reactors = reactors ; this . vMax = vMax ; this . price = price ; this . carburant = carburant ; } takeOff ( action : string ){ console . log ( action ); } } const Falcon1 = new RocketFactory ( 12 , 900 , 2 , 9000 ) console . log ( Falcon1 ); Falcon1 . takeOff ( 'D\u00e9collage' )","title":"6- Interfaces"},{"location":"pages/tools/typescript/start/#7-dom","text":"Type Assertion let txt : string ; txt = \"str\" Assertion const form : HTMLFormElement = document . querySelector ( 'form' ) ! console . log ( form . children ); Type Casting const form = document . querySelector ( 'form' ) as HTMLFormElement console . log ( form . children ); const input = document . querySelector ( 'input' ) as HTMLInputElement form . addEventListener ( 'submit' , handleSubmit ) function handleSubmit ( event : Event ){ event . preventDefault () console . log ( \"SUBMITTED\" ); } window . addEventListener ( 'click' , handleClick ) function handleClick ( event : MouseEvent ) { console . log ( event . clientX , event . clientY ); } const paragraphsList = document . querySelectorAll ( 'p' );","title":"7- DOM"}]}